"""
Created on September 1st, 2017
@author: rouxpn
"""

import os
import sys
import re 
from shutil import copyfile 
import fileinput 
from decimal import Decimal
import xml.etree.ElementTree as ET 
from xml.etree.ElementTree import Element, SubElement, Comment
from xml.dom import minidom
from random import *

class XSCreator():

  def tabMapping(self, tab):
    """
      link the tabulation number to the actual tabulation points 
      IN: tab: string (tabulation number)
      OUT: tabList, valueList: lists (all the tabulation parameters gathered in a list,
      and the tabulation values in another list)
    """
    mappingTree = ET.parse('tabMapping.xml')
    mappingRoot = mappingTree.getroot()
    for tabulationXML in mappingRoot.getiterator('tabulation'):
      if tab == tabulationXML.attrib.get('set'):
        tabList = []
        valueList = []
        for tabXML in tabulationXML.getiterator('tab'):
          tabList.append(tabXML.attrib.get('name')) 
          valueList.append(tabXML.text) 
    return tabList, valueList
    
  def prettify(self, elem):
    """
      Return a pretty-printed XML string for the Element.
    """
    rough_string = ET.tostring(elem, 'utf-8')
    reparsed = minidom.parseString(rough_string)
    return reparsed.toprettyxml(indent="  ")
   
  def generateRandomName(self):
    """
      generate a random file name for the modified file
      @ in, None
      @ Out, string
    """
    return str(randint(1,1000000000000))+'.xml'
    
  def generateXML(self):
    """
      create an XML file from the interface  
      In: None
      Out: XS.xml (xml file) 
    """
    top = Element('scaling_library')
    
    comment = Comment('Generated by rouxpn')
    top.append(comment)
    #print self.listedDict
    for XS in self.listedDict.iterkeys():
      for tabulation in self.listedDict.get('XS').iterkeys():
        topChild = SubElement(top, 'set')
        tabList, valueList = self.tabMapping(tabulation)
        if self.booleanTab is True:
          for i in xrange (0,len(tabList)):
            tabChild = SubElement(topChild, 'tab', {'name':tabList[i]})
            tabChild.text = valueList[i] 
        for material in self.listedDict.get('XS').get(tabulation).iterkeys():
          tabulationChild = SubElement(topChild, 'library', {'lib_name':material.lower()})
          for isotope in self.listedDict.get('XS').get(tabulation).get(material).iterkeys():
            for type in self.listedDict.get('XS').get(tabulation).get(material).get(isotope).iterkeys():
              libraryChild = SubElement(tabulationChild, 'isotope', {'id':isotope.lower(), 'type':type.lower()})
              for reaction in self.listedDict.get('XS').get(tabulation).get(material).get(isotope).get(type).iterkeys():
                groupList = [] 
                valueList = []
                count = 0 
                for group,value in self.listedDict.get('XS').get(tabulation).get(material).get(isotope).get(type).get(reaction).iteritems():
                  count = count + 1 
                  numberOfGroupsPerturbed = len(self.listedDict.get('XS').get(tabulation).get(material).get(isotope).get(type).get(reaction).keys())
                  groupList.append(group)
                  valueList.append(value)
                  group.join(',')
                  if count == numberOfGroupsPerturbed:
                    groups = ','.join(str(e) for e in groupList)
                    values = ','.join(str(f) for f in valueList)
                    #print groups
                    #print values
                    reactionChild = SubElement(libraryChild, reaction.lower(), {'g':groups})
                    reactionChild.text = values
    
    modifiedFile = self.generateRandomName()
    file_obj = open(modifiedFile, 'w')
    file_obj.write(self.prettify(top))
    #print self.prettify(top)
    return modifiedFile
  
  def clean_empty(self, leanDict):
    """
      remove all the empty string in the nested dictionary reconstructedDict  
      In: reconstructedDict  (nested dictionary)
      Out: leanReconstructedDict (nested dictionary) 
    """
    if not isinstance(leanDict, (dict, list)):
        return leanDict
    if isinstance(leanDict, list):
        return [v for v in (self.clean_empty(v) for v in leanDict) if v]
    return {k: v for k, v in ((k, self.clean_empty(v)) for k, v in leanDict.items()) if v} 

   
  def __init__(self, inputFiles, booleanTab, **pertDict):
    """
      Parse the PHISICS XS.xml data file   
      In: XS.xml
      Out: None 
    """
    self.booleanTab = booleanTab
    self.pertDict = pertDict
    #print self.pertDict
    #print "\n\n\n"
    #print inputFiles
    
    for key, value in self.pertDict.iteritems(): 
      self.pertDict[key] = '%.5E' % Decimal(str(value)) #convert the values into scientific values   
    self.inputFiles = inputFiles
    self.tree = ET.parse(self.inputFiles)
    self.root = self.tree.getroot()
    self.listedDict = self.fileReconstruction(self.pertDict)
    modifiedFile = self.generateXML()
    self.printInput(modifiedFile)

  def fileReconstruction(self, deconstructedDict):
    """
      Converts the formatted dictionary -> {'XS|FUEL1|U235|FISSION|1':1.30, 'XS|FUEL2|U238|ABS|2':4.69} 
      into a dictionary of dictionaries that has the format -> {'XS':{'FUEL1':{'U235':{'FISSION':{'1':1.30}}}}, 'FUEL2':{'U238':{'ABS':{'2':4.69}}}}
      In: Dictionary deconstructedDict
      Out: Dictionary of dictionaries reconstructedDict 
    """
    #print deconstructedDict
    reconstructedDict           = {}
    perturbedPhysicalParameters = []
    perturbedTabulationPoint    = []
    perturbedMaterials          = []
    perturbedIsotopes           = []
    perturbedTypes              = []
    perturbedReactions          = []
    perturbedGroups             = []
    
    
    pertDictSet = set(self.pertDict)
    deconstructedDictSet = set(deconstructedDict)
    #for variable in pertDictSet.intersection(deconstructedDictSet):
    for i in pertDictSet.intersection(deconstructedDictSet): 
      splittedKeywords = i.split('|')
      perturbedPhysicalParameters.append(splittedKeywords[0])
      perturbedTabulationPoint.append(splittedKeywords[1])
      perturbedMaterials.append(splittedKeywords[2])
      perturbedIsotopes.append(splittedKeywords[3])
      perturbedTypes.append(splittedKeywords[4])
      perturbedReactions.append(splittedKeywords[5])
      perturbedGroups.append(splittedKeywords[6])  
    
    #print perturbedReactions
    for i in xrange (0,len(perturbedPhysicalParameters)):
      reconstructedDict[perturbedPhysicalParameters[i]] = {}
      for j in xrange (0,len(perturbedTabulationPoint)):
        reconstructedDict[perturbedPhysicalParameters[i]][perturbedTabulationPoint[j]] = {} 
        for k in xrange (0,len(perturbedMaterials)):
          reconstructedDict[perturbedPhysicalParameters[i]][perturbedTabulationPoint[j]][perturbedMaterials[k]] = {}
          for l in xrange (0,len(perturbedIsotopes)):
            reconstructedDict[perturbedPhysicalParameters[i]][perturbedTabulationPoint[j]][perturbedMaterials[k]][perturbedIsotopes[l]] = {} 
            for m in xrange (0,len(perturbedReactions)):
              reconstructedDict[perturbedPhysicalParameters[i]][perturbedTabulationPoint[j]][perturbedMaterials[k]][perturbedIsotopes[l]][perturbedTypes[m]] = {} 
              for n in xrange (0,len(perturbedReactions)):
                reconstructedDict[perturbedPhysicalParameters[i]][perturbedTabulationPoint[j]][perturbedMaterials[k]][perturbedIsotopes[l]][perturbedTypes[m]][perturbedReactions[n]] = {}
                for o in xrange (0,len(perturbedGroups)):
                  reconstructedDict[perturbedPhysicalParameters[i]][perturbedTabulationPoint[j]][perturbedMaterials[k]][perturbedIsotopes[l]][perturbedTypes[m]][perturbedReactions[n]][perturbedGroups[o]] = {}
    #print reconstructedDict
    for typeKey, value in deconstructedDict.iteritems():
      if typeKey in pertDictSet:
        keyWords = typeKey.split('|')
        #print keyWords
        reconstructedDict[keyWords[0]][keyWords[1]][keyWords[2]][keyWords[3]][keyWords[4]][keyWords[5]][keyWords[6]] = value
    #print reconstructedDict  
    leanReconstructedDict = self.clean_empty(reconstructedDict)
    #print leanReconstructedDict
    return leanReconstructedDict
    
  def removeRandomlyNamedFiles(self, modifiedFile):
    """
      Remove the temporary file with a random name in the working directory
      In, modifiedFile, string
      Out, None 
    """
    os.remove(modifiedFile) 
    
  def printInput(self, modifiedFile):
    """
      Method to print out the new input
      @ In, outfile, string, optional, output file root
      @ Out, None
    """     
    #print self.inputFiles
    copyfile(modifiedFile, self.inputFiles)  
    self.removeRandomlyNamedFiles(modifiedFile)
   

