%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%% Saphire Interface %%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{SAPHIRE Interface}
\label{subsec:saphireInterface}
This section covers the input specification for running SAPHIRE through RAVEN. It is important to notice
that this short explanation assumes that the reader already knows how to use SAPHIRE.

\subsubsection{Files}
In the \xmlNode{Files} section, as specified before, all the files needed for the code to
run should be specified. In the case of SAPHIRE, the files typically needed are the following:
\begin{itemize}
  \item SAPHIRE compressed project inputs with file extension `.zip';
  \item SAPHIRE macro input file with file extension `.mac'.
\end{itemize}

Example:
\begin{lstlisting}[style=XML]
  <Files>
    <Input name="macro" type="">changeSet.mac</Input>
    <Input name="saphireInput" type="">saphireInput.zip</Input>
  </Files>
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%X
\subsubsection{Models}
In the \xmlNode{Models} block SAPHIRE executable needs to be specified. Here is a standard example of what
can be used:
\begin{lstlisting}[style=XML]
  <Models>
    <Code name="saphire" subType="Saphire">
      <executable>"C:\Saphire 8\tools\SAPHIRE.exe"</executable>
      <clargs arg="macro" extension=".mac" type="input" delimiter="="/>
      <clargs arg="project" extension=".zip" type="input" delimiter="="/>
      <outputFile>fixed_output.csv</outputFile>
      <codeOutput type="uncertainty">et_uq.csv</codeOutput>
      <codeOutput type="uncertainty">ft_uq.csv</codeOutput>
    </Code>
  </Models>
\end{lstlisting}

The \xmlNode{Code} XML node contains the information needed to execute the specific External Code. This
XML node accepts the following attributes:
\begin{itemize}
  \item \xmlAttr{name}, \xmlDesc{required string attribute}, user-defined identifier of this model.
    \nb As with other objects, this identifier can be used to reference this specific entity from other input
    blocks in the XML.
  \item \xmlAttr{subType}, \xmlDesc{required string attribute}, specifies the code that needs to be
    associated to this Model.
\end{itemize}
This model can be initialized with the following children:
\begin{itemize}
  \item \xmlNode{executable}, \xmlDesc{string, required field}, specifies the path of the executable to
    be used; \nb Either an absolute or relative path can be used.
  \item \xmlNode{clargs}, \xmlDesc{string, required field}, allows addition of command-line arguments to
    the execution command. This node is used to specify the input files that are required by SAPHIRE.
    This node accepts the following attributes:
    \begin{itemize}
      \item \xmlAttr{type}, \xmlDesc{require string attribute}, specifies the type of command-line argument
        to add. The current option is \xmlString{input}
      \item \xmlAttr{arg}, \xmlDesc{string, required field} specifies the flag to be used before the entry.
      \item \xmlAttr{extension}, \xmlDesc{string, required field}, specifies the type of file extension
        to use. This links the \xmlNode{Input} file in the \xmlNode{Steps} to this location in the execution
        command. Currently only accepts `.zip' and `.mac'.
      \item \xmlAttr{delimiter}, \xmlDesc{string, required field}, uses to link the \xmlAttr{arg} and the
        \xmlNode{Input} with the extension given by \xmlAttr{extension}
    \end{itemize}
    \nb As shown in previous example, the following command will be generated:
    \begin{lstlisting}
      "C:\Saphire 8\tools\SAPHIRE.exe" project=path/to/saphireInput.zip macro=path/to/changeSet.mac
    \end{lstlisting}
  \item \xmlNode{outputFile}, \xmlDesc{string, optional field}, uses to specify the output file name (CSV only). In this case, the code
    interface always produce a CSV file named ``fixed\_output.csv''.
  \item \xmlNode{codeOutput}, \xmlDesc{string, required field}, uses to specify output file generated by SAPHIRE that will be processed
    via the code interface. The following attributes can be specified:
    \begin{itemize}
      \item \xmlAttr{type}, \xmlDesc{required string attribute}, the actual type of the provided file. The
        only type accepted here is \xmlString{uncertainty}
    \end{itemize}
\end{itemize}

In this example, two output files ``eq\_uq.csv'' amd ``ft\_uq.csv'' will be processed by the SAPHIRE code
interface, and the results will be saved in output file with name ``fixed\_output.csv''.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Distributions}
The \xmlNode{Distributions} block defines the distributions that are going to be used for the sampling
of the variables defined in the \xmlNode{Samplers} block. For all the possible distributions and all
their possible inputs, please see the chapter about Distributions (see~\ref{sec:distributions}).
%
Here we give a general example:
\begin{lstlisting}[style=XML]
  <Distributions>
    <Normal name="allEvents">
        <mean>0.1</mean>
        <sigma>0.025</sigma>
        <lowerBound>0.05</lowerBound>
        <upperBound>0.15</upperBound>
    </Normal>
    <Normal name="mov1Event">
        <mean>0.5</mean>
        <sigma>0.1</sigma>
        <lowerBound>0.3</lowerBound>
        <upperBound>0.8</upperBound>
    </Normal>
    <Normal name="single1">
        <mean>0.2</mean>
        <sigma>0.05</sigma>
        <lowerBound>0.1</lowerBound>
        <upperBound>0.3</upperBound>
    </Normal>
  </Distributions>
\end{lstlisting}

It is good practice to name the distribution similar to what kind of variable is going to be sampled.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Samplers}
In the \xmlNode{Samplers} block we want to define the variables that are going to be sampled.
The perturbation of the input of SAPHIRE MACRO is performed using the approach detailed in the
\textit{Generic Interface} section (see \ref{subsec:genericInterface}). This approach uses the
``wild-cards'' (placed in the original input files) for injecting the perturbed values. For example,
if one wants to perturb the event tree probabilities of the original input file, i.e.
\begin{lstlisting}[style=XML]
<change set>
  <unmark></unmark>
  <delete>
    <name>ALL-EVENTS</name>
  </delete>
  <add>
    <name>ALL-EVENTS</name>
    <description>Class change all events Change Set</description>
    <class>
      <event name>*</event name>
      <suscept>1</suscept>
      <probability>1.E-2</probability>
    </class>
  </add>
  <mark name>ALL-EVENTS</mark name>
  <generate></generate>
</change set>
...
<change set>
  <unmark></unmark>
  <delete>
    <name>MOV-1-EVENTS</name>
  </delete>
  <add>
    <name>MOV-1-EVENTS</name>
    <description>Class change subset events Change Set</description>
    <class>
      <event name>?-MOV-CC-1</event name>
      <calc type>1</calc type>
      <probability>5E-3</probability>
    </class>
  </add>
    <mark name>MOV-1-EVENTS</mark name>
    <generate></generate>
</change set>
...

<change set>
  <unmark></unmark>
  <delete>
    <name>SINGLE-1</name>
  </delete>
  <add>
    <name>SINGLE-1</name>
    <description>Single Event Change Set</description>
    <single>
      <event name>E-MOV-CC-A</event name>
      <calc type>1</calc type>
      <probability>4E-1</probability>
    </single>
  </add>
  <mark name>SINGLE-1</mark name>
  <generate></generate>
</change set>
\end{lstlisting}

One need to use the RAVEN ``wild-cards`` to inject the perturbed values, i.e.
\begin{lstlisting}[style=XML]
<change set>
  <unmark></unmark>
  <delete>
    <name>ALL-EVENTS</name>
  </delete>
  <add>
    <name>ALL-EVENTS</name>
    <description>Class change all events Change Set</description>
    <class>
      <event name>*</event name>
      <suscept>1</suscept>
      <probability>$RAVEN-allEventsPb$</probability>
    </class>
  </add>
  <mark name>ALL-EVENTS</mark name>
  <generate></generate>
</change set>
...
<change set>
  <unmark></unmark>
  <delete>
    <name>MOV-1-EVENTS</name>
  </delete>
  <add>
    <name>MOV-1-EVENTS</name>
    <description>Class change subset events Change Set</description>
    <class>
      <event name>?-MOV-CC-1</event name>
      <calc type>1</calc type>
      <probability>$RAVEN-mov1EventPb$</probability>
    </class>
  </add>
    <mark name>MOV-1-EVENTS</mark name>
    <generate></generate>
</change set>
...

<change set>
  <unmark></unmark>
  <delete>
    <name>SINGLE-1</name>
  </delete>
  <add>
    <name>SINGLE-1</name>
    <description>Single Event Change Set</description>
    <single>
      <event name>E-MOV-CC-A</event name>
      <calc type>1</calc type>
      <probability>$RAVEN-single1Pb$</probability>
    </single>
  </add>
  <mark name>SINGLE-1</mark name>
  <generate></generate>
</change set>
\end{lstlisting}

The RAVEN \xmlNode{Samplers} input will be

\textbf{Example}:
\begin{lstlisting}[style=XML]
  <Samplers>
    <MonteCarlo name="mcSaphire">
        <samplerInit>
            <limit>2</limit>
        </samplerInit>
        <variable name="allEventsPb">
            <distribution>allEvents</distribution>
        </variable>
        <variable name="mov1EventPb">
            <distribution>mov1Event</distribution>
        </variable>
        <variable name="single1Pb">
            <distribution>single1</distribution>
        </variable>
    </MonteCarlo>
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Steps}
In this section, the \xmlNode{MultiRun} will be used. As shown in the following, two SAPHIRE
input files listed in \xmlNode{Files} are linked here using \xmlNode{Input}, the \xmlNode{Model}
and \xmlNode{Sampler} defined in previous sections will be used in this \xmlNode{MultiRun}. The
outputs will be saved in the \textbf{DataObject} ``saphireDump'', and will be printed via
\textbf{OutStreams}.

\begin{lstlisting}[style=XML]
  <Steps>
    <MultiRun name="sample">
      <Input class="Files" type="">macro</Input>
      <Input class="Files" type="">saphireInput</Input>
      <Model class="Models" type="Code">saphire</Model>
      <Sampler class="Samplers" type="MonteCarlo">mcSaphire</Sampler>
      <Output class="DataObjects" type="PointSet">saphireDump</Output>
      <Output class="OutStreams" type="Print">saphirePrint</Output>
    </MultiRun>
  </Steps>
\end{lstlisting}
