\section{Models}
\label{sec:models}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% If you are confused by the input of this document, please make sure you see
% these defined commands first. There is no point writing the same thing over
% and over and over and over and over again, so these will help us reduce typos,
% by just editing a template sentence or paragraph.

% These should be organized according to whic section they are most often used
% e.g. kernelDescription should go under a heading for SVMs.
% This will take a bit of work, but if later things are added it will make
% finding the appropriate parameters easier.

\renewcommand{\nameDescription}
{
  \xmlAttr{name},
  \xmlDesc{required string attribute}, user-defined identifier of this model.
  \nb As with other objects, this identifier can be used to reference this
  specific entity from other input blocks in the XML.
}


\newcommand{\assemblerAttrDescription}[1]
{
    This XML node needs to contain the attributes:
    \begin{itemize}
      \item \xmlAttr{class}, \xmlDesc{required string attribute}, the main
        ``class'' of the #1.
        %
      \item \xmlAttr{type},  \xmlDesc{required string attribute}, the sub-type of the #1.
        %
    \end{itemize}
}


\newcommand{\aliasSystemDescription}[1]
{
  \xmlNode{alias} \xmlDesc{string, optional field} specifies alias for
  any variable of interest in the input or output space for the #1.
  %
  These aliases can be used anywhere in the RAVEN input to refer to the #1
  variables.
  %
  In the body of this node the user specifies the name of the variable that the model is going to use
  (during its execution).
  %
  The actual alias, usable throughout the RAVEN input, is instead defined in the
  \xmlAttr{variable} attribute of this tag.
  \\The user can specify aliases for both the input and the output space. As sanity check, RAVEN
  requires an additional required attribute \xmlAttr{type}. This attribute can be either ``input'' or ``output''.
  %
  \nb The user can specify as many aliases as needed.
  %
  \default{None}
}

\renewcommand{\specBlock}[2]{
  The specifications of this model must be defined within #1 \xmlNode{#2} XML
  block.
}
%
\renewcommand{\subnodeIntro}
{
  This model can be initialized with the following child:
}
\renewcommand{\subnodesIntro}
{
  This model can be initialized with the following children:
}

\newcommand{\ppType}[2]
{
  In order to use the \textit{#1} PP, the user needs to set the
  \xmlAttr{subType} of a \xmlNode{PostProcessor} node:

  \xmlNode{PostProcessor \xmlAttr{subType}=\xmlString{#2}/}.

   Several sub-nodes are available:
}

\newcommand{\skltype}[2]
{
  In order to use the \textit{#1}, the user needs to set the
  sub-node:

  \xmlNode{SKLtype}\texttt{#2}\xmlNode{/SKLtype}.

  In addition to this XML node, several others are available:
}

\newcommand{\nIterDescriptionA}[1]
{
  \xmlNode{n\_iter}, \xmlDesc{integer, optional field}, is the maximum number of
  iterations.
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}

\newcommand{\nIterDescriptionB}[1]
{
  \xmlNode{n\_iter}, \xmlDesc{int, optional field}, specifies the number of
  passes over the training data (aka epochs).
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}

\newcommand{\nIterNoChangeDescriptionA}[1]
{
  \xmlNode{n\_iter\_no\_change}, \xmlDesc{integer, optional field}, number of iterations with no improvement to wait before early stopping. 
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}

\newcommand{\tolDescriptionA}[1]
{
  \xmlNode{tol}, \xmlDesc{float, optional field}, stop the algorithm if the convergence error felt below the tolerance specified here.
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}

\newcommand{\tolDescriptionB}[1]
{
  \xmlNode{tol}, \xmlDesc{float, optional field}, specifies the tolerance for
  the optimization: if the updates are smaller than tol, the optimization code
  checks the dual gap for optimality and continues until it is smaller than tol.
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}

\newcommand{\tolDescriptionC}[1]
{
  \xmlNode{tol}, \xmlDesc{float, optional field}, specifies the tolerance for
  stopping criteria.
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}

\newcommand{\fitInterceptDescription}[1]
{
  \xmlNode{fit\_intercept}, \xmlDesc{boolean, optional field}, determines
  whether to calculate the intercept for this model.
  %
  If set to False, no intercept will be used in the calculations (e.g. data is
  expected to be already centered).
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}

\newcommand{\normalizeDescription}[1]
{
  \xmlNode{normalize}, \xmlDesc{boolean, optional field}, if True, the
  regressors X will be normalized before regression.
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}

\newcommand{\verDescriptionA}[1]
{
  \xmlNode{verbose}, \xmlDesc{boolean, optional field}, use verbose mode
  when fitting the model.
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}

\newcommand{\verDescriptionB}[1]
{
  \xmlNode{verbose}, \xmlDesc{boolean or integer, optional field}, use verbose
  mode when fitting the model.
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}

\newcommand{\maxIterDescription}[1]
{
\xmlNode{max\_iter}, \xmlDesc{integer, optional field}, specifies the
  maximum number of iterations.
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}

\newcommand{\warmStartDescription}[1]
{
  \xmlNode{warm\_start}, \xmlDesc{boolean, optional field}, when set to
  True, the model will reuse the solution of the previous call to fit as
  initialization, otherwise, it will just erase the previous solution.
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}

\newcommand{\positiveDescription}[1]
{
  \xmlNode{positive}, \xmlDesc{boolean, optional field}, when set to True, this
  forces the coefficients to be positive.
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}

\newcommand{\precomputeDescription}[1]
{
  \xmlNode{precompute}, \xmlDesc{boolean or string, optional field}, determines
  whether to use a precomputed Gram matrix to speed up calculations.
  %
  If set to `auto,' RAVEN will decide.
  %
  The Gram matrix can also be passed as an argument.
  %
  Available options are [True | False | `auto' | array-like].
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}

\newcommand{\nAlphasDescription}[1]
{
  \xmlNode{max\_n\_alphas}, \xmlDesc{integer, optional field}, specifies the
  maximum number of points on the path used to compute the residuals in the
  cross-validation.
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}

\newcommand{\shuffleDescription}[1]
{
  \xmlNode{shuffle}, \xmlDesc{boolean, optional field}, specifies whether
  or not the training data should be shuffled after each epoch.
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}

\newcommand{\randomStateDescription}[1]
{
  \xmlNode{random\_state}, \xmlDesc{int seed, RandomState instance, or None},
  sets the seed of the pseudo random number generator to use when shuffling the
  data.
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}

\newcommand{\solverDescription}%[1]
{
  \xmlNode{solver}, \xmlDesc{\{`auto', `svd', `cholesky', `lsqr',
  `sparse\_cg'\}}, specifies the solver to use in the computational routines:
  \begin{itemize}
    \item `auto' chooses the solver automatically based on the type of data.
    %
    \item `svd' uses a singular value decomposition of X to compute the ridge
    coefficients.
    %
    More stable for singular matrices than `cholesky.'
    %
    \item `cholesky' uses the standard scipy.linalg.solve function to obtain a
    closed-form solution.
    %
    \item `sparse\_cg' uses the conjugate gradient solver as found in
    scipy.sparse.linalg.cg.
    %
    As an iterative algorithm, this solver is more appropriate than
    `cholesky' for large-scale data (possibility to set tol and max\_iter).
    %
    \item `lsqr' uses the dedicated regularized least-squares routine
    scipy.sparse.linalg.lsqr.
    %
    It is the fatest but may not be available in old scipy versions.
    %
    It also uses an iterative procedure.
    %
  \end{itemize}
  All three solvers support both dense and sparse data.
  %
  %\ifthenelse{\equal{#1}{}}{}{\default{#1}}
}

%%%%%%%%%%%%%%%%%%%%%%%%% Common Regression Parameters %%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%% End Common Regression Parameters %%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%% Common SVM Parameters %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\CSVMDescription}[1]
{
  \xmlNode{C}, \xmlDesc{float, optional field}, sets the penalty parameter C
  of the error term.
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
  %
}

\newcommand{\kernelDescription}[1]
{
  \xmlNode{kernel}, \xmlDesc{string, optional}, specifies the kernel type
  to be used in the algorithm.
  %
  It must be one of:
  \begin{itemize}
    \item `linear'
    \item `poly'
    \item `rbf'
    \item `sigmoid'
    \item `precomputed'
    \item a callable object
  \end{itemize}
  %
  If a callable is given it is used to pre-compute the kernel matrix.
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
  %
}

\newcommand{\degreeDescription}[1]
{
  \xmlNode{degree}, \xmlDesc{int, optional field}, determines the degree
  of the polynomial kernel function (`poly').
  %
  Ignored by all other kernels.
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}

\newcommand{\gammaDescription}[1]
{
  \xmlNode{gamma}, \xmlDesc{float, optional field}, sets the
  kernel coefficient for the kernels `rbf,' `poly,' and `sigmoid.'
  %
  If gamma is `auto' then 1/n\_features will be used instead.
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}

\newcommand{\coefZeroDescription}[1]
{
  \xmlNode{coef0}, \xmlDesc{float, optional field}, is an independent term in
  kernel function.
  %
  It is only significant in `poly' and `sigmoid.'
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}

\newcommand{\probabilityDescription}[1]
{
  \xmlNode{probability}, \xmlDesc{boolean, optional field}, determines whether
  or not to enable probability estimates.
  %
  This must be enabled prior to calling fit, and will slow down that method.
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}

\newcommand{\shrinkingDescription}[1]
{
  \xmlNode{shrinking}, \xmlDesc{boolean, optional field}, determines whether or
  not to use the shrinking heuristic.
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}

\newcommand{\cacheSizeDescription}[1]
{
  \xmlNode{cache\_size}, \xmlDesc{float, optional field}, specifies the
  size of the kernel cache (in MB).
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}

\newcommand{\classWeightDescription}[1]
{
  \xmlNode{class\_weight}, \xmlDesc{{dict, `auto'}, optional}, sets the
  parameter C of class i to class\_weight[i]*C for SVC.
  %
  If not given, all classes are assumed to have weight one.
  %
  The `auto' mode uses the values of y to automatically adjust weights inversely
  proportional to class frequencies.
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}

\newcommand{\tolSVMDescription}[1]
{
  \tolDescriptionC{#1}
}

\newcommand{\verSVMDescription}[1]
{
  \verDescriptionA{False}
  %
  \nb This setting takes advantage of a per-process runtime setting in libsvm
  that, if enabled, may not work properly in a multithreaded context.
}

\newcommand{\randomStateSVMDescription}[1]
{
  \xmlNode{random\_state}, \xmlDesc{int seed, RandomState instance, or
  None}, represents the seed of the pseudo random number generator to use when
  shuffling the data for probability estimation.
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}

%%%%%%%%%%%%%%%%%%%%%%%%%% End Common SVM Parameters %%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%% Common Multi-Class Parameters %%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\estimatorDescription}[1]
{
  \xmlNode{estimator}, \xmlDesc{boolean, required field},
  %
  An estimator object implementing fit and one of decision\_function or
  predict\_proba.
  %
  This XML node needs to contain the following attribute:
  \vspace{-5mm}
  \begin{itemize}
    \itemsep0em
    \item \xmlAttr{estimatorType}, \xmlDesc{required string attribute}, this
    attribute is another reduced order mode type that needs to be used for the
    construction of the multi-class algorithms.
    %
    Each sub-sequential node depends on the chosen ROM.
  \end{itemize}
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}
%%%%%%%%%%%%%%%%%%%%%%% End Common Multi-Class Parameters %%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%% Common Bayesian Parameters %%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\alphaBayesDescription}[1]
{
  \xmlNode{alpha}, \xmlDesc{float, optional field}, specifies an additive
  (Laplace/Lidstone) smoothing parameter (0 for no smoothing).
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}

\newcommand{\fitPriorDescription}[1]
{
  \xmlNode{fit\_prior}, \xmlDesc{boolean, required field}, determines whether to
  learn class prior probabilities or not.
  %
  If false, a uniform prior will be used.
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}

\newcommand{\classPriorDescription}[1]
{
  \xmlNode{class\_prior}, \xmlDesc{array-like float (n\_classes), optional
  field}, specifies prior probabilities of the classes.
  %
  If specified, the priors are not adjusted according to the data.
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}

%%%%%%%%%%%%%%%%%%%%%%%% End Common Bayesian Parameters %%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%% Common Neighbor Parameters %%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\nNeighborsDescription}[1]
{
  \xmlNode{n\_neighbors}, \xmlDesc{integer, optional field}, specifies the
  number of neighbors to use by default for `k\_neighbors' queries.
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}

\newcommand{\radiusDescription}[1]
{
  \xmlNode{radius}, \xmlDesc{float, optional field}, specifies the range of
  parameter space to use by default for `radius\_neighbors' queries.
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}

\newcommand{\weightsDescription}[1]
{
  \xmlNode{weights}, \xmlDesc{string, optional field}, specifies the weight
  function used in prediction.
  %
  Possible values:
  \begin{itemize}
    \item \textit{uniform} : uniform weights.
    %
    All points in each neighborhood are weighted equally;
    \item \textit{distance} : weight points by the inverse of their distance.
    %
    In this case, closer neighbors of a query point will have a greater
    influence than neighbors which are further away.
    %
  \end{itemize}
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}

\newcommand{\metricDescription}[1]
{
  \xmlNode{metric}, \xmlDesc{string, optional field}, sets the distance metric
  to use for the tree.
  %
  The Minkowski metric with p=2 is equivalent to the standard Euclidean metric.
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}

\newcommand{\algorithmDescription}[1]
{
  \xmlNode{algorithm}, \xmlDesc{string, optional field}, specifies the algorithm
  used to compute the nearest neighbors:
  \begin{itemize}
    \item \textit{ball\_tree} will use BallTree.
    \item \textit{kd\_tree} will use KDtree.
    \item \textit{brute} will use a brute-force search.
    \item \textit{auto} will attempt to decide the most appropriate algorithm
    based on the values passed to fit method.
    %
  \end{itemize}
  \nb Fitting on sparse input will override the setting of this parameter, using
  brute force.
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}

\newcommand{\leafSizeDescription}[1]
{
  \xmlNode{leaf\_size}, \xmlDesc{integer, optional field}, sets the leaf size
  passed to the BallTree or KDTree.
  %
  This can affect the speed of the construction and query, as well as the memory
  required to store the tree.
  %
  The optimal value depends on the nature of the problem.
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}

\newcommand{\pDescription}[1]
{
  \xmlNode{p}, \xmlDesc{integer, optional field}, is a parameter for the
  Minkowski metric.
  %
  When $p = 1$, this is equivalent to using manhattan distance (L1), and
  euclidean distance (L2) for $p = 2$.
  %
  For arbitrary p, minkowski distance (L\_p) is used.
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}

\newcommand{\outlierLabelDescription}[1]
{
  \xmlNode{outlier\_label}, \xmlDesc{integer, optional field}, is a label, which
  is given for outlier samples (samples with no neighbors on a given radius).
  %
  If set to None, ValueError is raised, when an outlier is detected.
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}

%%%%%%%%%%%%%%%%%%%%%%%% End Common Neighbor Parameters %%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%% Common Tree Parameters %%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\criterionDescription}[1]
{
  \xmlNode{criterion}, \xmlDesc{string, optional field}, specifies the function
  used to measure the quality of a split.
  %
  Supported criteria are ``gini'' for the Gini impurity and ``entropy'' for the
  information gain.
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}

\newcommand{\criterionDescriptionDT}[1]
{
  \xmlNode{criterion}, \xmlDesc{string, optional field}, specifies the function
  used to measure the quality of a split.
  %
  The only supported criterion is ``mse'' for mean squared error.
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}

\newcommand{\splitterDescription}[1]
{
  \xmlNode{splitter}, \xmlDesc{string, optional field}, specifies the strategy
  used to choose the split at each node.
  %
  Supported strategies are ``best'' to choose the best split and ``random'' to
  choose the best random split.
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}

\newcommand{\maxFeaturesDescription}[1]
{
  \xmlNode{max\_features}, \xmlDesc{int, float or string, optional field}, sets
  the number of features to consider when looking for the best split:
  \begin{itemize}
    \item If int, then consider max\_features features at each split.
    %
    \item If float, then max\_features is a percentage and int(max\_features *
    n\_features) features are considered at each split.
    %
    \item If ``auto,'' then max\_features=sqrt(n\_features).
    \item If ``sqrt,'' then max\_features=sqrt(n\_features).
    \item If ``log2,'' then max\_features=log2(n\_features).
    \item If None, then max\_features=n\_features.
    %
  \end{itemize}
  \nb The search for a split does not stop until at least one valid partition of
  the node samples is found, even if it requires to effectively inspect more
  than max\_features features.
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}

\newcommand{\maxDepthDescription}[1]
{
  \xmlNode{max\_depth}, \xmlDesc{integer, optional field}, determines the
  maximum depth of the tree.
  %
  If None, then nodes are expanded until all leaves are pure or until all leaves
  contain less than min\_samples\_split samples.
  %
  Ignored if max\_samples\_leaf is not None.
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}

\newcommand{\minSamplesSplitDescription}[1]
{
  \xmlNode{min\_samples\_split}, \xmlDesc{integer, optional field}, sets the
  minimum number of samples required to split an internal node.
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}

\newcommand{\minSamplesLeafDescription}[1]
{
  \xmlNode{min\_samples\_leaf}, \xmlDesc{integer, optional field}, sets the
  minimum number of samples required to be at a leaf node.
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}

\newcommand{\maxLeafNodesDescription}[1]
{
  \xmlNode{max\_leaf\_nodes}, \xmlDesc{integer, optional field}, grow a tree
  with max\_leaf\_nodes in best-first fashion.
  %
  Best nodes are defined by relative reduction in impurity.
  %
  If None then unlimited number of leaf nodes.
  %
  If not None then max\_depth will be ignored.
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}
%%%%%%%%%%%%%%%%%%%%%%%%%% End Common Tree Parameters %%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%% Common Gaussian Process Parameters %%%%%%%%%%%%%%%%%%%%%%
\newcommand{\blankbDescription}[1]
{
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}
%%%%%%%%%%%%%%%%%%%% End Common Gaussian Process Parameters %%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%% Common Multi-layer Perceptron Parameters %%%%%%%%%%%%%%%%%%%%%%
\newcommand{\hiddenLayerSizesMLPDescription}[1]
{
  \xmlNode{hidden\_layer\_sizes}, \xmlDesc{tuple, length = n\_layers - 2, optional field}, the ith
  element represents the number of neurons in the ith hidden layer.
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}

\newcommand{\activationMLPDescription}[1]
{
  \xmlNode{activation}, \xmlDesc{string, optional field}, activation function for the hidden layer.
  \begin{itemize}
    \item \textit{identity}, no-op activation, useful to implement linear bottleneck, returns
      f(x) = x
    \item \textit{logistic}, the logistic sigmoid function, returns f(x) = 1/(1+exp(-x))
    \item \textit{tanh}, the hyperbolic tan function, returns f(x) = tanh(x)
    \item \textit{relu}, the rectified linear function, returns f(x) = max(0, x)
  \end{itemize}

  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}

\newcommand{\solverMLPDescription}[1]
{
  \xmlNode{solver}, \xmlDesc{string, optional field}, The solver for weight optimization.
  \begin{itemize}
    \item \textit{lbfgs}, is an optimizer in the family of quasi-Newton methods
    \item \textit{sgd}, refers to stochastic gradient descent
    \item \textit{adam}, refers to a stochastic gradient-based optimizer proposed by
      Kingma, Diederik, and Jimmy Ba.
  \end{itemize}
  \nb The default solver \textit{adam} works pretty well on relatively large datasets
  (with thousands of training samples or more) in terms of both training time and validation
  score. For small datasets, however, \textit{lbfgs} can converge faster and perform better.
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}


\newcommand{\alphaMLPDescription}[1]
{
  \xmlNode{alpha}, \xmlDesc{float, optional field}, L2 penalty parameter
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}

\newcommand{\batchSizeMLPDescription}[1]
{
  \xmlNode{batch\_size}, \xmlDesc{int, optional field}, Size of minibatches for stochastic
  optimizers. If the solver is \textit{lbfgs}, the classifier will not use minibatch.
  \default{min(200, n\_samples)}
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}


\newcommand{\learningRateMLPDescription}[1]
{
  \xmlNode{learning\_rate}, \xmlDesc{string, optional field}, Learning rate schedule for weight updates
  \begin{itemize}
    \item \textit{constant}, is a constant learning rate given by \textit{learning\_rate\_init}
    \item \textit{invscaling}, gradually decreases the learning rate at each time step `t' using an
      inverse scaling exponent of `power\_t'. effective\_learning\_rate = learning\_rate\_init / pow(t, power\_t)
    \item \textit{adaptive}, keeps the learning rate constant to `learning\_rate\_init' as long as
      training loss keeps decreasing. Each time two consecutive epochs fail to decrease training loss by at least
       tol, or fail to increase validation score by at least tol if `early\_stopping' is on, the current
       learning rate is divided by 5.
       \nb Only used when \textit{solver = `sgd'}
  \end{itemize}
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}

\newcommand{\learningRateInitMLPDescription}[1]
{
  \xmlNode{learning\_rate\_init}, \xmlDesc{float, optional field}, The initial learning rate used. It
  controls the step-size in updating the weights. Only used when solver = `sgd' or `adam'
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}


\newcommand{\powerTMLPDescription}[1]
{
  \xmlNode{power\_t}, \xmlDesc{float, optional field}, the exponent for inverse scaling learning rate.
  It is used in updating effective learning rate when the learning\_rate is set to `invscaling'. only
  used when solver = `sgd'
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}

\newcommand{\maxIterMLPDescription}[1]
{
  \xmlNode{max\_iter}, \xmlDesc{int, optional field}, maximum number of iterations. The solver iterates until
  convergence (determined by `tol') or this number of iterations. For stochastic solvers (`sgd', `adam'), note
  that this determines the number of epochs (how many times each data point will be used), not the number
  of gradient steps
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}



\newcommand{\shuffleMLPDescription}[1]
{
  \xmlNode{shuffle}, \xmlDesc{bool, optional field}, whether to shuffle samples in each iteration. Only used
  when solver = `sgd' or `adam'
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}

\newcommand{\randomStateMLPDescription}[1]
{
  \xmlNode{random\_state}, \xmlDesc{int, RandomState instance or None, optional field}
  if int, random\_state is the seed used by the random number generator; If RandomState
  instance, random\_state is the random number generator; If None, the random number
  generator is the RandomState instance used by np.random.
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}
\newcommand{\tolMLPDescription}[1]
{
  \xmlNode{tol}, \xmlDesc{float, optional field}, tolerance for optimization. When the loss or
  score is not improving by at least tol for two consecutive iterations, unless learning\_rate
  is set to `adaptive', convergence is considered to be reached and training stops.
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}
\newcommand{\verboseMLPDescription}[1]
{
  \xmlNode{verbose}, \xmlDesc{bool, optional field}, whether to print progress messages or stdout
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}
\newcommand{\warmStartMLPDescription}[1]
{
  \xmlNode{warm\_start}, \xmlDesc{bool, optional field}, when set to True, reuse the solution of 
  previous call to fit as initialization, otherise, just erase the previous solution.
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}
\newcommand{\momentumMLPDescription}[1]
{
  \xmlNode{momentum}, \xmlDesc{float, optional field}, momentum for gradient descent update.
  Should be between 0 and 1. Only used when solver = `sgd'.
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}
\newcommand{\nesterovsMomentumMLPDescription}[1]
{
  \xmlNode{nesterovs\_momentum}, \xmlDesc{bool, optional field}, whether to use Nesterov's momentum.
  Only used when solver='sgd' and momentum > 0.
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}
\newcommand{\earlyStoppingMLPDescription}[1]
{
  \xmlNode{early\_stopping}, \xmlDesc{bool, optional field}, whether to use early stopping to terminate
  training when validation score is not improving. If set to true, it will automatically set aside 10\%
  of training data as validation and terminate training when validation score is not improving by at
  least tol for two consecutive epochs. Only effective when solver=`sgd' or `adam'.
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}
\newcommand{\validationFractionMLPDescription}[1]
{
  \xmlNode{validation\_fraction}, \xmlDesc{float, optional field}, the proportion of training data to set
  aside as validation set for early stopping. Must be between 0 and 1. Only used if early\_stopping is True.
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}
\newcommand{\epsilonMLPDescription}[1]
{
  \xmlNode{epsilon}, \xmlDesc{float, optional field}, value for numerical stability in adam. Only used
  when solver = `adam'
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}

\newcommand{\betaAMLPDescription}[1]
{
  \xmlNode{beta\_1}, \xmlDesc{float, optional field}, exponential decay rate for estimates of first moment
  vector in adam. should be in [0, 1). only used when solver = `adam'
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}
\newcommand{\betaBMLPDescription}[1]
{
  \xmlNode{beta\_2}, \xmlDesc{float, optional field}, exponentail decay rate for estimates of second moment
  vector in adam. should be in [0, 1). only used when solver = `adam'
  %
  \ifthenelse{\equal{#1}{}}{}{\default{#1}}
}

%%%%%%%%%%%%%%%%%%%% End Common Multi-layer Perceptron Parameters %%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In RAVEN, \textbf{Models} are important entities.
%
A model is an object that employs a mathematical representation of a
phenomenon, either of a physical or other nature (e.g. statistical operators,
etc.).
%
From a practical point of view, it can be seen, as a ``black box'' that, given
an input, returns an output.
%

RAVEN has a strict classification of the different types of models.
%
Each ``class'' of models is represented by the definition reported above, but it
can be further classified based on its particular functionalities:
\begin{itemize}
  \item \xmlNode{Code} represents an external system code that employs a high
  fidelity physical model.
  \item \xmlNode{Dummy} acts as ``transfer'' tool.
  %
  The only action it performs is transferring the the information in the input
  space (inputs) into the output space (outputs).
  %
  For example, it can be used to check the effect of a sampling strategy, since
  its outputs are the sampled parameters' values (input space) and a counter
  that keeps track of the number of times an evaluation has been requested.
  %
  \item \xmlNode{ROM}, or reduced order model, is a mathematical model trained
  to predict a response of interest of a physical system.
  %
  Typically, ROMs trade speed for accuracy representing a faster, rough estimate
  of the underlying phenomenon.
  %
  The ``training'' process is performed by sampling the response of a physical
  model with respect to variation of its parameters subject to probabilistic
  behavior.
  %
  The results (outcomes of the physical model) of the sampling are fed into
  the algorithm representing the ROM that tunes itself to replicate those
  results.
  \item \xmlNode{ExternalModel}, as its name suggests, is an entity existing
  outside the RAVEN framework that is embedded in the RAVEN code at run time.
  %
  This object allows the user to create a Python module that will be treated as
  a predefined internal model object.
  \item \xmlNode{EnsembleModel} is model that is able to combine \textbf{Code},
  \textbf{ExternalModel} and \textbf{ROM} models. It is aimed to create a chain
  of Models (whose execution order is determined by the Input/Output relationships among them).
  If the relationships among the models evolve in a non-linear system, a Picard's Iteration scheme
  is employed.
  \item \xmlNode{PostProcessor} is a container of all the actions that can
  manipulate and process a data object in order to extract key information,
  such as statistical quantities, clustering, etc.
  %
\end{itemize}
Before analyzing each model in detail, it is important to mention that each
type needs to be contained in the main XML node \xmlNode{Models}, as reported
below:

\textbf{Example:}
\begin{lstlisting}[style=XML]
<Simulation>
  ...
  <Models>
    ...
    <WhatEverModel name='whatever'>
      ...
    </WhatEverModel>
    ...
  </Models>
  ...
</Simulation>
\end{lstlisting}
In the following sub-sections each \textbf{Model} type is fully analyzed and
described.
%
%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%  Code  Model   %%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%
%<Code name='MyRAVEN' subType='RAVEN'><executable>%FRAMEWORK_DIR%/../RAVEN-%METHOD%</executable></Code>
%<alias variable='internal_variable_name'>Material|Fuel|thermal_conductivity</alias>
\subsection{Code}
\label{subsec:models_code}
The \textbf{Code} model represents an external system
software employing a high fidelity physical model.
%
The link between RAVEN and the driven code is performed at run-time, through
coded interfaces that are the responsible for transferring information from the
code to RAVEN and vice versa.
%
In Section~\ref{sec:existingInterface}, all of the available interfaces are
reported and, for advanced users, Section~\ref{sec:newCodeCoupling} explains how
to couple a new code.


\specBlock{a}{Code}
%
\attrsIntro
%
\vspace{-5mm}
\begin{itemize}
  \itemsep0em
  \item \nameDescription
  \item \xmlAttr{subType}, \xmlDesc{required string attribute}, specifies the
  code that needs to be associated to this Model.
  %
  \nb See Section~\ref{sec:existingInterface} for a list of currently supported
  codes.
  %
\end{itemize}
\vspace{-5mm}

\subnodesIntro
%
\begin{itemize}
  \item \xmlNode{executable} \xmlDesc{string, required field} specifies the path
  of the executable to be used.

  \item \xmlNode{walltime}  \xmlDesc{string, optional field} specifies the maximum 
  allowed run time of the code; if the code running time is greater than the specified 
  walltime then the code run is stopped. The stopped run is then considered as if it crashed.
  %
  \nb Both absolute and relative path can be used. In addition, the relative path
  to the working directory can also be used.
  %
  \item \xmlNode{preexec} \xmlDesc{string, optional field} specifies the path of
    pre-executable to be used.
  \nb Both absolute and relative path can be used. In addition, the relative path
  to the working directory can also be used.
  %
  \item \aliasSystemDescription{Code}
  %
  \item \xmlNode{clargs} \xmlDesc{string, optional field} allows addition of
  command-line arguments to the execution command.  If the code interface
  specified in \xmlNode{Code} \xmlAttr{subType} does not specify how to
  determine the input file(s), this node must be used to specify them.
  There are several types of \xmlNode{clargs}, based on the \xmlAttr{type}:
  \begin{itemize}
    \item \xmlAttr{type} \xmlDesc{string, required field} specifies the type of
    command-line argument to add.  Options include \xmlString{input},
    \xmlString{output}, \xmlString{prepend}, \xmlString{postpend}, 
    \xmlString{text}, and \xmlString{python}.
    %
    \item \xmlAttr{arg} \xmlDesc{string, optional field} specifies the flag to
    be used before the entry.  For example, \xmlAttr{arg=}\xmlString{-i} would
    place a \texttt{-i} before the entry in the execution command.  Required for
    the \xmlString{output} \xmlAttr{type}.
    %
    \item \xmlAttr{extension} \xmlDesc{string, optional field} specifies the type
    of file extension to use (for example, \texttt{-i} or \texttt{-o}).  This links the
    \xmlNode{Input} file in the \xmlNode{Step} to this location in the execution
    command.  Required for \xmlString{input} \xmlAttr{type}.
    %
    \item \xmlAttr{delimiter} \xmlDesc{string, optional field} specifies the delimiter
      that is used between the \xmlAttr{arg} and the provided input file with
      the extension given by \xmlAttr{extension}.
      \nb This is currently only used to link the \xmlAttr{arg} and input file. i.e.
      the \xmlAttr{type} should be \xmlString{input} in order to use this feature.
  \end{itemize}
  The execution command is combined in the order \xmlString{prepend}, \xmlNode{python}
  \xmlNode{executable}, \xmlString{input}, \xmlString{output}, \xmlString{text},
  \xmlString{postpend}.  The \xmlString{python} is a special type that puts the name of the python command.
  %
  \item \xmlNode{fileargs} \xmlDesc{string, optional field} like \xmlNode{clargs},
  but allows editing of input files to specify the output filename and/or auxiliary
  file names.
  %
  The location in the input files to edit using these arguments are identified in
  the input file using the prefix-postfix notation, which defaults to
  \texttt{\$RAVEN-var\$} for variable keyword \emph{var}.  The variable keyword
  is then listed in the \xmlNode{fileargs} node in the attribute \xmlAttr{arg} to
  couple it in Raven.
  %
  If the code interface specified in \xmlNode{Code} \xmlAttr{subType}
  does not specify how to name the output file, that must be specified either through
  \xmlNode{clargs} or \xmlNode{filargs}, with \xmlAttr{type} \xmlString{output}.
  The attributes required for \xmlNode{fileargs} are as follows:
  \begin{itemize}
    \item \xmlAttr{type} \xmlDesc{string, required field} specifies the type
    of entry to replace in the file.  Possible values for \xmlNode{fileargs}
    \xmlAttr{type} are \xmlString{input} and \xmlString{output}.
    %
    \item \xmlAttr{arg} \xmlDesc{string, required field} specifies the Raven
    variable with which to replace the file of interest.  This should match
    the entry in the template input file; that is, if \texttt{\$RAVEN-auxinp\$}
    is in the input file, the arg for the corresponding input file should be
    \xmlString{auxinp}.
    %
    \item \xmlAttr{extension} \xmlDesc{string, optional field} specifies the
    extension of the input file that should replace the Raven variable in
    the input file.  This attribute is required for the \xmlString{input} \xmlAttr{type}
    and ignored for the \xmlString{output} \xmlAttr{type}.
    \nb{Currently, there can only be a one-to-one pairing between input files
    and extensions; that is, multiple Raven-editable input files cannot have the
    same extension.}
  \end{itemize}
\end{itemize}
\textbf{Example:}
\begin{lstlisting}[style=XML,morekeywords={subType,name,variable}]
<Simulation>
  ...
  <Models>
    ...
    <Code name='aUserDefinedName' subType='RAVEN_Driven_code'>
      <executable>path_to_executable</executable>
      <alias variable='internal_RAVEN_input_variable_name1' type="input">
         External_Code_input_Variable_Name_1
      </alias>
      <alias variable='internal_RAVEN_input_variable_name2' type='input'>
         External_Code_input_Variable_Name_2
      </alias>
      <alias variable='internal_RAVEN__output_variable_name' type='output'>
         External_Code_output_Variable_Name_2
      </alias>
      <clargs type='prepend' arg='python'/>
      <clargs type='input' arg='-i' extension='.i'/>
      <fileargs type='input' arg='aux' extension='.two'
      <fileargs type='output' arg='out' />
    </Code>
    ...
  </Models>
  ...
</Simulation>
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%% Dummy Model  %%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Dummy}
\label{subsec:models_dummy}
The \textbf{Dummy} model is an object that acts as a pass-through tool.
%
The only action it performs is transferring the information in the input
space (inputs) to the output space (outputs).
%
For example, it can be used to check the effect of a particular sampling
strategy, since its outputs are the sampled parameters' values (input space) and
a counter that keeps track of the number of times an evaluation has been
requested.
%

\specBlock{a}{Dummy}.
%
\attrsIntro
%
\vspace{-5mm}
\begin{itemize}
  \itemsep0em
  \item \nameDescription
  %
  \item \xmlAttr{subType}, \xmlDesc{required string attribute}, this attribute
  must be kept empty.
\end{itemize}
\vspace{-5mm}

\subnodesIntro
%
\begin{itemize}
  \item \aliasSystemDescription{Dummy}
  \\Since the \textbf{Dummy} model represents a transfer function only, the usage of the alias is relatively meaningless.
\end{itemize}

Given a particular \textit{Step} using this model, if this model is linked to
a \textit{Data} with the role of \textbf{Output}, it expects one of the output
parameters will be identified by the keyword ``OutputPlaceHolder'' (see
Section~\ref{sec:steps}).

\textbf{Example:}
\begin{lstlisting}[style=XML,morekeywords={subType}]
<Simulation>
  ...
  <Models>
    ...
    <Dummy name='aUserDefinedName1' subType=''/>

    <Dummy name='aUserDefinedName2' subType=''>
      <alias variable="a_RAVEN_input_variable" type="input">
      another_name_for_this_variable_in_the_model
      </alias>
    </Dummy>
    ...
  </Models>
  ...
</Simulation>
\end{lstlisting}



%%%%%%%%%%%%%%%%%%%%%%
%%%%% ROM Model  %%%%%%%
%%%%%%%%%%%%%%%%%%%%%%
\input{rom.tex}


%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%  External  Model   %%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{External Model}
\label{subsec:models_externalModel}
As the name suggests, an external model is an entity that is embedded in the
RAVEN code at run time.
%
This object allows the user to create a python module that is going to be
treated as a predefined internal model object.
%
In other words, the \textbf{External Model} is going to be treated by RAVEN as a
normal external Code (e.g. it is going to be called in order to compute an
arbitrary quantity based on arbitrary input).
%

The specifications of an External Model must be defined within the XML block
\xmlNode{ExternalModel}.
%
This XML node needs to contain the attributes:

\vspace{-5mm}
\begin{itemize}
  \itemsep0em
  \item \xmlAttr{name}, \xmlDesc{required string attribute}, user-defined name
  of this External Model.
  %
  \nb As with the other objects, this is the name that can be used to refer to
  this specific entity from other input blocks in the XML.
  \item \xmlAttr{subType}, \xmlDesc{required string attribute}, must be kept
  empty.
  \item \xmlAttr{ModuleToLoad}, \xmlDesc{required string attribute}, file name
  with its absolute or relative path.
  %
  \nb If a relative path is specified, the code first checks relative
  to the working directory, then it checks with respect to where the
  user runs the code.  Using the relative path with respect to where the
  code is run is not recommended.
  %
\end{itemize}
\vspace{-5mm}

In order to make the RAVEN code aware of the variables the user is going to
manipulate/use in her/his own python Module, the variables need to be specified
in the \xmlNode{ExternalModel} input block.
%
The user needs to input, within this block, only the variables that RAVEN needs
to be aware of (i.e. the variables are going to directly be used by the code)
and not the local variables that the user does not want to, for example, store
in a RAVEN internal object.
%
These variables are specified within a \xmlNode{variables} block:
\begin{itemize}
  \item \xmlNode{variables}, \xmlDesc{string, required parameter}.
  %
  Comma-separated list of variable names.
  %
  Each variable name needs to match a variable used/defined in the external python
  model.
  %
\end{itemize}

In addition, if the user wants to use the alias system, the following XML block can be inputted:
\begin{itemize}
  \item \aliasSystemDescription{ExternalModel}
\end{itemize}


When the external function variables are defined, at run time, RAVEN initializes
them and tracks their values during the simulation.
%
Each variable defined in the \xmlNode{ExternalModel} block is available in the
module (each method implemented) as a python ``self.''
%

In the External Python module, the user can implement all the methods that are
needed for the functionality of the model, but only the following methods, if
present, are called by the framework:
\begin{itemize}
  \item \texttt{\textbf{def \_readMoreXML}}, \xmlDesc{OPTIONAL METHOD}, can be
  implemented by the user if the XML input that belongs to this External Model
  needs to be extended to contain other information.
  %
  The information read needs to be stored in ``self'' in order to be available
  to all the other methods (e.g. if the user needs to add a couple of newer XML
  nodes with information needed by the algorithm implemented in the ``run''
  method).
  \item \texttt{\textbf{def initialize}}, \xmlDesc{OPTIONAL METHOD}, can
  implement all the actions need to be performed at the initialization stage.
  \item \texttt{\textbf{def createNewInput}}, \xmlDesc{OPTIONAL METHOD}, creates
  a new input with the information coming from the RAVEN framework.
  %
  In this function the user can retrieve the information coming from the RAVEN
  framework, during the employment of a calculation flow, and use them to
  construct a new input that is going to be transferred to the ``run'' method.
  \item \texttt{\textbf{def run}}, \xmlDesc{REQUIRED METHOD}, is the actual
  location where the user needs to implement the model action (e.g. resolution
  of a set of equations, etc.).
  %
  This function is going to receive the Input (or Inputs) generated either by
  the External Model ``createNewInput'' method or the internal RAVEN one.
\end{itemize}

In the following sub-sections, all the methods are going to be analyzed in
detail.

\subsubsection{Method: \texttt{def \_readMoreXML}}
\label{subsubsec:externalReadMoreXML}
As already mentioned, the \textbf{readMoreXML} method can be implemented by the
user if the XML input that belongs to this External Model needs to be extended
to contain other information.
%
The information read needs to be stored in ``self'' in order to be available to
all the other methods (e.g. if the user needs to add a couple of newer XML nodes
with information needed by the algorithm implemented in the ``run'' method).
%
If this method is implemented in the \textbf{External Model}, RAVEN is going to
call it when the node \xmlNode{ExternalModel} is found parsing the XML input
file.
%
The method receives from RAVEN an attribute of type ``xml.etree.ElementTree'',
containing all the sub-nodes and attribute of the XML block \xmlNode{ExternalModel}.
%

Example XML:
\begin{lstlisting}[style=XML,morekeywords={subType,ModuleToLoad}]
<Simulation>
  ...
  <Models>
     ...
    <ExternalModel name='AnExtModule' subType='' ModuleToLoad='path_to_external_module'>
       <variables>sigma,rho,outcome</variables>
       <!--
          here we define other XML nodes RAVEN does not read automatically.
          We need to implement, in the external module 'AnExtModule' the readMoreXML method
        -->
        <newNodeWeNeedToRead>
            whatNeedsToBeRead
        </newNodeWeNeedToRead>
    </ExternalModel>
     ...
  </Models>
  ...
</Simulation>
\end{lstlisting}

Corresponding Python function:
\begin{lstlisting}[language=python]
def _readMoreXML(self,xmlNode):
  # the xmlNode is passed in by RAVEN framework
  # <newNodeWeNeedToRead> is unknown (in the RAVEN framework)
  # we have to read it on our own
  # get the node
  ourNode = xmlNode.find('newNodeWeNeedToRead')
  # get the information in the node
  self.ourNewVariable = ourNode.text
  # end function
\end{lstlisting}


\subsubsection{Method: \texttt{def initialize}}
\label{subsubsec:externalInitialize}
The \textbf{initialize} method can be implemented in the \textbf{External Model}
in order to initialize some variables needed by it.
%
For example, it can be used to compute a quantity needed by the ``run'' method
before performing the actual calculation).
%
If this method is implemented in the \textbf{External Model}, RAVEN is going to
call it at the initialization stage of each ``Step'' (see section
\ref{sec:steps}.
%
RAVEN will communicate, thorough a set of method attributes, all the information
that are generally needed to perform a initialization:
\begin{itemize}
  \item runInfo, a dictionary containing information regarding how the
  calculation is set up (e.g. number of processors, etc.).
  %
  It contains the following attributes:
  \begin{itemize}
    \item \texttt{DefaultInputFile} -- default input file to use
    \item \texttt{SimulationFiles} -- the xml input file
    \item \texttt{ScriptDir} -- the location of the pbs script interfaces
    \item \texttt{FrameworkDir} -- the directory where the framework is located
    \item \texttt{WorkingDir} -- the directory where the framework should be
    running
    \item \texttt{TempWorkingDir} -- the temporary directory where a simulation
    step is run
    \item \texttt{NumMPI} -- the number of mpi process by run
    \item \texttt{NumThreads} -- number of threads by run
    \item \texttt{numProcByRun} -- total number of core used by one run (number
    of threads by number of mpi)
    \item \texttt{batchSize} -- number of contemporaneous runs
    \item \texttt{ParallelCommand} -- the command that should be used to submit
    jobs in parallel (mpi)
    \item \texttt{numNode} -- number of nodes
    \item \texttt{procByNode} -- number of processors by node
    \item \texttt{totalNumCoresUsed} -- total number of cores used by driver
    \item \texttt{queueingSoftware} -- queueing software name
    \item \texttt{stepName} -- the name of the step currently running
    \item \texttt{precommand} -- added to the front of the command that is run
    \item \texttt{postcommand} -- added after the command that is run
    \item \texttt{delSucLogFiles} -- if a simulation (code run) has not failed,
    delete the relative log file (if True)
    \item \texttt{deleteOutExtension} -- if a simulation (code run) has not
    failed, delete the relative output files with the listed extension (comma
    separated list, for example: `e,r,txt')
    \item \texttt{mode} -- running mode, curently the only mode supported is
      mpi (but custom modes can be created)
    \item \textit{expectedTime} -- how long the complete input is expected to
    run
    \item \textit{logfileBuffer} -- logfile buffer size in bytes
  \end{itemize}
  \item inputs, a list of all the inputs that have been specified in the
  ``Step'' using this model.
  %
\end{itemize}
In the following an example is reported:
\begin{lstlisting}[language=python]
def initialize(self,runInfo,inputs):
 # Let's suppose we just need to initialize some variables
  self.sigma = 10.0
  self.rho   = 28.0
  # end function
\end{lstlisting}


\subsubsection{Method: \texttt{def createNewInput}}
\label{subsubsec:externalcreateNewInput}

The \textbf{createNewInput} method can be implemented by the user to create a
new input with the information coming from the RAVEN framework.
%
In this function, the user can retrieve the information coming from the RAVEN
framework, during the employment of a calculation flow, and use them to
construct a new input that is going to be transferred to the ``run'' method.
%
The new input created needs to be returned to RAVEN (i.e. ``return NewInput'').
\\This method expects that the new input is returned in a Python ``dictionary''.
%
RAVEN communicates, thorough a set of method attributes, all the information
that are generally needed to create a new input:
%myInput,samplerType,**Kwargs
\begin{itemize}
  \item \texttt{inputs}, \xmlDesc{python list}, a list of all the inputs that
  have been defined in the ``Step'' using this model.
  \item \texttt{samplerType}, \xmlDesc{string}, the type of Sampler, if a
  sampling strategy is employed; will be None otherwise.
  \item \texttt{Kwargs}, \xmlDesc{dictionary}, a dictionary containing several
  pieces of information (that can change based on the ``Step'' type).
  %
  If a sampling strategy is employed, this dictionary contains another
  dictionary identified by the keyword ``SampledVars'', in which the variables
  perturbed by the sampler are reported.
\end{itemize}
\nb If the ``Step'' that is using this Model has as input(s) an object of main
class type ``DataObjects'' (see Section~\ref{sec:DataObjects}), the internal ``createNewInput''
method is going to convert it in a dictionary of values.
%

Here we present an example:
\begin{lstlisting}[language=python]
def createNewInput(self,inputs,samplerType,**Kwargs):
  # in here the actual createNewInput of the
  # model is implemented
  if samplerType == 'MonteCarlo':
    avariable = inputs['something']*inputs['something2']
  else:
    avariable = inputs['something']/inputs['something2']
  return avariable*Kwargs['SampledVars']['aSampledVar']
\end{lstlisting}

\subsubsection{Method: \texttt{def run}}
\label{subsubsec:externalRun}
As stated previously, the only method that \emph{must} be present in an
External Module is the \textbf{run} function.
%
In this function, the user needs to implement the algorithm that RAVEN will
execute.
%
The \texttt{\textbf{run}} method is generally called after having inquired the
``createNewInput'' method (either the internal or the user-implemented one).
%
The only attribute this method is going to receive is a Python list of inputs
(the inputs coming from the \texttt{createNewInput} method).
%
If the user wants RAVEN to collect the results of this method, the outcomes of
interest need to be stored in ``self.''
%
\nb RAVEN is trying to collect the values of the variables listed only in the
\xmlNode{ExternalModel} XML block.
%

In the following an example is reported:
\begin{lstlisting}[language=python]
def run(self,Input):
  # in here the actual run of the
  # model is implemented
  input = Input[0]
  self.outcome = self.sigma*self.rho*input[``whatEver'']
\end{lstlisting}

%\subsection{Projector}
%\label{sec:models_projector}
%
%Description

%Summary

%Example

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%         PostProcessor         %%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{postprocessor.tex}

%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%  EnsembleModel  Model   %%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%

\subsection{EnsembleModel}
\label{subsec:models_EnsembleModel}
As already mentioned, the \textbf{EnsembleModel} is able to combine \textbf{Code}(see ~\ref{subsec:models_code}),
\textbf{ExternalModel}(see ~\ref{subsec:models_externalModel}) and \textbf{ROM}(see ~\ref{subsec:models_externalModel}) Models.
\\It is aimed to create a chain of Models (whose execution order is determined by the Input/Output relationships among them).
  If the relationships among the models evolve in a non-linear system, a Picard's Iteration scheme is employed.
\\Currently this model is able to share information (i.e. data) using \textbf{PointSet},  \textbf{HistorySet} and \textbf{DataSet}

The specifications of a EnsembleModel must be defined within the XML block
\xmlNode{EnsembleModel}.
%
This XML node needs to contain the attributes:

\vspace{-5mm}
\begin{itemize}
  \itemsep0em
  \item \xmlAttr{name}, \xmlDesc{required string attribute}, user-defined name
  of this EnsembleModel.
  %
  \nb As with the other objects, this is the name that can be used to refer to
  this specific entity from other input blocks in the XML.
  \item \xmlAttr{subType}, \xmlDesc{required string attribute}, must be kept
  empty.
  %
\end{itemize}
\vspace{-5mm}

Within the \xmlNode{EnsembleModel} XML node, the multiple Models that constitute
this EnsembleModel needs to be inputted. Each Model is specified within a \xmlNode{Model} block (\nb each model
here specified need to be inputted in the\xmlNode{Models} main XML block) :
\begin{itemize}
  \item \xmlNode{Model}, \xmlDesc{XML node, required parameter}.
  %
  The text portion of this node needs to contain the name of the Model
  %
  \\This XML node needs to contain the attributes:

\vspace{-5mm}
\begin{itemize}
  \itemsep0em
  \item \xmlAttr{class}, \xmlDesc{required string attribute}, the class of this sub-model (e.g. Models)
  %
  \item \xmlAttr{type}, \xmlDesc{required string attribute}, the sub-type of this Model (e.g. ExternalModel, ROM, Code)
  %
\end{itemize}
\vspace{-5mm}

  %
  In addition the following XML sub-nodes need to be inputted (or optionally inputted):
  \begin{itemize}
     \item \xmlNode{TargetEvaluation}, \xmlDesc{string, required field},
        represents the container where the output of this Model are stored.
        %
        From a practical point of view, this XML node must contain the name of
        a data object defined in the \xmlNode{DataObjects} block (see
        Section~\ref{sec:DataObjects}).
        %
        Currently, the  \xmlNode{EnsembleModel} accept all \textbf{\textit{DataObjects'}}  types:
        \textbf{PointSet},  \textbf{HistorySet} and \textbf{DataSet}
        \nb The  \xmlNode{TargetEvaluation} is primary used for input-output identification. If the linked
        DataObject is not placed as additional output of the Step where the EnsembleModel is used, it will
        not be filled with the data coming from the calculation and it will be kept empty.
     \item \xmlNode{Input}, \xmlDesc{string, required field},
        represents the input entities that need to be passed to this sub-model
        %
        The user can specify as many \xmlNode{Input} as required by the sub-model.
        \nb All the inputs here specified need to be listed in the Steps where the EnsembleModel
        is used.
     \item \xmlNode{Output}, \xmlDesc{string, optional field},
        represents the output entities that need to be linked to this sub-model.  \nb The \xmlNode{Output}s here 
        specified are not part 
        of the determination of the EnsembleModel execution but represent an additional storage of results from the
        sub-models. For example, if the \xmlNode{TargetEvaluation} is of type PointSet (since just scalar data needs to 
        be transferred to other 
        models) and the sub-model is able to also output history-type data, this Output can be of type HistorySet.
        Note that the structure of each Output dataObject must include only variables (either input or output) that are 
        defined among the model.
        As an example, the Output dataObjects cannot contained variables that are defined at the Ensemble model 
        level.
        %
        The user can specify as many \xmlNode{Output} (s) as needed. The optional \xmlNode{Output}s  can be of 
        both classes ``DataObjects'' and ``Databases'' 
        (e.g. \textit{PointSet}, \textit{HistorySet}, \textit{DataSet}, \textit{HDF5})
        \nb \textbf{The \xmlNode{Output} (s) here specified MUST be listed in the Step in which the EnsembleModel is used.}
    \end{itemize}
  %
\end{itemize}


It is important to notice that when the EnsembleModel detects a chain of models that evolve in a non-linear system, a Picard's Iteration scheme is activated. In this case, an additional XML sub-node within the main \xmlNode{EnsembleModel} XML node needs to be specified:
\begin{itemize}
  \item \xmlNode{settings}, \xmlDesc{XML node, required parameter (if Picard's activated)}.
  %
  The body of this sub-node  contains the following XML sub-nodes:
  %
  \begin{itemize}
     \item \xmlNode{maxIterations}, \xmlDesc{integer, optional field},
        maximum number of Picard's iteration to be performed (in case the iteration scheme does
        not previously converge). \default{30};
     \item \xmlNode{tolerance}, \xmlDesc{float, optional field},
        convergence criterion. It represents the L2 norm residue below which the Picard's iterative scheme is
        considered converged. \default{0.001};
     \item \xmlNode{initialConditions}, \xmlDesc{XML node, required parameter  (if Picard's activated)},
        Within this sub-node, the initial conditions for the input variables (that are part of a loop)  need to
        be specified in sub-nodes named with the variable name (e.g. \xmlNode{varName}). The body of the
        \xmlNode{varName} contains the value of the initial conditions (scalar or arrays, depending of the
        type of variable). If an array needs to be inputted, the user can specify the attribute  \xmlAttr{repeat}
        and the code is going to repeat for  \xmlAttr{repeat}-times the value inputted in the body.
     \item \xmlNode{initialStartModels}, \xmlDesc{XML node, only required parameter when Picard's iteration is 
     activated},
        specifies the list of models that will be initially executed. \nb Do not input this node for non-Picard calculations,
        otherwise an error will be raised.
  \end{itemize}
\end{itemize}

\nb \textcolor{red} { \textbf{ It is crucial to understand that the choice of the \xmlNode{DataObject} used as
 \newline \xmlNode{TargetEvaluation} determines how the data are going to be transferred from a model to
  the other. If for example the chain of models is $A \rightarrow B$:}}
\begin{itemize}
  \item \textcolor{red} { \textbf{ If model $B$ expects as input scalars and outputs time-series, the \xmlNode{TargetEvaluation}  
  of the  model $B$ will be a \textit{HistorySet} and the  \xmlNode{TargetEvaluation} of the model $A$ will be either 
  a \textit{PointSet} or a \textit{DataSet} (where the output variables that need to be transferred to the model $A$ are scalars) }    }
   \item \textcolor{red} { \textbf{ If model $B$ expects as input scalars and time-series and outputs time-series or scalars or both, the \xmlNode{TargetEvaluation}  
  of the  model $B$ will be a \textit{DataSet} and the \newline  \xmlNode{TargetEvaluation} of the model $A$ will be either 
  a \textit{HistorySet} or a \textit{DataSet}  }    }
  \item \textcolor{red} { \textbf{ If both model $A$ and $B$ expect as input scalars and output scalars, the \xmlNode{TargetEvaluation}  
  of the  both models  $A$  and $B$ will be  \textit{PointSet}s  }  }
\end{itemize}

\textbf{Example (Linear System):}
\begin{lstlisting}[style=XML,morekeywords={subType,debug,name,class,type}]
<Simulation>
  ...
  <Models>
    ...
    <EnsembleModel name="heatTransferEnsembleModel" subType="">
      <Model class="Models" type="ExternalModel">
        thermalConductivityComputation
        <TargetEvaluation class="DataObjects" type="PointSet">
          thermalConductivityComputationContainer
        </TargetEvaluation>
        <Input class="DataObjects" type="PointSet">
          inputHolder
        </Input>
      </Model>
      <Model class="Models" type="ExternalModel" >
          heatTransfer
          <TargetEvaluation class="DataObjects" type="PointSet">
            heatTransferContainer
          </TargetEvaluation>
        <Input class="DataObjects" type="PointSet">
          inputHolder
        </Input>
        <Output class="DataObjects" type="HistorySet">
          thisModelLinkedOutput
        </Output>
        <Output class="Databases" type="HDF5">
          thisModelLinkedHDF5
        </Output>
      </Model>
    </EnsembleModel>
    ...
  </Models>
  ...
</Simulation>
\end{lstlisting}

\textbf{Example (Non-Linear System):}
\begin{lstlisting}[style=XML,morekeywords={subType,debug,repeat,name,class,type}]
<Simulation>
  ...
  <Models>
    ...
    <EnsembleModel name="heatTransferEnsembleModel" subType="">
      <settings>
        <maxIterations>8</maxIterations>
         <tolerance>0.01</tolerance>
         <initialConditions>
           <!-- the value 0.7 is going to be repeated 10 times in order to create  an array for var1 -->
           <var1 repeat="10">0.7</var1>
           <!-- an array for var2 has been inputted -->
           <var2> 0.5 0.3 0.4</var2>
           <!-- a scalar for var3 has been inputted -->
           <var3> 45.0</var3>
         </initialConditions>
      </settings>

      <Model class="Models" type="ExternalModel">
        thermalConductivityComputation
        <TargetEvaluation class="DataObjects" type="PointSet">
          thermalConductivityComputationContainer
        </TargetEvaluation>
        <Input class="DataObjects" type="PointSet">
          inputHolder
        </Input>
      </Model>
      <Model class="Models" type="ExternalModel" >
          heatTransfer
          <TargetEvaluation class="DataObjects" type="PointSet">
            heatTransferContainer
          </TargetEvaluation>
        <Input class="DataObjects" type="PointSet">
          inputHolder
        </Input>
      </Model>
    </EnsembleModel>
    ...
  </Models>
  ...
</Simulation>
\end{lstlisting}


%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%  HybridModel  Model   %%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%

\subsection{HybridModel}
\label{subsec:models_HybridModel}
The \textbf{HybridModel} is a new \textit{Model} entity. This new Model is able to combine reduced order model
(ROMs) and any other high-fidelity Model (i.e. Code, ExternalModel). The ROMs will be trained based on the results
from the high-fidelity model. The accuracy of the ROMs will be evaluated based on the cross validation scores,
and the validity of the ROMs will be determined via some local validation metrics (\nb currently only one metric
is available, i.e. CrowdingDistance). After these ROMs are trained, the \textbf{HybridModel} can decide which of
the Model (i.e the ROMs or high-fidelity model) to be executed based on the accuracy and validity of the ROMs.

Currently this model is only able to share information (i.e. data) using \textbf{PointSet}.

The specifications of a HybridModel must be defined within the XML block
\xmlNode{HybridModel}.
%
This XML node needs to contain the attributes:

\vspace{-5mm}
\begin{itemize}
  \itemsep0em
  \item \xmlAttr{name}, \xmlDesc{required string attribute}, user-defined name
  of this HybridModel.
  %
  \nb As with the other objects, this is the name that can be used to refer to
  this specific entity from other input blocks in the XML.
  \item \xmlAttr{subType}, \xmlDesc{required string attribute}, must be kept
  empty.
  %
\end{itemize}
\vspace{-5mm}

Within the \xmlNode{HybridModel} XML node, the multiple entities that constitute
this HybridModel needs to be inputted. 

\begin{itemize}
  \item \xmlNode{Model}, \xmlDesc{XML node, required parameter}.
  %
  The text portion of this node needs to contain the name of the Model
  %
  \assemblerAttrDescription{Model}
  %
  \item \xmlNode{ROM}, \xmlDesc{XML node, required parameter}.
  %
  The text portion of this node needs to contain the name of the ROM
  The user can specify as many \xmlNode{ROM} as required by the \xmlNode{Model}.
  \nb The outputs of each ROM should be different, and the total set of ROMs' outputs
  should be the same as the set of \textit{Model's} outputs.
  %
  \assemblerAttrDescription{Model}
  %
  \item \xmlNode{CV}, \xmlDesc{XML node, required parameter}.
  %
    The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with \xmlAttr{subType}
    ``CrossValidation``.
  %
    \assemblerAttrDescription{Model}
  % 
  \item \xmlNode{TargetEvaluation}, \xmlDesc{XML node, required parameter}.
  %
    The text portion of this node needs to contain the name of a data object defined in the \xmlNode{DataObjects} block.
    \nb currently only accept data object with type ``PointSet``. The \xmlNode{TargetEvaluation} is primary used for
    training ROMs. \nb The linked DataObject should be placed as additional output of the Step where the
    \textbf{HybridModel} is used.
  %
    \assemblerAttrDescription{DataObjects}
  %
\end{itemize}

An additional XML sub-node within the main \xmlNode{HybridModel} XML node needs to be specified:
\begin{itemize}
  \item \xmlNode{settings}, \xmlDesc{XML node, optional parameter}.
  %
  The body of this sub-node  contains the following XML sub-nodes:
  %
  \begin{itemize}
     \item \xmlNode{minInitialTrainSize}, \xmlDesc{integer, optional field}, the minimum initial number of high-fidelity
       model runs before starting train the ROMs.
       \default{10};
     \item \xmlNode{tolerance}, \xmlDesc{float, optional field}, ROMs convergence criterion indicates the displacement
       from the optimum results of cross validation. In other words, small tolerance indicates tight convergence criterion
       of the ROMs, while large tolerance indicates loose convergence criterion of the ROMs.
       \nb Currently, this tolerance can be only used for cross validations with SKL Metrics: \textit{explained\_variance\_score},
       \textit{r2\_score}, \textit{median\_absolute\_error}, \textit{mean\_squared\_error} and \textit{mean\_absolute\_error}.
       \default{0.01};
     \item \xmlNode{maxTrainSize}, \xmlDesc{XML node, optional field}, the maximum size of training set of ROMs.
       \default{1.0E6}
  \end{itemize}
  \item \xmlNode{validationMethod}, \xmlDesc{XML node, optional parameter}.
  %
  The validity methods that are used to determine which model to run (i.e. ROMs or high-fidelity Model).
  This XML node needs to contain the attributes:
  %
  \begin{itemize}
    \itemsep0em
    \item \xmlAttr{name}, \xmlDesc{required string attribute}, user-defined name
      of this \xmlNode{validationMethod}.
      \nb Currently, only one method is available, ie. ``CrowdingDistance``.
  \end{itemize}
  %
  The body of this sub-node  contains the following XML sub-nodes:
  %
  \begin{itemize}
     \item \xmlNode{threshold}, \xmlDesc{XML node, required field}, the threshold that is used for ``CrowdingDistance`` method.
  \end{itemize}
\end{itemize}


\textbf{Example (ExternalModel):}
\begin{lstlisting}[style=XML,morekeywords={subType,debug,name,class,type}]
<Simulation>
  ...
  <Metrics>
    <SKL name="m1">
      <metricType>mean_absolute_error</metricType>
    </SKL>
  </Metrics>

  <Models>
    <ExternalModel ModuleToLoad="EM2linear" name="thermalConductivityComputation" subType="">
      <variables>leftTemperature,rightTemperature,k,averageTemperature</variables>
    </ExternalModel>
    <ROM name="knr" subType="SciKitLearn">
      <SKLtype>neighbors|KNeighborsRegressor</SKLtype>
      <Features>leftTemperature, rightTemperature</Features>
      <Target>k</Target>
      <n_neighbors>5</n_neighbors>
      <weights>uniform</weights>
      <algorithm>auto</algorithm>
      <leaf_size>30</leaf_size>
      <metric>minkowski</metric>
      <p>2</p>
    </ROM>
    <PostProcessor name="pp1" subType="CrossValidation">
        <SciKitLearn>
            <SKLtype>KFold</SKLtype>
            <n_splits>10</n_splits>
            <shuffle>False</shuffle>
        </SciKitLearn>
        <Metric class="Metrics" type="SKL">m1</Metric>
    </PostProcessor>
    <HybridModel name="hybrid" subType="">
        <Model class="Models" type="ExternalModel">thermalConductivityComputation</Model>
        <ROM class="Models" type="ROM">knr</ROM>
        <TargetEvaluation class="DataObjects" type="PointSet">thermalConductivityComputationContainer</TargetEvaluation>
        <CV class="Models" type="PostProcessor">pp1</CV>
        <settings>
            <tolerance>0.01</tolerance>
            <trainStep>1</trainStep>
            <maxTrainSize>1000</maxTrainSize>
            <initialTrainSize>10</initialTrainSize>
        </settings>
        <validationMethod name="CrowdingDistance">
            <threshold>0.2</threshold>
        </validationMethod>
    </HybridModel>
  </Models>
  ...
</Simulation>

\end{lstlisting}

\textbf{Example (Code):}
\begin{lstlisting}[style=XML,morekeywords={subType,debug,repeat,name,class,type}]
<Simulation>
  ...
  <Metrics>
    <SKL name="m1">
      <metricType>mean_absolute_error</metricType>
    </SKL>
  </Metrics>

  <Models>
    <Code name="poly" subType="GenericCode">
      <executable>runCode/poly_inp_io.py</executable>
      <clargs arg="python" type="prepend"/>
      <clargs arg="-i" extension=".one" type="input"/>
      <fileargs arg="aux" extension=".two" type="input"/>
      <fileargs arg="output" type="output"/>
      <prepend>python</prepend>
    </Code>
    <ROM name="knr" subType="SciKitLearn">
      <SKLtype>neighbors|KNeighborsRegressor</SKLtype>
      <Features>x, y</Features>
      <Target>poly</Target>
      <n_neighbors>5</n_neighbors>
      <weights>uniform</weights>
      <algorithm>auto</algorithm>
      <leaf_size>30</leaf_size>
      <metric>minkowski</metric>
      <p>2</p>
    </ROM>
    <PostProcessor name="pp1" subType="CrossValidation">
        <SciKitLearn>
            <SKLtype>KFold</SKLtype>
            <n_splits>10</n_splits>
            <shuffle>False</shuffle>
        </SciKitLearn>
        <Metric class="Metrics" type="SKL">m1</Metric>
    </PostProcessor>
    <HybridModel name="hybrid" subType="">
        <Model class="Models" type="Code">poly</Model>
        <ROM class="Models" type="ROM">knr</ROM>
        <TargetEvaluation class="DataObjects" type="PointSet">samples</TargetEvaluation>
        <CV class="Models" type="PostProcessor">pp1</CV>
        <settings>
            <tolerance>0.1</tolerance>
            <trainStep>1</trainStep>
            <maxTrainSize>1000</maxTrainSize>
            <initialTrainSize>10</initialTrainSize>
        </settings>
        <validationMethod name="CrowdingDistance">
            <threshold>0.2</threshold>
        </validationMethod>
    </HybridModel>
  </Models>
  ...
  <Steps>
    <MultiRun name="hybridModelCode">
      <Input class="Files" type="">gen.one</Input>
      <Input class="Files" type="">gen.two</Input>
      <Input class="DataObjects" type="PointSet">inputHolder</Input>
      <Model class="Models" type="HybridModel">hybrid</Model>
      <Sampler class="Samplers" type="Stratified">LHS</Sampler>
      <Output class="DataObjects" type="PointSet">samples</Output>
      <Output class="OutStreams" type="Print">samples</Output>
    </MultiRun>
  </Steps>
  ...
</Simulation>
\end{lstlisting}
%
\nb For this example, the user needs to provide all the inputs for the \textbf{HybridModel}, i.e. Files for the
\textbf{Code} and DataObject for the \textbf{ROM} defined in the \textbf{HybridModel}.
