\subsubsection{SparseSensing}
\label{SparseSensing}
The \textbf{SparseSensing} post-processor incorporates ``PySensors'', a Scikit-learn style Python package for the sparse placement of sensors for reconstruction tasks and classification tasks which will be added here soon.

Sparse sensor placement concerns the problem of selecting a small subset of sensor or measurement locations in a way that allows one to perform some task nearly as well as if one had access to measurements at every location.

This post-processor provides objects designed for the tasks of reconstruction and classification. See

\begin{itemize}
    \item Manohar, Krithika, et al. ``Data-driven sparse sensor placement for reconstruction: Demonstrating the benefits of exploiting known patterns.'' IEEE Control Systems Magazine 38.3 (2018): 63-86 for more information about the PySensors approach to reconstruction problems and,
    \item Brunton, Bingni W., et al. ``Sparse sensor placement optimization for classification.'' SIAM Journal on Applied Mathematics 76.5 (2016): 2099-2122 for classification and,
    \item de Silva, Brian M., et al. ``PySensors: A Python package for sparse sensor placement.'' arXiv preprint arXiv:2102.13476 (2021) contains a full literature review along with examples and additional tips for using PySensors effectively,
    \item Karnik, Niharika, et al. ``Constrained Optimization of Sensor Placement for Nuclear Digital Twins.'' IEEE Sensors Journal Volume: 24 Issues: 9 (2024) for more details about constrained optimization of sensor placement,
    \item Karnik, Niharika, et al. ``Leveraging Optimal Sparse Sensor Placement to Aggregate a Network of Digital Twins for Nuclear Subsystems.''Energies, 17(13), 3355. (2024) for more details about constrained optimization of sensor placement with various constraint region shapes.
\end{itemize}

\ppType{SparseSensing }{SparseSensing}
\begin{itemize}
\item \xmlNode{Goal}, \xmlDesc{string, required field}, the goal of the sparse sensor optimization.
User has to provide \xmlAttr{subType} which is a \xmlDesc{string, required field} representing the goal of the sparse sensing optimization; i.e., which goal function is used in the optimization? Examples for such goal functions are:
\begin{itemize}
    \item \textbf{Reconstruction} deals with predicting the values of a quantity of interest at different locations other than those where sensors are located. For example, one might predict the temperature at a point in the middle of a fuel rod based on readings taken at various other positions.

    \item \textbf{Classification} is the problem of predicting which category an example belongs to, given a set of training data (e.g. determining whether digital photos are of dogs or cats).
\end{itemize}
In order to use the \xmlNode{Goal}, the user needs to provide the following subnodes:
\begin{itemize}
	\item \xmlNode{features}, \xmlDesc{comma separated strings, required field}, features/inputs of the data model, i.e., possible sensor locations/IDs
	\item \xmlNode{measuredState}, \xmlDesc{comma separated strings, required field}, state Variable to be measured/sensed
  \nb{Currently the algorithms can handle a single target}.
	\item \xmlNode{basis},  \xmlDesc{string, optional field}, the type of basis onto which the data are projected: \xmlString{Identity}, \xmlString{SVD}, \xmlString{Random}. \default{SVD}
	\item \xmlNode{nModes},  \xmlDesc{integer, required field}, the number of modes  used to project the data.
	\item \xmlNode{nSensors},  \xmlDesc{integer, required field}, the number of sensors used
	\item \xmlNode{optimizer},  \xmlDesc{string, optional field}, the optimizer used to find the sensors: \xmlString{QR}, for the unconstrained case, and \xmlString{GQR}, for the constrained case.
        \item \xmlNode{seed}, \xmlDesc{integer, optional field}, the seed that is passed to the pysensors SSPOR fit function.  If not specified if there are more sensors chosen then nModes, the sensors chosen will be different with each run.
  \item \xmlNode{xValue},  \xmlDesc{string, required field}, variable plotted on the X-axis of the data model
  \item \xmlNode{yValue},  \xmlDesc{string, required field}, variable plotted on the Y-axis of the data model
  \item \xmlNode{zValue},  \xmlDesc{string, required field}, variable plotted on the Z-axis of the data model
  \item \xmlNode{labels},  \xmlDesc{string or float list, required field when goal is classification}, labels/target for the classification case
  \item \xmlNode{nConstSensors},  \xmlDesc{integer, required field when optimizer is GQR}, The number of constraint sensors for GQR optimizer
  \item \xmlNode{constraintOption},  \xmlDesc{string. required field when optimizer is GQR}, The constraint the user wants to implement (max\_n, exact\_n, predetermined)
  \item \xmlNode{ConstrainedRegions},
        \item \xmlNode{type}, \xmlDesc{string, required field when optimizer is GQR}, type of Constrained Region shape the user wants- (Constraint can be a circle, parabola, ellipse, line, rectangle, square or user defined constraint too)
  \item \xmlNode{classifier}, \xmlDesc{string, optional field}, The type of classifier used, default='LDA'
  \item \xmlNode{center\_x}, \xmlDesc{float, required field when optimizer is GQR and ConstrainedRegions type is circle, ellipse}, The x co-ordinate of center of circle, ellipse
  \item \xmlNode{center\_y}, \xmlDesc{float, required field when optimizer is GQR and ConstrainedRegions type is circle, ellipse}, The y co-ordinate of center of circle, ellipse
  \item \xmlNode{radius}, \xmlDesc{float, required field when optimizer is GQR and ConstrainedRegions type is circle, ellipse}, The radius of circle, ellipse
  \item \xmlNode{loc}, \xmlDesc{string, optional field}, whether the constraint region is inside or outside the shape defined as constraint
  \item \xmlNode{width}, \xmlDesc{float, required field when optimizer is GQR and ConstrainedRegions type is ellipse}, Width of the ellipse
  \item \xmlNode{height}, \xmlDesc{float, required field when optimizer is GQR and ConstrainedRegions type is ellipse}, Height of the ellipse
  \item \xmlNode{angle}, \xmlDesc{float, required field when optimizer is GQR and ConstrainedRegions type is ellipse}, Angle of rotations of the ellipse
  \item \xmlNode{x1}, \xmlDesc{float, required field when optimizer is GQR and ConstrainedRegions type is line}, X co-ordinate of one of the points that defines the line
  \item \xmlNode{x2}, \xmlDesc{float, required field when optimizer is GQR and ConstrainedRegions type is line}, X co-ordinate of the other point that defines the line
  \item \xmlNode{y1}, \xmlDesc{float, required field when optimizer is GQR and ConstrainedRegions type is line}, Y co-ordinate of one of the points that defines the line
  \item \xmlNode{y2}, \xmlDesc{float, required field when optimizer is GQR and ConstrainedRegions type is line}, Y co-ordinate of the other point that defines the line
  \item \xmlNode{h}, \xmlDesc{float, required field when optimizer is GQR and ConstrainedRegions type is parabola}, X coordinate of the vertex of the parabola we want to be constrained
  \item \xmlNode{k}, \xmlDesc{float, required field when optimizer is GQR and ConstrainedRegions type is parabola}, Y coordinate of the vertex of the parabola we want to be constrained
  \item \xmlNode{a}, \xmlDesc{float, required field when optimizer is GQR and ConstrainedRegions type is parabola}, X coordinate of the focus of the parabola
  \item \xmlNode{xy\_coords}, \xmlDesc{float list, required field when optimizer is GQR and ConstrainedRegions type is polygon}, an array consisting of tuples for (x,y) coordinates of points of the Polygon where N = No. of sides of the polygon
\end{itemize}
\end{itemize}

\textbf{Example: Unconstrained sensor placement for reconstruction}
\begin{lstlisting}[style=XML]
<Simulation>
   ...
   <Models>
      ...
      <PostProcessor name="mySPSL" subType="SparseSensing" verbosity="debug">
      <Goal subType="reconstruction">
        <features>X (m),Y (m),Temperature (K)</features>
        <measuredState>Temperature (K)</measuredState>
        <basis>SVD</basis> <!--default: SVD-->
        <nModes>4</nModes> <!--default: opt, allows the algorithm to pick nModes-->
        <nSensors>4</nSensors><!--default: opt, allows the algorithm to pick nSensors-->
        <optimizer>QR</optimizer><!--default: QR-->
      </Goal>
    </PostProcessor>
    ...
  </Models>
   ...
</Simulation>
\end{lstlisting}

\textbf{Example: Unconstrained sensor placement for classification}
\begin{lstlisting}[style=XML]
<Simulation>
   ...
   <Models>
      ...
   <PostProcessor name="mySPSL" subType="SparseSensing" verbosity="debug">
     <Goal subType="classification">
       <features>X (m),Y (m),Temperature (K), label</features>
       <measuredState>Temperature (K)</measuredState>
       <labels>label</labels>
       <basis>SVD</basis>
       <nModes>4</nModes>
       <nSensors>4</nSensors>
       <classifier>LDA</classifier>
     </Goal>
   </PostProcessor>
    ...
 </Models>
   ...
</Simulation>
\end{lstlisting}

\textbf{Example: Constrained sensor placement for reconstruction with the constrained region being a circle}
\begin{lstlisting}[style=XML]
<Simulation>
   ...
   <Models>
      ...
    <PostProcessor name="mySPSL" subType="SparseSensing" verbosity="debug">
      <Goal subType="reconstruction">
        <features>X (m),Y (m),Temperature (K)</features>
        <measuredState>Temperature (K)</measuredState>
        <basis>SVD</basis>
        <nModes>4</nModes>
        <nSensors>4</nSensors>
        <nConstSensors>0</nConstSensors>
        <constraintOption>"exact_n"</constraintOption>
        <ConstrainedRegions type = "circle"> 
          <center_x>0.025</center_x>
          <center_y>0</center_y>
          <loc>'in'</loc>
          <radius>0.02</radius>
        </ConstrainedRegions>
        <optimizer>GQR</optimizer>
      </Goal>
    </PostProcessor>
    ...
  </Models>
   ...
</Simulation>
\end{lstlisting}
