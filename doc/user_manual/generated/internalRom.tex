

\subsubsection{NDspline}
  \xmlNode{NDspline} is a ROM based on an $N$-dimensional                             spline
  interpolation/extrapolation scheme.                             In spline interpolation, the
  regressor is a special type of piece-wise                             polynomial called tensor
  spline.                             The interpolation error can be made small even when using low
  degree polynomials                             for the spline.                             Spline
  interpolation avoids the problem of Runge's phenomenon, in which
  oscillation can occur between points when interpolating using higher degree
  polynomials.                             In order to use this ROM, the \xmlNode{ROM} attribute
  \xmlAttr{subType} needs to                             be \xmlString{NDspline}
  No further XML sub-nodes are required.                             \nb This ROM type must be
  trained from a regular Cartesian grid.                             Thus, it can only be trained
  from the outcomes of a grid sampling strategy.
  \zNormalizationPerformed{NDspline}

  The \xmlNode{NDspline} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{NDspline} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}
  \end{itemize}

\hspace{24pt}
Example:
\begin{lstlisting}[style=XML]
<Simulation>
  ...
  <Models>
    ...
    <ROM name='aUserDefinedName' subType='NDspline'>
       <Features>var1,var2,var3</Features>
       <Target>result1,result2</Target>
     </ROM>
    ...
  </Models>
  ...
</Simulation>
\end{lstlisting}


\subsubsection{pickledROM}
  It is not uncommon for a reduced-order model (ROM) to be created and trained in one RAVEN run,
  then     serialized to file (\emph{pickled}), then loaded into another RAVEN run to be used as a
  model.  When this is     the case, a \xmlNode{ROM} with subtype \xmlString{pickledROM} is used to
  hold the place of the ROM that will     be loaded from file.  The notation for this ROM is much
  less than a typical ROM; it usually only requires a name and     its subtype.     \\     Note that
  when loading ROMs from file, RAVEN will not perform any checks on the expected inputs or outputs
  of     a ROM; it is expected that a user know at least the I/O of a ROM before trying to use it as
  a model.     However, RAVEN does require that pickled ROMs be trained before pickling in the first
  place.     \\     Initially, a pickledROM is not usable.  It cannot be trained or sampled;
  attempting to do so will raise an     error.  An \xmlNode{IOStep} is used to load the ROM from
  file, at which point the ROM will have all the same     characteristics as when it was pickled in
  a previous RAVEN run.

  The \xmlNode{pickledROM} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{pickledROM} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{seed}: \xmlDesc{integer}, 
      provides seed for VARMA and ARMA sampling.
      Must be provided before training. If no seed is assigned,
      then a random number will be used.

    \item \xmlNode{Multicycle}: \xmlDesc{string}, 
      indicates that each sample of the ARMA should yield
      multiple sequential samples. For example, if an ARMA model is trained to produce a year's
      worth of data,                                                    enabling
      \xmlNode{Multicycle} causes it to produce several successive years of data. Multicycle
      sampling                                                    is independent of ROM training,
      and only changes how samples of the ARMA are created.
      \nb The output of a multicycle ARMA must be stored in a \xmlNode{DataSet}, as the targets will
      depend                                                    on both the \xmlNode{pivotParameter}
      as well as the cycle, \xmlString{Cycle}. The cycle is a second
      \xmlNode{Index} that all targets should depend on, with variable name \xmlString{Cycle}.

      The \xmlNode{Multicycle} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{cycles}: \xmlDesc{integer}, 
          the number of cycles the ARMA should produce
          each time it yields a sample.

        \item \xmlNode{growth}: \xmlDesc{float}, 
          if provided then the histories produced by
          the ARMA will be increased by the growth factor for successive cycles. This node can be
          added                                                    multiple times with different
          settings for different targets.                                                    The
          text of this node is the growth factor in percentage. Some examples are in
          Table~\ref{tab:arma multicycle growth}, where \emph{Growth factor} is the value used in
          the RAVEN                                                    input and \emph{Scaling
          factor} is the value by which the history will be multiplied.
          \begin{table}[h!]                                                      \centering
          \begin{tabular}{r c l}                                                        Growth
          factor & Scaling factor & Description \\ \hline
          50 & 1.5 & growing by 50\% each cycle \\
          -50 & 0.5 & shrinking by 50\% each cycle \\
          150 & 2.5 & growing by 150\% each cycle \\
          \end{tabular}                                                      \caption{ARMA Growth
          Factor Examples}                                                      \label{tab:arma
          multicycle growth}                                                    \end{table}
          The \xmlNode{growth} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{targets}: \xmlDesc{comma-separated strings, required}, 
                lists the targets                     in this ARMA that this growth factor should
                apply to.
              \item \xmlAttr{start\_index}: \xmlDesc{integer, optional}, 
                -- no description yet --
              \item \xmlAttr{end\_index}: \xmlDesc{integer, optional}, 
                -- no description yet --
              \item \xmlAttr{mode}: \xmlDesc{[exponential, linear], required}, 
                either \xmlString{linear} or                     \xmlString{exponential}, determines
                the manner in which the growth factor is applied.                     If
                \xmlString{linear}, then the scaling factor is $(1+y\cdot g/100)$;
                if \xmlString{exponential}, then the scaling factor is $(1+g/100)^y$;
                where $y$ is the cycle after the first and $g$ is the provided scaling factor.
          \end{itemize}
      \end{itemize}

    \item \xmlNode{clusterEvalMode}: \xmlDesc{[clustered, truncated, full]}, 
      changes the structure of the samples for Clustered
      Segmented ROMs. These are identical to the options for \xmlNode{evalMode}
      node under \xmlNode{Segmented}

    \item \xmlNode{maxCycles}: \xmlDesc{integer}, 
      maximum number of cycles to run (default no limit)
  \end{itemize}

\hspace{24pt}
Example:
For this example the ROM has already been created and trained in another RAVEN run, then pickled to a file
called \texttt{rom\_pickle.pk}.  In the example, the file is identified in \xmlNode{Files}, the model is
defined in \xmlNode{Models}, and the model loaded in \xmlNode{Steps}.
\begin{lstlisting}[style=XML]
<Simulation>
  ...
  <Files>
    <Input name="rompk" type="">rom_pickle.pk</Input>
  </Files>
  ...
  <Models>
    ...
    <ROM name="myRom" subType="pickledROM"/>
    ...
  </Models>
  ...
  <Steps>
    ...
    <IOStep name="loadROM">
      <Input class="Files" type="">rompk</Input>
      <Output class="Models" type="ROM">myRom</Output>
    </IOStep>
    ...
  </Steps>
  ...
</Simulation>
\end{lstlisting}


\subsubsection{GaussPolynomialRom}
  The \xmlString{GaussPolynomialRom} is based on a                         characteristic Gaussian
  polynomial fitting scheme: generalized polynomial chaos                         expansion (gPC).
  \\                         In gPC, sets of polynomials orthogonal with respect to the distribution
  of uncertainty                         are used to represent the original model.  The method
  converges moments of the original                         model faster than Monte Carlo for small-
  dimension uncertainty spaces ($N<15$).                         In order to use this ROM, the
  \xmlNode{ROM} attribute \xmlAttr{subType} needs to                         be
  \xmlString{GaussPolynomialRom}.                         \\                         The
  GaussPolynomialRom is dependent on specific sampling; thus, this ROM cannot be trained unless a
  SparseGridCollocation or similar Sampler specifies this ROM in its input and is sampled in a
  MultiRun step.                         \begin{table}[htb]                           \centering
  \begin{tabular}{c | c c}                             Unc. Distribution & Default Quadrature &
  Default Polynomials \\ \hline                             Uniform & Legendre & Legendre \\
  Normal & Hermite & Hermite \\ \hline                             Gamma & Laguerre & Laguerre \\
  Beta & Jacobi & Jacobi \\ \hline                             Other & Legendre* & Legendre*
  \end{tabular}                           \caption{GaussPolynomialRom defaults}
  \label{tab:gpcCompatible}                         \end{table}                         \nb This ROM
  type must be trained from a collocation quadrature set.                         Thus, it can only
  be trained from the outcomes of a SparseGridCollocation sampler.                         Also,
  this ROM must be referenced in the SparseGridCollocation sampler in order to
  accurately produce the necessary sparse grid points to train this ROM.
  \zNormalizationNotPerformed{GaussPolynomialRom}                         \\
  When Printing this ROM via a Print OutStream (see \ref{sec:printing}), the available metrics are:
  \begin{itemize}                           \item \xmlString{mean}, the mean value of the ROM output
  within the input space it was trained,                           \item \xmlString{variance}, the
  variance of the ROM output within the input space it was trained,                           \item
  \xmlString{samples}, the number of distinct model runs required to construct the ROM,
  \item \xmlString{indices}, the Sobol sensitivity indices (in percent), Sobol total indices, and
  partial variances,                           \item \xmlString{polyCoeffs}, the polynomial
  expansion coefficients (PCE moments) of the ROM.  These are                             listed by
  each polynomial combination, with the polynomial order tags listed in the order of the variables
  shown in the XML print.                         \end{itemize}

  The \xmlNode{GaussPolynomialRom} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{GaussPolynomialRom} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{IndexSet}: \xmlDesc{[TensorProduct, TotalDegree, HyperbolicCross, Custom]}, 
      specifies the rules by which to construct multidimensional polynomials.  The options are
      \xmlString{TensorProduct}, \xmlString{TotalDegree},\\
      \xmlString{HyperbolicCross}, and \xmlString{Custom}.
      Total degree is efficient for                                                  uncertain
      inputs with a large degree of regularity, while hyperbolic cross is more efficient
      for low-regularity input spaces.                                                  If
      \xmlString{Custom} is chosen, the \xmlNode{IndexPoints} is required.

    \item \xmlNode{PolynomialOrder}: \xmlDesc{integer}, 
      indicates the maximum polynomial order in any one dimension to use in the
      polynomial chaos expansion. \nb If non-equal importance weights are supplied in the optional
      \xmlNode{Interpolation} node, the actual polynomial order in dimensions with high
      importance might exceed this value; however, this value is still used to limit the
      relative overall order.

    \item \xmlNode{SparseGrid}: \xmlDesc{[smolyak, tensor]}, 
      allows specification of the multidimensional
      quadrature construction strategy.  Options are \xmlString{smolyak} and \xmlString{tensor}.

    \item \xmlNode{IndexPoints}: \xmlDesc{comma-separated list of comma separated integer tuples}, 
      used to specify the index set points in a \xmlString{Custom} index set.  The tuples are
      entered as comma-separated values between parenthesis, with each tuple separated by a comma.
      Any amount of whitespace is acceptable.  For example,
      \xmlNode{IndexPoints}\verb'(0,1),(0,2),(1,1),(4,0)'\xmlNode{/IndexPoints}
      \nb{Using custom index sets                                                  does not
      guarantee accurate convergence.}

    \item \xmlNode{Interpolation}: \xmlDesc{string}, 
      offers the option to specify quadrature, polynomials, and importance weights for the given
      variable name.  The ROM accepts any number of \xmlNode{Interpolation} nodes up to the
      dimensionality of the input space.
      The \xmlNode{Interpolation} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{quad}: \xmlDesc{string, optional}, 
            specifies the quadrature type to use for collocation in this dimension.  The default
            options                   depend on the uncertainty distribution of the input dimension,
            as shown in Table                   \ref{tab:gpcCompatible}. Additionally, Clenshaw
            Curtis quadrature can be used for any                   distribution that doesn't
            include an infinite bound.                   \default{see Table
            \ref{tab:gpcCompatible}.}                   \nb For an uncertain distribution aside from
            the four listed on Table                   \ref{tab:gpcCompatible}, this ROM
            makes use of the uniform-like range of the distribution's CDF to apply quadrature that
            is                   suited uniform uncertainty (Legendre).  It converges more slowly
            than the four listed, but are                   viable choices.  Choosing polynomial
            type Legendre for any non-uniform distribution will                   enable this
            formulation automatically.
          \item \xmlAttr{poly}: \xmlDesc{string, optional}, 
            specifies the interpolating polynomial family to use for the polynomial expansion in
            this                   dimension.  The default options depend on the quadrature type
            chosen, as shown in Table                   \ref{tab:gpcCompatible}.  Currently, no
            polynomials are available outside the                   default. \default{see Table
            \ref{tab:gpcCompatible}.}
          \item \xmlAttr{weight}: \xmlDesc{float, optional}, 
            delineates the importance weighting of this dimension.  A larger importance weight will
            result in increased resolution for this dimension at the cost of resolution in lower-
            weighted                   dimensions.  The algorithm normalizes weights at run-
            time.\default{1}.
      \end{itemize}
  \end{itemize}

\hspace{24pt}
Example:
\begin{lstlisting}[style=XML,morekeywords={name,subType}]
<Simulation>
  ...
  <Samplers>
    ...
    <SparseGridCollocation name="mySG" parallel="0">
      <variable name="x1">
        <distribution>myDist1</distribution>
      </variable>
      <variable name="x2">
        <distribution>myDist2</distribution>
      </variable>
      <ROM class = 'Models' type = 'ROM' >myROM</ROM>
    </SparseGridCollocation>
    ...
  </Samplers>
  ...
  <Models>
    ...
    <ROM name='myRom' subType='GaussPolynomialRom'>
      <Target>ans</Target>
      <Features>x1,x2</Features>
      <IndexSet>TotalDegree</IndexSet>
      <PolynomialOrder>4</PolynomialOrder>
      <Interpolation quad='Legendre' poly='Legendre' weight='1'>x1</Interpolation>
      <Interpolation quad='ClenshawCurtis' poly='Jacobi' weight='2'>x2</Interpolation>
    </ROM>
    ...
  </Models>
  ...
</Simulation>
\end{lstlisting}


\subsubsection{HDMRRom}
  The \xmlString{HDMRRom} is based on a Sobol decomposition scheme.                         In Sobol
  decomposition, also known as high-density model reduction (HDMR, specifically Cut-HDMR),
  a model is approximated as as the sum of increasing-complexity interactions.  At its lowest level
  (order 1), it treats the function as a sum of the reference case plus a functional of each input
  dimesion separately.  At order 2, it adds functionals to consider the pairing of each dimension
  with each other dimension.  The benefit to this approach is considering several functions of small
  input cardinality instead of a single function with large input cardinality.  This allows reduced
  order models like generalized polynomial chaos (see \ref{subsubsec:GaussPolynomialRom}) to
  approximate the functionals accurately with few computations runs.                         In
  order to use this ROM, the \xmlNode{ROM} attribute \xmlAttr{subType} needs to
  be \xmlString{HDMRRom}.                         \\                         The HDMRRom is
  dependent on specific sampling; thus, this ROM cannot be trained unless a
  Sobol or similar Sampler specifies this ROM in its input and is sampled in a MultiRun step.
  \\                         \nb This ROM type must be trained from a Sobol decomposition training
  set.                         Thus, it can only be trained from the outcomes of a Sobol sampler.
  Also, this ROM must be referenced in the Sobol sampler in order to
  accurately produce the necessary sparse grid points to train this ROM.
  Experience has shown order 2 Sobol decompositions to include the great majority of
  uncertainty in most models.                         \zNormalizationNotPerformed{HDMRRom}
  \\                         When Printing this ROM via an OutStream (see \ref{sec:printing}), the
  available metrics are:                         \begin{itemize}                           \item
  \xmlString{mean}, the mean value of the ROM output within the input space it was trained,
  \item \xmlString{variance}, the ANOVA-calculated variance of the ROM output within the input space
  it                             was trained.                           \item \xmlString{samples},
  the number of distinct model runs required to construct the ROM,                           \item
  \xmlString{indices}, the Sobol sensitivity indices (in percent), Sobol total indices, and partial
  variances.                         \end{itemize}

  The \xmlNode{HDMRRom} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{HDMRRom} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{IndexSet}: \xmlDesc{[TensorProduct, TotalDegree, HyperbolicCross, Custom]}, 
      specifies the rules by which to construct multidimensional polynomials.  The options are
      \xmlString{TensorProduct}, \xmlString{TotalDegree},\\
      \xmlString{HyperbolicCross}, and \xmlString{Custom}.
      Total degree is efficient for                                                  uncertain
      inputs with a large degree of regularity, while hyperbolic cross is more efficient
      for low-regularity input spaces.                                                  If
      \xmlString{Custom} is chosen, the \xmlNode{IndexPoints} is required.

    \item \xmlNode{PolynomialOrder}: \xmlDesc{integer}, 
      indicates the maximum polynomial order in any one dimension to use in the
      polynomial chaos expansion. \nb If non-equal importance weights are supplied in the optional
      \xmlNode{Interpolation} node, the actual polynomial order in dimensions with high
      importance might exceed this value; however, this value is still used to limit the
      relative overall order.

    \item \xmlNode{SparseGrid}: \xmlDesc{[smolyak, tensor]}, 
      allows specification of the multidimensional
      quadrature construction strategy.  Options are \xmlString{smolyak} and \xmlString{tensor}.

    \item \xmlNode{IndexPoints}: \xmlDesc{comma-separated list of comma separated integer tuples}, 
      used to specify the index set points in a \xmlString{Custom} index set.  The tuples are
      entered as comma-separated values between parenthesis, with each tuple separated by a comma.
      Any amount of whitespace is acceptable.  For example,
      \xmlNode{IndexPoints}\verb'(0,1),(0,2),(1,1),(4,0)'\xmlNode{/IndexPoints}
      \nb{Using custom index sets                                                  does not
      guarantee accurate convergence.}

    \item \xmlNode{Interpolation}: \xmlDesc{string}, 
      offers the option to specify quadrature, polynomials, and importance weights for the given
      variable name.  The ROM accepts any number of \xmlNode{Interpolation} nodes up to the
      dimensionality of the input space.
      The \xmlNode{Interpolation} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{quad}: \xmlDesc{string, optional}, 
            specifies the quadrature type to use for collocation in this dimension.  The default
            options                   depend on the uncertainty distribution of the input dimension,
            as shown in Table                   \ref{tab:gpcCompatible}. Additionally, Clenshaw
            Curtis quadrature can be used for any                   distribution that doesn't
            include an infinite bound.                   \default{see Table
            \ref{tab:gpcCompatible}.}                   \nb For an uncertain distribution aside from
            the four listed on Table                   \ref{tab:gpcCompatible}, this ROM
            makes use of the uniform-like range of the distribution's CDF to apply quadrature that
            is                   suited uniform uncertainty (Legendre).  It converges more slowly
            than the four listed, but are                   viable choices.  Choosing polynomial
            type Legendre for any non-uniform distribution will                   enable this
            formulation automatically.
          \item \xmlAttr{poly}: \xmlDesc{string, optional}, 
            specifies the interpolating polynomial family to use for the polynomial expansion in
            this                   dimension.  The default options depend on the quadrature type
            chosen, as shown in Table                   \ref{tab:gpcCompatible}.  Currently, no
            polynomials are available outside the                   default. \default{see Table
            \ref{tab:gpcCompatible}.}
          \item \xmlAttr{weight}: \xmlDesc{float, optional}, 
            delineates the importance weighting of this dimension.  A larger importance weight will
            result in increased resolution for this dimension at the cost of resolution in lower-
            weighted                   dimensions.  The algorithm normalizes weights at run-
            time.\default{1}.
      \end{itemize}

    \item \xmlNode{SobolOrder}: \xmlDesc{integer}, 
      indicates the maximum cardinality of the input space used in the subset functionals.  For
      example, order 1                                                  includes only functionals of
      each independent dimension separately, while order 2 considers pair-wise interactions.
  \end{itemize}

\hspace{24pt}
Example:
\begin{lstlisting}[style=XML,morekeywords={name,subType}]
  <Samplers>
    ...
    <Sobol name="mySobol" parallel="0">
      <variable name="x1">
        <distribution>myDist1</distribution>
      </variable>
      <variable name="x2">
        <distribution>myDist2</distribution>
      </variable>
      <ROM class = 'Models' type = 'ROM' >myHDMR</ROM>
    </Sobol>
    ...
  </Samplers>
  ...
  <Models>
    ...
    <ROM name='myHDMR' subType='HDMRRom'>
      <Target>ans</Target>
      <Features>x1,x2</Features>
      <SobolOrder>2</SobolOrder>
      <IndexSet>TotalDegree</IndexSet>
      <PolynomialOrder>4</PolynomialOrder>
      <Interpolation quad='Legendre' poly='Legendre' weight='1'>x1</Interpolation>
      <Interpolation quad='ClenshawCurtis' poly='Jacobi' weight='2'>x2</Interpolation>
    </ROM>
    ...
  </Models>
\end{lstlisting}


\subsubsection{MSR}
  The \xmlNode{MSR} contains a class of ROMs that perform a topological
  decomposition of the data into approximately monotonic regions and fits weighted
  linear patches to the identified monotonic regions of the input space. Query
  points have estimated probabilities that they belong to each cluster. These
  probabilities can eitehr be used to give a smooth, weighted prediction based on
  the associated linear models, or a hard categorization  to a particular local
  linear model which is then used for prediction. Currently, the probability
  prediction can be done using kernel density estimation (KDE) or through a
  one-versus-one support vector machine (SVM).                             \\
  \zNormalizationNotPerformed{MSR}                             \\                             In
  order to use this ROM, the \xmlNode{ROM} attribute \xmlAttr{subType} needs to
  be \xmlString{MSR}

  The \xmlNode{MSR} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{MSR} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{persistence}: \xmlDesc{string}, 
      specifies how                                                  to define the hierarchical
      simplification by assigning a value to each local
      minimum and maximum according to the one of the strategy options below:
      \begin{itemize}                                                    \item \texttt{difference} -
      The function value difference between the
      extremum and its closest-valued neighboring saddle.
      \item \texttt{probability} - The probability integral computed as the
      sum of the probability of each point in a cluster divided by the count of
      the cluster.                                                    \item \texttt{count} - The
      count of points that flow to or from the
      extremum.                                                  \end{itemize}

    \item \xmlNode{gradient}: \xmlDesc{string}, 
      specifies the                                                  method used for estimating the
      gradient, available options are:
      \begin{itemize}                                                    \item \texttt{steepest}
      \end{itemize}

    \item \xmlNode{simplification}: \xmlDesc{float}, 
      specifies the                                                  amount of noise reduction to
      apply before returning labels.

    \item \xmlNode{graph}: \xmlDesc{string}, 
      specifies the type                                                  of neighborhood graph used
      in the algorithm, available options are:
      \begin{itemize}                                                    \item \texttt{beta
      skeleton}                                                    \item \texttt{relaxed beta
      skeleton}                                                    \item \texttt{approximate knn}
      \end{itemize}

    \item \xmlNode{beta}: \xmlDesc{float}, 
      in range: $(0, 2])$. It is                                                  only used when the
      \xmlNode{graph} is set to \texttt{beta skeleton} or
      \texttt{relaxed beta skeleton}.

    \item \xmlNode{knn}: \xmlDesc{integer}, 
      is the number of                                                  neighbors when using the
      \texttt{approximate knn} for the \xmlNode{graph}
      sub-node and used to speed up the computation of other graphs by using the
      approximate knn graph as a starting point for pruning. -1 means use a fully
      connected graph.

    \item \xmlNode{weighted}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      a flag that specifies                                                  whether the regression
      models should be probability weighted.

    \item \xmlNode{partitionPredictor}: \xmlDesc{string}, 
      a flag that                                                  specifies how the predictions for
      query point categorization  should be
      performed. Available options are:
      \begin{itemize}                                                    \item \texttt{kde}
      \item \texttt{svm}                                                  \end{itemize}

    \item \xmlNode{smooth}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      if this node is present, the ROM will blend the
      estimates of all of the local linear models weighted by the probability the
      query point is categorized as belonging to that partition of the input space.

    \item \xmlNode{kernel}: \xmlDesc{string}, 
      this option is only                                                  used when the
      \xmlNode{partitionPredictor} is set to \texttt{kde} and
      specifies the type of kernel to use in the kernel density estimation.
      Available options are:                                                  \begin{itemize}
      \item \texttt{uniform}                                                    \item
      \texttt{triangular}                                                    \item \texttt{gaussian}
      \item \texttt{epanechnikov}                                                    \item
      \texttt{biweight} or \texttt{quartic}                                                    \item
      \texttt{triweight}                                                    \item \texttt{tricube}
      \item \texttt{cosine}                                                    \item
      \texttt{logistic}                                                    \item \texttt{silverman}
      \item \texttt{exponential}                                                  \end{itemize}

    \item \xmlNode{bandwidth}: \xmlDesc{float or string}, 
      this                                                  option is only used when the
      \xmlNode{partitionPredictor} is set to
      \texttt{kde} and specifies the scale of the fall-off. A higher bandwidth
      implies a smooother blending. If set to \texttt{variable}, then the bandwidth
      will be set to the distance of the $k$-nearest neighbor of the query point
      where $k$ is set by the \xmlNode{knn} parameter.
  \end{itemize}

\hspace{24pt}
Example:
\begin{lstlisting}[style=XML,morekeywords={name,subType}]
<Simulation>
  ...
  <Models>
    ...
    </ROM>
    <ROM name='aUserDefinedName' subType='MSR'>
       <Features>var1,var2,var3</Features>
       <Target>result1,result2</Target>
       <!-- <weighted>true</weighted> -->
       <simplification>0.0</simplification>
       <persistence>difference</persistence>
       <gradient>steepest</gradient>
       <graph>beta skeleton</graph>
       <beta>1</beta>
       <knn>8</knn>
       <partitionPredictor>kde</partitionPredictor>
       <kernel>gaussian</kernel>
       <smooth/>
       <bandwidth>0.2</bandwidth>
     </ROM>
    ...
  </Models>
  ...
</Simulation>
\end{lstlisting}


\subsubsection{NDinvDistWeight}
  The \xmlNode{NDinvDistWeight} is based on an                             $N$-dimensional inverse
  distance weighting formulation.                             Inverse distance weighting (IDW) is a
  type of deterministic method for                             multivariate interpolation with a
  known scattered set of points.                             The assigned values to unknown points
  are calculated via a weighted average of                             the values available at the
  known points.                             \\
  \zNormalizationPerformed{NDinvDistWeight}                             \\
  In order to use this Reduced Order Model, the \xmlNode{ROM} attribute
  \xmlAttr{subType} needs to be \xmlString{NDinvDistWeight}.

  The \xmlNode{NDinvDistWeight} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{NDinvDistWeight} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{p}: \xmlDesc{integer}, 
      must be greater than zero and represents the ``power parameter''.
      For the choice of value for \xmlNode{p},it is necessary to consider the degree
      of smoothing desired in the interpolation/extrapolation, the density and
      distribution of samples being interpolated, and the maximum distance over
      which an individual sample is allowed to influence the surrounding ones (lower
      $p$ means greater importance for points far away).
  \end{itemize}

\hspace{24pt}
Example:
\begin{lstlisting}[style=XML,morekeywords={name,subType}]
<Simulation>
  ...
  <Models>
    ...
    <ROM name='aUserDefinedName' subType='NDinvDistWeight'>
      <Features>var1,var2,var3</Features>
      <Target>result1,result2</Target>
      <p>3</p>
     </ROM>
    ...
  </Models>
  ...
</Simulation>
\end{lstlisting}


\subsubsection{SyntheticHistory}
  A ROM for characterizing and generating synthetic histories. This ROM makes use of         a
  variety of TimeSeriesAnalysis (TSA) algorithms to characterize and generate new         signals
  based on training signal sets. It is a more general implementation of the ARMA ROM. The available
  algorithms are discussed in more detail below. The SyntheticHistory ROM uses the TSA algorithms to
  characterize then reproduce time series in sequence; for example, if using Fourier then ARMA, the
  SyntheticHistory ROM will characterize the Fourier properties using the Fourier TSA algorithm on a
  training signal, then send the residual to the ARMA TSA algorithm for characterization. Generating
  new signals works in reverse, first generating a signal using the ARMA TSA algorithm then
  superimposing the Fourier TSA algorithm.         //         In order to use this Reduced Order
  Model, the \xmlNode{ROM} attribute         \xmlAttr{subType} needs to be
  \xmlString{SyntheticHistory}.

  The \xmlNode{SyntheticHistory} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{SyntheticHistory} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.

    \item \xmlNode{TimeSeriesGenerator}:
      Base class for time series analysis algorithms used in RAVEN.
      The \xmlNode{TimeSeriesGenerator} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{target}: \xmlDesc{comma-separated strings, required}, 
            indicates the variables for which this algorithm will be used for characterization.
          \item \xmlAttr{seed}: \xmlDesc{integer, optional}, 
            sets a seed for the underlying random number generator, if present.
      \end{itemize}

    \item \xmlNode{TimeSeriesCharacterizer}:
      Base class for time series analysis algorithms used in RAVEN.
      The \xmlNode{TimeSeriesCharacterizer} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{target}: \xmlDesc{comma-separated strings, required}, 
            indicates the variables for which this algorithm will be used for characterization.
          \item \xmlAttr{seed}: \xmlDesc{integer, optional}, 
            sets a seed for the underlying random number generator, if present.
      \end{itemize}

    \item \xmlNode{fourier}:
      TimeSeriesAnalysis algorithm for determining the strength and phase of
      specified Fourier periods within training signals. The Fourier signals take
      the form $C\sin(\frac{2\pi}{k}+\phi)$, where $C$ is the calculated strength
      or amplitude, $k$ is the user-specified period(s) to search for, and $\phi$
      is the calculated phase shift. The resulting characterization and synthetic
      history generation is deterministic given a single training signal.
      The \xmlNode{fourier} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{target}: \xmlDesc{comma-separated strings, required}, 
            indicates the variables for which this algorithm will be used for characterization.
          \item \xmlAttr{seed}: \xmlDesc{integer, optional}, 
            sets a seed for the underlying random number generator, if present.
      \end{itemize}

      The \xmlNode{fourier} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{periods}: \xmlDesc{comma-separated floats}, 
          Specifies the periods (inverse of frequencies) that should be searched
          for within the training signal.
      \end{itemize}

    \item \xmlNode{arma}:
      characterizes the signal using Auto-Regressive and Moving Average         coefficients to
      stochastically fit the training signal.         The ARMA representation has the following
      form:         \begin{equation*}           A\_t = \sum\_{i=1}^P \phi\_i A\_{t-i} + \epsilon\_t +
      \sum\_{j=1}^Q \theta\_j \epsilon\_{t-j},         \end{equation*}         where $t$ indicates a
      discrete time step, $\phi$ are the signal lag (or auto-regressive)         coefficients, $P$
      is the number of signal lag terms to consider, $\epsilon$ is a random noise         term,
      $\theta$ are the noise lag (or moving average) coefficients, and $Q$ is the number of
      noise lag terms to consider. The ARMA algorithms are developed in RAVEN using the
      \texttt{statsmodels} Python library.
      The \xmlNode{arma} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{target}: \xmlDesc{comma-separated strings, required}, 
            indicates the variables for which this algorithm will be used for characterization.
          \item \xmlAttr{seed}: \xmlDesc{integer, optional}, 
            sets a seed for the underlying random number generator, if present.
          \item \xmlAttr{reduce\_memory}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0], optional}, 
            activates a lower memory usage ARMA training. This does tend to result
            in a slightly slower training time, at the benefit of lower memory usage. For
            example, in one 1000-length history test, low memory reduced memory usage by 2.3
            MiB, but increased training time by 0.4 seconds. No change in results has been
            observed switching between modes. Note that the ARMA must be
            retrained to change this property; it cannot be applied to serialized ARMAs. \default{False}
      \end{itemize}

      The \xmlNode{arma} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{SignalLag}: \xmlDesc{integer}, 
          the number of terms in the AutoRegressive term to retain in the
          regression; typically represented as $P$ in literature.

        \item \xmlNode{NoiseLag}: \xmlDesc{integer}, 
          the number of terms in the Moving Average term to retain in the
          regression; typically represented as $Q$ in literature.
      \end{itemize}

    \item \xmlNode{wavelet}:
      Discrete Wavelet TimeSeriesAnalysis algorithm. Performs a discrete wavelet transform
      on time-dependent data. Note: This TSA module requires pywavelets to be installed within your
      python environment.
      The \xmlNode{wavelet} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{target}: \xmlDesc{comma-separated strings, required}, 
            indicates the variables for which this algorithm will be used for characterization.
          \item \xmlAttr{seed}: \xmlDesc{integer, optional}, 
            sets a seed for the underlying random number generator, if present.
      \end{itemize}

      The \xmlNode{wavelet} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{family}: \xmlDesc{string}, 
          The type of wavelet to use for the transformation.     There are several possible families
          to choose from, and most families contain     more than one variation. For more
          information regarding the wavelet families,     refer to the Pywavelets documentation
          located at:     https://pywavelets.readthedocs.io/en/latest/ref/wavelets.html (wavelet-
          families)     \\     Possible values are:     \begin{itemize}       \item \textbf{haar
          family}: haar       \item \textbf{db family}: db1, db2, db3, db4, db5, db6, db7, db8, db9,
          db10, db11,         db12, db13, db14, db15, db16, db17, db18, db19, db20, db21, db22,
          db23,         db24, db25, db26, db27, db28, db29, db30, db31, db32, db33, db34, db35,
          db36, db37, db38       \item \textbf{sym family}: sym2, sym3, sym4, sym5, sym6, sym7,
          sym8, sym9, sym10,         sym11, sym12, sym13, sym14, sym15, sym16, sym17, sym18, sym19,
          sym20       \item \textbf{coif family}: coif1, coif2, coif3, coif4, coif5, coif6, coif7,
          coif8,         coif9, coif10, coif11, coif12, coif13, coif14, coif15, coif16, coif17
          \item \textbf{bior family}: bior1.1, bior1.3, bior1.5, bior2.2, bior2.4, bior2.6,
          bior2.8, bior3.1, bior3.3, bior3.5, bior3.7, bior3.9, bior4.4, bior5.5,         bior6.8
          \item \textbf{rbio family}: rbio1.1, rbio1.3, rbio1.5, rbio2.2, rbio2.4, rbio2.6,
          rbio2.8, rbio3.1, rbio3.3, rbio3.5, rbio3.7, rbio3.9, rbio4.4, rbio5.5,         rbio6.8
          \item \textbf{dmey family}: dmey       \item \textbf{gaus family}: gaus1, gaus2, gaus3,
          gaus4, gaus5, gaus6, gaus7, gaus8       \item \textbf{mexh family}: mexh       \item
          \textbf{morl family}: morl       \item \textbf{cgau family}: cgau1, cgau2, cgau3, cgau4,
          cgau5, cgau6, cgau7, cgau8       \item \textbf{shan family}: shan       \item \textbf{fbsp
          family}: fbsp       \item \textbf{cmor family}: cmor     \end{itemize}
      \end{itemize}

    \item \xmlNode{PolynomialRegression}:
      fits time-series data using a polynomial function of degree one or greater.
      The \xmlNode{PolynomialRegression} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{target}: \xmlDesc{comma-separated strings, required}, 
            indicates the variables for which this algorithm will be used for characterization.
          \item \xmlAttr{seed}: \xmlDesc{integer, optional}, 
            sets a seed for the underlying random number generator, if present.
      \end{itemize}

      The \xmlNode{PolynomialRegression} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{degree}: \xmlDesc{integer}, 
          Specifies the degree polynomial to fit the data with.
      \end{itemize}

    \item \xmlNode{rwd}:
      TimeSeriesAnalysis algorithm for sliding window snapshots to generate features
      The \xmlNode{rwd} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{target}: \xmlDesc{comma-separated strings, required}, 
            indicates the variables for which this algorithm will be used for characterization.
          \item \xmlAttr{seed}: \xmlDesc{integer, optional}, 
            sets a seed for the underlying random number generator, if present.
      \end{itemize}

      The \xmlNode{rwd} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{signatureWindowLength}: \xmlDesc{integer}, 
          the size of signature window, which represents as a snapshot for a certain time step;
          typically represented as $w$ in literature, or $w\_sig$ in the code.

        \item \xmlNode{featureIndex}: \xmlDesc{integer}, 
          Index used for feature selection, which requires pre-analysis for now, will be addresses
          via other non human work required method

        \item \xmlNode{sampleType}: \xmlDesc{integer}, 
          Indicating the type of sampling.

        \item \xmlNode{seed}: \xmlDesc{integer}, 
          Indicating random seed.
      \end{itemize}
  \end{itemize}

\hspace{24pt}
Example:
\begin{lstlisting}[style=XML,morekeywords={name,subType,pivotLength,shift,target,threshold,period,width}]
<Simulation>
  ...
  <Models>
    ...
    <ROM name="synth" subType="SyntheticHistory">
      <Target>signal1, signal2, hour</Target>
      <Features>scaling</Features>
      <pivotParameter>hour</pivotParameter>
      <fourier target="signal1, signal2">
        <periods>12, 24</periods>
      </fourier>
      <arma target="signal1, signal2" seed='42'>
        <SignalLag>2</SignalLag>
        <NoiseLag>3</NoiseLag>
      </arma>
    </ROM>
    ...
  </Models>
  ...
</Simulation>
\end{lstlisting}


\subsubsection{ARMA}
  The \xmlString{ARMA} ROM is based on an autoregressive moving average time series model with
  Fourier signal processing, sometimes referred to as a FARMA.                         ARMA is a
  type of time dependent model that characterizes the autocorrelation between time series data. The
  mathematic description of ARMA is given as                         \begin{equation*}
  x\_t = \sum\_{i=1}^p\phi\_ix\_{t-i}+\alpha\_t+\sum\_{j=1}^q\theta\_j\alpha\_{t-j},
  \end{equation*}                         where $x$ is a vector of dimension $n$, and $\phi\_i$ and
  $\theta\_j$ are both $n$ by $n$ matrices. When $q=0$, the above is
  autoregressive (AR); when $p=0$, the above is moving average (MA).                         When
  training an ARMA, the input needs to be a synchronized HistorySet. For unsynchronized data, use
  PostProcessor methods to                         synchronize the data before training an ARMA.
  The ARMA model implemented allows an option to use Fourier series to detrend the time series
  before fitting to ARMA model to                         train. The Fourier trend will be stored in
  the trained ARMA model for data generation. The following equation
  describes the detrending                         process.
  \begin{equation*}                         \begin{aligned}                         x\_t &= y\_t -
  \sum\_m\left\{a\_m\sin(2\pi f\_mt)+b\_m\cos(2\pi f\_mt)\right\}  \\                         &=y\_t -
  \sum\_m\ c\_m\sin(2\pi f\_mt+\phi\_m)                         \end{aligned}
  \end{equation*}                         where $1/f\_m$ is defined by the user parameter
  \xmlNode{Fourier}. \nb $a\_m$ and $b\_m$ will be calculated then transformed to
  $c\_m$ and $\phi$. The $c\_m$ will be stored as \xmlString{amplitude}, and $\phi$ will be stored as
  \xmlString{phase}.                         By default, each target in the training will be
  considered independent and have an unique ARMA for each                         target.
  Correlated targets can be specified through the \xmlNode{correlate} node, at which point
  the correlated targets will be trained together using a vector ARMA (or VARMA). Due to limitations
  in                         the VARMA, in order to seed samples the VARMA must be trained with the
  node \xmlNode{seed}, which acts                         independently from the global random seed
  used by other RAVEN entities.                         Both the ARMA and VARMA make use of the
  \texttt{statsmodels} python package.                         In order to use this Reduced Order
  Model, the \xmlNode{ROM} attribute                         \xmlAttr{subType} needs to be
  \xmlString{ARMA}.

  The \xmlNode{ARMA} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{ARMA} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      defines the pivot variable (e.g., time) that is non-decreasing in
      the input HistorySet.

    \item \xmlNode{correlate}: \xmlDesc{comma-separated strings}, 
      indicates the listed variables                                                    should be
      considered as influencing each other, and trained together instead of independently.  This
      node                                                    can only be listed once, so all
      variables that are desired for correlation should be included.  \nb The
      correlated VARMA takes notably longer to train than the independent ARMAs for the same number
      of targets.

    \item \xmlNode{seed}: \xmlDesc{integer}, 
      provides seed for VARMA and ARMA sampling.
      Must be provided before training. If no seed is assigned,
      then a random number will be used.

    \item \xmlNode{reseedCopies}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      if \xmlString{True} then whenever the ARMA is loaded from file, a
      random reseeding will be performed to ensure different histories. \nb If
      reproducible histories are desired for an ARMA loaded from file,
      \xmlNode{reseedCopies} should be set to \xmlString{False}, and in the
      \xmlNode{RunInfo} block \xmlNode{batchSize} needs to be 1
      and \xmlNode{internalParallel} should be
      \xmlString{False} for RAVEN runs sampling the trained ARMA model.
      If \xmlNode{InternalParallel} is \xmlString{True} and the ARMA has
      \xmlNode{reseedCopies} as \xmlString{False}, an identical ARMA history
      will always be provided regardless of how many samples are taken.
      If \xmlNode{InternalParallel} is \xmlString{False} and \xmlNode{batchSize}
      is more than 1, it is not possible to guarantee the order of RNG usage by
      the separate processes, so it is not possible to guarantee reproducible
      histories are generated.

    \item \xmlNode{P}: \xmlDesc{integer}, 
      defines the value of $p$.

    \item \xmlNode{Q}: \xmlDesc{integer}, 
      defines the value of $q$.

    \item \xmlNode{Fourier}: \xmlDesc{comma-separated integers}, 
      must be positive integers. This defines the
      based period that will be used for Fourier detrending, i.e., this
      field defines $1/f\_m$ in the above equation.
      When this filed is not specified, the ARMA considers no Fourier detrend.

    \item \xmlNode{Peaks}: \xmlDesc{string}, 
      designed to estimate the peaks in signals that repeat with some frequency,
      often in periodic data.
      The \xmlNode{Peaks} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{target}: \xmlDesc{string, required}, 
            defines the name of one target (besides the                         pivot parameter)
            expected to have periodic peaks.
          \item \xmlAttr{threshold}: \xmlDesc{float, required}, 
            user-defined minimum required                         height of peaks (absolute value).
          \item \xmlAttr{period}: \xmlDesc{float, required}, 
            user-defined expected period for target variable.
      \end{itemize}

      The \xmlNode{Peaks} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{nbin}: \xmlDesc{integer}, 
          -- no description yet --

        \item \xmlNode{window}: \xmlDesc{comma-separated floats}, 
          lists the window of time within each period in which a peak should be discovered.
          The text of this node is the upper and lower boundary of this
          window \emph{relative to} the start of the period, separated by a comma.
          User can define the lower bound to be a negative
          number if the window passes through one side of one period. For example, if the period is
          24                                                  hours, the window can be -2,2 which is
          equivalent to 22, 2.
          The \xmlNode{window} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{width}: \xmlDesc{float, required}, 
                The user defined  width of peaks in that window. The width is in the unit of the
                signal as well.
          \end{itemize}
      \end{itemize}

    \item \xmlNode{preserveInputCDF}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      enables a final transform on sampled                                                    data
      coercing it to have the same distribution as the original data. If \xmlString{True}, then
      every                                                    sample generated by this ARMA after
      training will have a distribution of values that conforms within
      numerical accuracy to the original data. This is especially useful when variance is desired
      not to stretch                                                    the most extreme events
      (high or low signal values), but instead the sequence of events throughout this
      history. For example, this transform can preserve the load duration curve for a load signal.

    \item \xmlNode{SpecificFourier}: \xmlDesc{string}, 
      provides a means to specify different Fourier
      decomposition for different target variables.  Values given in the subnodes of this node will
      supercede                                                    the defaults set by the
      \xmlNode{Fourier} and \xmlNode{FourierOrder} nodes.
      The \xmlNode{SpecificFourier} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variables}: \xmlDesc{comma-separated strings, required}, 
            lists the variables to whom                     the \xmlNode{SpecificFourier} parameters
            will apply.
      \end{itemize}

      The \xmlNode{SpecificFourier} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{periods}: \xmlDesc{comma-separated integers}, 
          lists the (fundamental)                                                    periodic
          wavelength of the Fourier decomposition for these variables,
          as in the \xmlNode{Fourier} general node.
      \end{itemize}

    \item \xmlNode{Multicycle}: \xmlDesc{string}, 
      indicates that each sample of the ARMA should yield
      multiple sequential samples. For example, if an ARMA model is trained to produce a year's
      worth of data,                                                    enabling
      \xmlNode{Multicycle} causes it to produce several successive years of data. Multicycle
      sampling                                                    is independent of ROM training,
      and only changes how samples of the ARMA are created.
      \nb The output of a multicycle ARMA must be stored in a \xmlNode{DataSet}, as the targets will
      depend                                                    on both the \xmlNode{pivotParameter}
      as well as the cycle, \xmlString{Cycle}. The cycle is a second
      \xmlNode{Index} that all targets should depend on, with variable name \xmlString{Cycle}.

      The \xmlNode{Multicycle} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{cycles}: \xmlDesc{integer}, 
          the number of cycles the ARMA should produce
          each time it yields a sample.

        \item \xmlNode{growth}: \xmlDesc{float}, 
          if provided then the histories produced by
          the ARMA will be increased by the growth factor for successive cycles. This node can be
          added                                                    multiple times with different
          settings for different targets.                                                    The
          text of this node is the growth factor in percentage. Some examples are in
          Table~\ref{tab:arma multicycle growth}, where \emph{Growth factor} is the value used in
          the RAVEN                                                    input and \emph{Scaling
          factor} is the value by which the history will be multiplied.
          \begin{table}[h!]                                                      \centering
          \begin{tabular}{r c l}                                                        Growth
          factor & Scaling factor & Description \\ \hline
          50 & 1.5 & growing by 50\% each cycle \\
          -50 & 0.5 & shrinking by 50\% each cycle \\
          150 & 2.5 & growing by 150\% each cycle \\
          \end{tabular}                                                      \caption{ARMA Growth
          Factor Examples}                                                      \label{tab:arma
          multicycle growth}                                                    \end{table}
          The \xmlNode{growth} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{targets}: \xmlDesc{comma-separated strings, required}, 
                lists the targets                     in this ARMA that this growth factor should
                apply to.
              \item \xmlAttr{start\_index}: \xmlDesc{integer, optional}, 
                -- no description yet --
              \item \xmlAttr{end\_index}: \xmlDesc{integer, optional}, 
                -- no description yet --
              \item \xmlAttr{mode}: \xmlDesc{[exponential, linear], required}, 
                either \xmlString{linear} or                     \xmlString{exponential}, determines
                the manner in which the growth factor is applied.                     If
                \xmlString{linear}, then the scaling factor is $(1+y\cdot g/100)$;
                if \xmlString{exponential}, then the scaling factor is $(1+g/100)^y$;
                where $y$ is the cycle after the first and $g$ is the provided scaling factor.
          \end{itemize}
      \end{itemize}

    \item \xmlNode{nyquistScalar}: \xmlDesc{integer}, 
      -- no description yet --

    \item \xmlNode{ZeroFilter}: \xmlDesc{string}, 
      turns on \emph{zero filtering}                                                  for the listed
      targets. Zero filtering is a very specific algorithm, and should not be used without
      understanding its application.  When zero filtering is enabled, the ARMA will remove all the
      values from                                                  the training data equal to zero
      for the target, then train on the remaining data (including Fourier detrending
      if applicable). If the target is set as correlated to another target, the second target will
      be treated as                                                  two distinct series: one
      containing times in which the original target is zero, and one in the remaining
      times. The results from separated ARMAs are recombined after sampling. This can be a
      methodology for                                                  treating histories with long
      zero-value segments punctuated periodically by peaks.
      The \xmlNode{ZeroFilter} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{tol}: \xmlDesc{float, optional}, 
            -- no description yet --
      \end{itemize}

    \item \xmlNode{outTruncation}: \xmlDesc{comma-separated strings}, 
      defines whether and how output                                                    time series
      are limited in domain. This node has one attribute, \xmlAttr{domain}, whose value can be
      \xmlString{positive} or \xmlString{negative}. The value of this node contains the list of
      targets to whom                                                    this domain limitation
      should be applied. In the event a negative value is discovered in a target whose
      domain is strictly positive, the absolute value of the original negative value will be used
      instead, and                                                    similarly for the negative
      domain.
      The \xmlNode{outTruncation} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{domain}: \xmlDesc{[positive, negative], required}, 
            -- no description yet --
      \end{itemize}
  \end{itemize}

In addition, \xmlNode{Segment} can be used to divided the ROM. In order to enable the segmentation, the
user need to specify following information for \xmlNode{Segment}:
\begin{itemize}
  \item \xmlNode{Segment}, \xmlDesc{node, optional}, provides an alternative way to build the ROM. When
    this mode is enabled, the subspace of the ROM (e.g. ``time'') will be divided into segments as
    requested, then a distinct ROM will be trained on each of the segments. This is especially helpful if
    during the subspace the ROM representation of the signal changes significantly. For example, if the signal
    is different during summer and winter, then a signal can be divided and a distinct ROM trained on the
    segments. By default, no segmentation occurs.

    To futher enable clustering of the segments, the \xmlNode{Segment} has the following attributes:
    \begin{itemize}
      \item \xmlAttr{grouping}, \xmlDesc{string, optional field} enables the use of ROM subspace clustering in
        addition to segmenting if set to \xmlString{cluster}. If set to \xmlString{segment}, then performs
        segmentation without clustering. If clustering, then an additional node needs to be included in the
        \xmlNode{Segment} node, as described below.
        \default{segment}
    \end{itemize}

    This node takes the following subnodes:
    \begin{itemize}
      \item \xmlNode{subspace}, \xmlDesc{string, required field} designates the subspace to divide. This
        should be the pivot parameter (often ``time'') for the ROM. This node also requires an attribute
        to determine how the subspace is divided, as well as other attributes, described below:
        \begin{itemize}
          \item \xmlAttr{pivotLength}, \xmlDesc{float, optional field}, provides the value in the subspace
            that each segment should attempt to represent, independently of how the data is stored. For
            example, if the subspace has hourly resolution, is measured in seconds, and the desired
            segmentation is daily, the \xmlAttr{pivotLength} would be 86400.
            Either this option or \xmlAttr{divisions} must be provided.
          \item \xmlAttr{divisions}, \xmlDesc{integer, optional field}, as an alternative to
            \xmlAttr{pivotLength}, this attribute can be used to specify how many data points to include in
            each subdivision, rather than use the pivot values. The algorithm will attempt to split the data
            points as equally as possible.
            Either this option or \xmlAttr{pivotLength} must be provided.
          \item \xmlAttr{shift}, \xmlDesc{string, optional field}, governs the way in which the subspace is
            treated in each segment. By default, the subspace retains its actual values for each segment; for
            example, if each segment is 4 hours long, the first segment starts at time 0, the second at 4
            hours, the third at 8 hours, and so forth. Options to change this behavior are \xmlString{zero}
            and \xmlString{first}. In the case of \xmlString{zero}, each segment restarts the pivot with the
            subspace value as 0, shifting all other values similarly. In the example above, the first segment
            would start at 0, the second at 0, and the third at 0, with each ending at 4 hours. Note that the
            pivot values are restored when the ROM is evaluated. Using \xmlString{first}, each segment
            subspace restarts at the value of the first segment. This is useful in the event subspace 0 is not
            a desirable value.
        \end{itemize}
      \item \xmlNode{Classifier}, \xmlDesc{string, optional field} associates a \xmlNode{PostProcessor}
        defined in the \xmlNode{Models} block to this segmentation. If clustering is enabled (see
        \xmlAttr{grouping} above), then this associated Classifier will be used to cluster the segmented ROM
        subspaces. The attributes \xmlAttr{class}=\xmlString{Models} and
        \xmlAttr{type}=\xmlString{PostProcessor} must be set, and the text of this node is the \xmlAttr{name}
        of the requested Classifier. Note this Classifier must be a valid Classifier; not all PostProcessors
        are suitable. For example, see the DataMining PostProcessor subtype Clustering.
      \item \xmlNode{clusterFeatures}, \xmlDesc{string, optional field}, if clustering then delineates
        the fundamental ROM features that should be considered while clustering. The available features are
        ROM-dependent, and an exception is raised if an unrecognized request is given. See individual ROMs
        for options. \default All ROM-specific options.
      \item \xmlNode{evalMode}, \xmlDesc{string, optional field}, one of \xmlString{truncated},
        \xmlString{full}, or \xmlString{clustered}, determines how the evaluations are
        represented, as follows:
        \begin{itemize}
          \item \xmlString{full}, reproduce the full signal using representative cluster segments,
          \item \xmlString{truncated}, reproduce a history containing exactly segment from each
            cluster placed back-to-back, with the \xmlNode{pivotParameter} spanning the clustered
            dimension. Note this will almost surely not be the same length as the original signal;
            information about indexing can be found in the ROM's XML metadata.
          \item \xmlString{clustered}, reproduce a N-dimensional object with the variable
            \texttt{\_ROM\_cluster} as one of the indexes for the ROM's sampled variables. Note that
            in order to use the option, the receiving \xmlNode{DataObject} should be of type
            \xmlNode{DataSet} with one of the indices being \texttt{\_ROM\_cluster}.
        \end{itemize}
     \item \xmlNode{evaluationClusterChoice}, \xmlDesc{string, optional field}, one of \xmlString{first} or
        \xmlString{random}, determines, if \xmlAttr{grouping}$=cluster$, which
        strategy needs to be followed for the evaluation stage. If ``first'', the
        first ROM (representative segmented ROM),in each cluster, is considered to
         be representative of the full space in the cluster (i.e. the evaluation is always performed
         interrogating the first ROM in each cluster); If ``random'', a random ROM, in each cluster,
         is choosen when an evaluation is requested.
   \nb if ``first'' is used, there is \emph{substantial} memory savings when compared to using
   ``random''.
         %If ``centroid'', a ROM ``trained" on the centroids
         %information of each cluster is used for the evaluation (\nb ``centroid'' option is not
         %available yet).
         \default{first}
    \end{itemize}
\end{itemize}

\hspace{24pt}
General ARMA Example:
\begin{lstlisting}[style=XML, morekeywords={name,subType,pivotLength,shift,target,threshold,period,width}]
<Simulation>
  ...
  <Models>
    ...
    <ROM name='aUserDefinedName' subType='ARMA'>
      <pivotParameter>Time</pivotParameter>
      <Features>scaling</Features>
      <Target>Speed1,Speed2</Target>
      <P>5</P>
      <Q>4</Q>
      <Segment>
        <subspace pivotLength="1296000" shift="first">Time</subspace>
      </Segment>
      <preserveInputCDF>True</preserveInputCDF>
      <Fourier>604800,86400</Fourier>
      <FourierOrder>2, 4</FourierOrder>
      <Peaks target='Speed1' threshold='0.1' period='86400'>
        <window width='14400' >-7200,10800</window>
        <window width='18000' >64800,75600</window>
      </Peaks>
     </ROM>
    ...
  </Models>
  ...
</Simulation>
\end{lstlisting}


\subsubsection{PolyExponential}
  The \xmlNode{PolyExponential} contains a single ROM type, aimed to construct a     time-dependent
  (or any other monotonic variable) surrogate model based on polynomial sum of exponential term.
  This surrogate have the form:     \begin{equation}       SM(X,z) = \sum\_{i=1}^{N} P\_{i}(X) \times
  \exp ( - Q\_{i}(X) \times z )     \end{equation}     where:     \begin{itemize}       \item
  $\mathbf{z}$ is the independent  monotonic variable (e.g. time)       \item $\mathbf{X}$  is the
  vector of the other independent (parametric) variables  (Features)       \item $\mathbf{P\_{i}}(X)$
  is a polynomial of rank M function of the parametric space X       \item  $\mathbf{Q\_{i}}(X)$ is a
  polynomial of rank M function of the parametric space X       \item  $\mathbf{N}$ is the number of
  requested exponential terms.     \end{itemize}     It is crucial to notice that this model is
  quite suitable for FOMs whose drivers are characterized by an exponential-like behavior.     In
  addition, it is important to notice that the exponential terms' coefficients are computed running
  a genetic-algorithm optimization     problem, which is quite slow in case of increasing number of
  ``numberExpTerms''.     In order to use this Reduced Order Model, the \xmlNode{ROM} attribute
  \xmlAttr{subType} needs to be set equal to \xmlString{PolyExponential}.     \\     Once the ROM is
  trained (\textbf{Step} \xmlNode{RomTrainer}), its coefficients can be exported into an XML file
  via an \xmlNode{OutStream} of type \xmlAttr{Print}. The following variable/parameters can be
  exported (i.e. \xmlNode{what} node     in \xmlNode{OutStream} of type \xmlAttr{Print}):
  \begin{itemize}       \item \xmlNode{expTerms}, see XML input specifications above, inquired pre-
  pending the keyword ``output|'' (e.g. output| expTerms)       \item \xmlNode{coeffRegressor}, see
  XML input specifications above       \item \xmlNode{polyOrder}, see XML input specifications above
  \item \xmlNode{features}, see XML input specifications above       \item \xmlNode{timeScale}, XML
  node containing the array of the training time steps values       \item \xmlNode{coefficients},
  XML node containing the exponential terms' coefficients for each realization     \end{itemize}

  The \xmlNode{PolyExponential} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{PolyExponential} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      defines the pivot variable (e.g., time) that represents the
      independent monotonic variable

    \item \xmlNode{numberExpTerms}: \xmlDesc{integer}, 
      the number of exponential terms to be used ($N$ above)

    \item \xmlNode{coeffRegressor}: \xmlDesc{[poly, spline, nearest]}, 
      defines which regressor to use for interpolating the
      exponential coefficient. Available are ``spline'',``poly'' and ``nearest''.

    \item \xmlNode{polyOrder}: \xmlDesc{integer}, 
      the polynomial order to be used for interpolating the exponential
      coefficients. Only valid in case of  \xmlNode{coeffRegressor} set to ``poly''.

    \item \xmlNode{tol}: \xmlDesc{float}, 
      relative tolerance of the optimization problem (differential evolution optimizer)

    \item \xmlNode{max\_iter}: \xmlDesc{integer}, 
      maximum number of iterations (generations) for the
      optimization problem  (differential evolution optimizer)
  \end{itemize}

\hspace{24pt}
Example:
\begin{lstlisting}[style=XML,morekeywords={name,subType}]
<Simulation>
  ...
  <Models>
    ...
   <ROM name='PolyExp' subType='PolyExponential'>
     <Target>time,decay_heat, xe135_dens</Target>
     <Features>enrichment,bu</Features>
     <pivotParameter>time</pivotParameter>
     <numberExpTerms>5</numberExpTerms>
     <max_iter>1000000</max_iter>
     <tol>0.000001</tol>
  </ROM>
    ...
  </Models>
  ...
</Simulation>
\end{lstlisting}

Example to export the coefficients of trained PolyExponential ROM:
\begin{lstlisting}[style=XML,morekeywords={name,subType}]
<Simulation>
  ...
  <OutStreams>
    ...
    <Print name = 'dumpAllCoefficients'>
      <type>xml</type>
      <source>PolyExp</source>
      <!--
        here the <what> node is omitted. All the available params/coefficients
        are going to be printed out
      -->
    </Print>
    <Print name = 'dumpSomeCoefficients'>
      <type>xml</type>
      <source>PolyExp</source>
      <what>coefficients,timeScale</what>
    </Print>
    ...
  </OutStreams>
  ...
</Simulation>
\end{lstlisting}


\subsubsection{DMD}
  The \xmlString{DMD} ROM aimed to construct a time-dependent (or any other monotonic
  variable) surrogate model based on Dynamic Mode Decomposition         This surrogate is aimed to
  perform a ``dimensionality reduction regression'', where, given time         series (or any
  monotonic-dependent variable) of data, a set of modes each of which is associated         with a
  fixed oscillation frequency and decay/growth rate is computed         in order to represent the
  data-set.         In order to use this Reduced Order Model, the \xmlNode{ROM} attribute
  \xmlAttr{subType} needs to be set equal to \xmlString{DMD}.         \\         Once the ROM  is
  trained (\textbf{Step} \xmlNode{RomTrainer}), its parameters/coefficients can be exported into an
  XML file         via an \xmlNode{OutStream} of type \xmlAttr{Print}. The following
  variable/parameters can be exported (i.e. \xmlNode{what} node         in \xmlNode{OutStream} of
  type \xmlAttr{Print}):         \begin{itemize}           \item \xmlNode{rankSVD}, see XML input
  specifications below           \item \xmlNode{energyRankSVD}, see XML input specifications below
  \item \xmlNode{rankTLSQ}, see XML input specifications below           \item \xmlNode{exactModes},
  see XML input specifications below           \item \xmlNode{optimized}, see XML input
  specifications below           \item \xmlNode{features}, see XML input specifications below
  \item \xmlNode{timeScale}, XML node containing the array of the training time steps values
  \item \xmlNode{dmdTimeScale}, XML node containing the array of time scale in the DMD space (can be
  used as mapping           between the  \xmlNode{timeScale} and \xmlNode{dmdTimeScale})
  \item \xmlNode{eigs}, XML node containing the eigenvalues (imaginary and real part)
  \item \xmlNode{amplitudes}, XML node containing the amplitudes (imaginary and real part)
  \item \xmlNode{modes}, XML node containing the dynamic modes (imaginary and real part)
  \end{itemize}

  The \xmlNode{DMD} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{DMD} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{dmdType}: \xmlDesc{[dmd, hodmd]}, 
      the type of Dynamic Mode Decomposition to apply.Available are:
      \begin{itemize}                                                     \item \textit{dmd}, for
      classical DMD                                                     \item \textit{hodmd}, for
      high order DMD.                                                   \end{itemize}

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      defines the pivot variable (e.g., time) that represents the
      independent monotonic variable

    \item \xmlNode{rankSVD}: \xmlDesc{integer}, 
      defines the truncation rank to be used for the SVD.
      Available options are:                                                  \begin{itemize}
      \item \textit{-1}, no truncation is performed
      \item \textit{0}, optimal rank is internally computed
      \item \textit{>1}, this rank is going to be used for the truncation
      \end{itemize}

    \item \xmlNode{energyRankSVD}: \xmlDesc{float}, 
      energy level ($0.0 < float < 1.0$) used to compute the rank such
      as computed rank is the number of the biggest singular values needed to reach the energy
      identified by                                                    \xmlNode{energyRankSVD}. This
      node has always priority over  \xmlNode{rankSVD}

    \item \xmlNode{rankTLSQ}: \xmlDesc{integer}, 
      $int > 0$ that defines the truncation rank to be used for the total
      least square problem. If not inputted, no truncation is applied

    \item \xmlNode{exactModes}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      True if the exact modes need to be computed (eigenvalues and
      eigenvectors),   otherwise the projected ones (using the left-singular matrix after SVD).

    \item \xmlNode{optimized}: \xmlDesc{float}, 
      True if the amplitudes need to be computed minimizing the error
      between the modes and all the time-steps or False, if only the 1st timestep only needs to be
      considered
  \end{itemize}

\hspace{24pt}
Example:
\textbf{Example:}
\begin{lstlisting}[style=XML,morekeywords={name,subType}]
<Simulation>
  ...
  <Models>
    ...
   <ROM name='DMD' subType='DMD'>
      <Target>time,totals_watts, xe135_dens</Target>
      <Features>enrichment,bu</Features>
      <dmdType>dmd</dmdType>
      <pivotParameter>time</pivotParameter>
      <rankSVD>0</rankSVD>
      <rankTLSQ>5</rankTLSQ>
      <exactModes>False</exactModes>
      <optimized>True</optimized>
    </ROM
    ...
  </Models>
  ...
</Simulation>
\end{lstlisting}

Example to export the coefficients of trained DMD ROM:
\begin{lstlisting}[style=XML,morekeywords={name,subType}]
<Simulation>
  ...
  <OutStreams>
    ...
    <Print name = 'dumpAllCoefficients'>
      <type>xml</type>
      <source>DMD</source>
      <!--
        here the <what> node is omitted. All the available params/coefficients
        are going to be printed out
      -->
    </Print>
    <Print name = 'dumpSomeCoefficients'>
      <type>xml</type>
      <source>DMD</source>
      <what>eigs,amplitudes,modes</what>
    </Print>
    ...
  </OutStreams>
  ...
</Simulation>
\end{lstlisting}


\subsubsection{DMDC}
  The \xmlString{DMDC} contains a single ROM type similar to DMD, aimed to         construct a time-
  dependent surrogate model based on Dynamic         Mode Decomposition with Control (ref.
  \cite{proctor2016dynamic}).         In addition to perform a ``dimensionality reduction
  regression'' like DMD, this surrogate will         calculate the state-space representation
  matrices A, B and  C in a discrete time domain:         \begin{itemize}           \item
  $x[k+1]=A*x[k]+B*u[k]$           \item $y[k+1]=C*x[k+1]$         \end{itemize}          In order
  to use this Reduced Order Model, the \xmlNode{ROM} attribute         \xmlAttr{subType} needs to be
  set equal to \xmlString{DMDC}.         \\         Once the ROM  is trained (\textbf{Step}
  \xmlNode{RomTrainer}), its         parameters/coefficients can be exported into an XML file
  via an \xmlNode{OutStream} of type \xmlAttr{Print}. The following variable/parameters can be
  exported (i.e.         \xmlNode{what} node         in \xmlNode{OutStream} of type
  \xmlAttr{Print}):         \begin{itemize}           \item \xmlNode{rankSVD}, see XML input
  specifications below           \item \xmlNode{actuators}, XML node containing the list of actuator
  variables (u),                  see XML input specifications below           \item
  \xmlNode{stateVariables}, XML node containing the list of system state variables (x),
  see XML input specifications below           \item \xmlNode{initStateVariables}, XML node
  containing the list of system state variables                 (x\_init) that are used for
  initializing the model in ``evaluation'' mode,                  see XML input specifications below
  \item \xmlNode{outputs}, XML node containing the list of system output variables (y)
  \item \xmlNode{dmdTimeScale}, XML node containing the the array of time scale in the DMD space,
  which is time axis in traning data (Time)           \item \xmlNode{UNorm}, XML node containing the
  norminal values of actuators,                  which are the initial actuator values in the
  training data           \item \xmlNode{XNorm}, XML node containing the norminal values of state
  variables,                 which are the initial state values in the training data           \item
  \xmlNode{XLast}, XML node containing the last value of state variables,                 which are
  the final state values in the training data (before nominal value subtraction)           \item
  \xmlNode{YNorm}, XML node containing the norminal values of output variables,
  which are the initial output values in the training data           \item \xmlNode{Atilde},  XML
  node containing the A matrix in discrete time domain                 (imaginary part, matrix
  shape, and real part)           \item \xmlNode{Btilde}, XML node containing the B matrix in
  discrete time domain                 (imaginary part, matrix shape, and real part)           \item
  \xmlNode{Ctilde}, XML node containing the C matrix in discrete time domain
  (imaginary part, matrix shape, and real part)         \end{itemize}

  The \xmlNode{DMDC} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{DMDC} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      defines the pivot variable (e.g., time) that represents the
      independent monotonic variable

    \item \xmlNode{rankSVD}: \xmlDesc{integer}, 
      defines the truncation rank to be used for the SVD.
      Available options are:                                                  \begin{itemize}
      \item \textit{-1}, no truncation is performed
      \item \textit{0}, optimal rank is internally computed
      \item \textit{>1}, this rank is going to be used for the truncation
      \end{itemize}

    \item \xmlNode{energyRankSVD}: \xmlDesc{float}, 
      energy level ($0.0 < float < 1.0$) used to compute the rank such
      as computed rank is the number of the biggest singular values needed to reach the energy
      identified by                                                    \xmlNode{energyRankSVD}. This
      node has always priority over  \xmlNode{rankSVD}

    \item \xmlNode{rankTLSQ}: \xmlDesc{integer}, 
      $int > 0$ that defines the truncation rank to be used for the total
      least square problem. If not inputted, no truncation is applied

    \item \xmlNode{exactModes}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      True if the exact modes need to be computed (eigenvalues and
      eigenvectors),   otherwise the projected ones (using the left-singular matrix after SVD).

    \item \xmlNode{optimized}: \xmlDesc{float}, 
      True if the amplitudes need to be computed minimizing the error
      between the modes and all the time-steps or False, if only the 1st timestep only needs to be
      considered

    \item \xmlNode{actuators}: \xmlDesc{comma-separated strings}, 
      defines the actuators (i.e. system input parameters)
      of this model. Each actuator variable (u1, u2, etc.) needs to
      be listed here.

    \item \xmlNode{stateVariables}: \xmlDesc{comma-separated strings}, 
      defines the state variables (i.e. system variable vectors)
      of this model. Each state variable (x1, x2, etc.) needs to be listed
      here. The variables indicated in \xmlNode{stateVariables} must be
      listed in the \xmlNode{Target} node too.

    \item \xmlNode{initStateVariables}: \xmlDesc{comma-separated strings}, 
      defines the state variables' ids  that should be used as
      initialization variable                                                   in the evaluation
      stage (for the evaluation of the model).
      These variables are used for the first time step to initiate
      the rolling time-step prediction of the state variables, ``exited''
      by the \xmlNode{actuators} signal. The variables listed in
      \xmlNode{initStateVariables} must be listed in the  \xmlNode{Features}
      node too.

    \item \xmlNode{subtractNormUXY}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      True if the initial values need to be subtracted from the
      actuators (u), state (x) and outputs (y) if any. False if the subtraction
      is not needed.
  \end{itemize}

\hspace{24pt}
Example of DMDc ROM definition, with 1 actuator variable (u1), 3 state variables (x1, x2, x3), 2 output variables (y1, y2), and 2 scheduling parameters (mod, flow):
\begin{lstlisting}[style=XML,morekeywords={name,subType}]
<Simulation>
   ...
   <Models>
     ...
    <ROM name="DMDrom" subType="DMDC">
      <!-- Target contains Time, StateVariable Names (x) and OutputVariable Names (y) in training data -->
      <Target>Time,x1,x2,x3,y1,y2</Target>
      <!-- Actuator Variable Names (u) -->
      <actuators>u1</actuators>
      <!-- StateVariables Names (x) -->
      <stateVariables>x1,x2,x3</stateVariables>
      <!-- Pivot variable (e.g. Time) -->
      <pivotParameter>Time</pivotParameter>
      <!-- rankSVD: -1 = No truncation; 0 = optimized truncation; pos. int = truncation level -->
      <rankSVD>1</rankSVD>
      <!-- SubtractNormUXY: True = will subtract the initial values from U,X,Y -->
      <subtractNormUXY>True</subtractNormUXY>
	    
      <!-- Features are the variable names for predictions: Actuator "u", scheduling parameters, and initial states -->
      <Features>u1,mod,flow,x1_init,x2_init,x3_init</Features>
      <!-- Initialization Variables-->
      <initStateVariables>
        x1_init,x2_init,x3_init
      </initStateVariables>
    </ROM>
     ...
   </Models>
   ...
 </Simulation>

\end{lstlisting}

Example to export the coefficients of trained DMDC ROM:
\begin{lstlisting}[style=XML,morekeywords={name,subType}]
<Simulation>
  ...
  <OutStreams>
    ...
    <Print name = 'dumpAllCoefficients'>
      <type>xml</type>
      <source>DMDc</source>
      <!--
        here the <what> node is omitted. All the available params/coefficients
        are going to be printed out
      -->
    </Print>
    <Print name = 'dumpSomeCoefficients'>
      <type>xml</type>
      <source>DMDc</source>
      <what>rankSVD,UNorm,XNorm,XLast,Atilde,Btilde</what>
    </Print>
    ...
  </OutStreams>
  ...
</Simulation>
\end{lstlisting}


\subsubsection{KerasMLPRegression}
  Multi-Layer Perceptron (MLP) (or Artificial Neural Network - ANN), a class of feedforward
  ANN, can be viewed as a logistic regression where input is first transformed         using a non-
  linear transformation. This transformation probjects the input data into a         space where it
  becomes linearly separable. This intermediate layer is referred to as a         \textbf{hidden
  layer}. An MLP consists of at least three layers of nodes. Except for the         input nodes,
  each node is a neuron that uses a nonlinear \textbf{activation function}. MLP         utilizes a
  suppervised learning technique called \textbf{Backpropagation} for training.         Generally, a
  single hidden layer is sufficient to make MLPs a universal approximator.         However, many
  hidden layers, i.e. deep learning, can be used to model more complex nonlinear
  relationships. The extra layers enable composition of features from lower layers, potentially
  modeling complex data with fewer units than a similarly performing shallow network.         \\
  \zNormalizationPerformed{KerasMLPRegression}         \\         In order to use this ROM, the
  \xmlNode{ROM} attribute \xmlAttr{subType} needs to         be \xmlString{KerasMLPRegression}

  The \xmlNode{KerasMLPRegression} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{KerasMLPRegression} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{metrics}: \xmlDesc{comma-separated strings}, 
      list of metrics to be evaluated by         the model during training and testing. available
      metrics include         \textit{binary\_accuracy}, \textit{categorical\_accuracy},
      \textit{sparse\_categorical\_accuracy},         \textit{top\_k\_categorical\_accuracy},
      \textit{sparse\_top\_k\_categorical\_accuracy}.

    \item \xmlNode{batch\_size}: \xmlDesc{integer}, 
      number of samples per gradient update.

    \item \xmlNode{epochs}: \xmlDesc{integer}, 
      number of epochs to train the model. An epoch         is an iteration over the entire training
      data.

    \item \xmlNode{random\_seed}: \xmlDesc{integer}, 
      a integer to use as random seed.

    \item \xmlNode{plot\_model}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      if true the DNN model constructed by RAVEN will be         plotted and stored in the working
      directory. The file name will be \textit{"ROM name" + "\_" + "model.png"}.         \nb This
      capability requires the following libraries, i.e. pydot-ng and graphviz to be installed.

    \item \xmlNode{num\_classes}: \xmlDesc{integer}, 
      dimensionality of the output space of given classifier.

    \item \xmlNode{validation\_split}: \xmlDesc{float}, 
      float between 0 and 1, the fraction of the training data to         be used as validation
      data.

    \item \xmlNode{output\_layer\_activation}: \xmlDesc{string}, 
      activation function for output layer of deep neural network

    \item \xmlNode{loss}: \xmlDesc{string}, 
      if the model has multiple outputs, you can use a different         loss metric on each output
      by passing a list of loss metrics. The value that will be minimized by the model will then
      be the sum of all individual value from each loss metric. Available loss functions include
      \textit{mean\_squared\_error},         \textit{mean\_absolute\_error},
      \textit{mean\_absolute\_percentage\_error}, \textit{mean\_squared\_logarithmic\_error},
      \textit{squared\_hinge}, \textit{hinge}, \textit{categorical\_hinge}, \textit{logcosh},
      \textit{categorical\_crossentropy},         \textit{sparse\_categorical\_crossentropy},
      \textit{binary\_crossentropy}, \textit{kullback\_leibler\_divergence},
      \textit{poisson}, \textit{cosine\_proximity}.

    \item \xmlNode{optimizerSetting}: \xmlDesc{string}, 
      The settings for optimizer

      The \xmlNode{optimizerSetting} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{beta\_1}: \xmlDesc{float}, 
          $0 < beta < 1$. Generally close to 1.

        \item \xmlNode{beta\_2}: \xmlDesc{float}, 
          $0 < beta < 1$. Generally close to 1.

        \item \xmlNode{decay}: \xmlDesc{float}, 
          learning rate decay over each update.

        \item \xmlNode{lr}: \xmlDesc{float}, 
          learning rate.

        \item \xmlNode{optimizer}: \xmlDesc{string}, 
          name of optimizer.

        \item \xmlNode{epsilon}: \xmlDesc{float}, 
          fuzz factor.

        \item \xmlNode{momentum}: \xmlDesc{float}, 
          Parameter that accelerates SGD in         the relevant direction and dampens oscillations.

        \item \xmlNode{nesterov}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
          whether to apply Nesterov momentum

        \item \xmlNode{rho}: \xmlDesc{float}, 
          $> 0$
      \end{itemize}

    \item \xmlNode{Dense}: \xmlDesc{string}, 
      regular densely-connected neural network layer.
      The \xmlNode{Dense} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{name}: \xmlDesc{string, required}, 
            name of this layer. The value will be         used in \xmlNode{layer\_layout} to
            construct the fully connected neural network.
      \end{itemize}

      The \xmlNode{Dense} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{activation}: \xmlDesc{string}, 
          including {`relu', `tanh', `elu', `selu', `softplus', `softsign', `sigmoid',
          `hard\_sigmoid', `linear', `softmax'}.         (see~\ref{activationsDNN})

        \item \xmlNode{use\_bias}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
          whether the layer uses a bias vector.

        \item \xmlNode{kernel\_initializer}: \xmlDesc{string}, 
          initializer for the kernel weights matrix (see~\ref{initializersDNN}).

        \item \xmlNode{bias\_initializer}: \xmlDesc{string}, 
          initializer for the bias vector (see ~\ref{initializersDNN}).

        \item \xmlNode{kernel\_regularizer}: \xmlDesc{string}, 
          regularizer function applied to the kernel weights matrix (see ~\ref{regularizersDNN}).

        \item \xmlNode{bias\_regularizer}: \xmlDesc{string}, 
          regularizer function applied to the bias vector (see~\ref{regularizersDNN}).

        \item \xmlNode{activity\_regularizer}: \xmlDesc{string}, 
          regularizer function applied to the output         of the layer (its ``activation'').
          (see~\ref{regularizersDNN})

        \item \xmlNode{kernel\_constraint}: \xmlDesc{string}, 
          constraint function applied to the kernel weights         matrix
          (see~\ref{constraintsDNN}).

        \item \xmlNode{bias\_constraint}: \xmlDesc{string}, 
          constraint function applied to the bias vector         (see ~\ref{constraintsDNN}).

        \item \xmlNode{dim\_out}: \xmlDesc{string}, 
          dimensionality of the output space of this layer, required except if this layer is used as
          the last output layer
      \end{itemize}

    \item \xmlNode{Activation}: \xmlDesc{string}, 
      activation layer
      The \xmlNode{Activation} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{name}: \xmlDesc{string, required}, 
            name of the layer
      \end{itemize}

      The \xmlNode{Activation} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{activation}: \xmlDesc{string}, 
          including {`relu', `tanh', `elu', `selu', `softplus', `softsign', `sigmoid',
          `hard\_sigmoid', `linear', `softmax'}.         (see~\ref{activationsDNN}).
      \end{itemize}

    \item \xmlNode{Dropout}: \xmlDesc{string}, 
      The Dropout layer randomly sets input units to 0 with a frequency of rate at each step during
      training time, which helps prevent overfitting. Inputs not set to 0 are scaled up by $1/(1 -
      rate)$         such that the sum over all inputs is unchanged.
      The \xmlNode{Dropout} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{name}: \xmlDesc{string, required}, 
            the name of the layer
      \end{itemize}

      The \xmlNode{Dropout} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{rate}: \xmlDesc{float}, 
          Float between 0 and 1. Fraction of the input units to drop.

        \item \xmlNode{noise\_shape}: \xmlDesc{comma-separated integers}, 
          1D integer tensor representing the shape of the binary dropout mask that will be
          multiplied with         the input. For instance, if your inputs have shape (batch\_size,
          timesteps, features) and you want the         dropout mask to be the same for all
          timesteps, you can use noise\_shape=(batch\_size, 1, features).

        \item \xmlNode{seed}: \xmlDesc{integer}, 
          A Python integer to use as random seed.
      \end{itemize}

    \item \xmlNode{Flatten}: \xmlDesc{string}, 
      Flattens the input. Does not affect the batch size.
      The \xmlNode{Flatten} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{name}: \xmlDesc{string, required}, 
            the name of the layer
      \end{itemize}

      The \xmlNode{Flatten} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{data\_format}: \xmlDesc{string}, 
          The ordering of the dimensions in the inputs. channels\_last corresponds to inputs with
          shape         (batch, ..., channels) while channels\_first corresponds to inputs with shape
          (batch, channels, ...).
      \end{itemize}

    \item \xmlNode{Input}: \xmlDesc{string}, 
      is used to instantiate a Keras tensor.
      The \xmlNode{Input} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{name}: \xmlDesc{string, required}, 
            the name of the layer
      \end{itemize}

    \item \xmlNode{Reshape}: \xmlDesc{string}, 
      Layer that reshapes inputs into the given shape.
      The \xmlNode{Reshape} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{name}: \xmlDesc{string, required}, 
            the name of the layer
      \end{itemize}

      The \xmlNode{Reshape} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{target\_shape}: \xmlDesc{comma-separated integers}, 
          the target shape after reshapping
      \end{itemize}

    \item \xmlNode{Permute}: \xmlDesc{string}, 

      The \xmlNode{Permute} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{name}: \xmlDesc{string, required}, 
            the name of the layer
      \end{itemize}

      The \xmlNode{Permute} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{permute\_pattern}: \xmlDesc{comma-separated integers}, 
          Permutes the dimensions of the input according to a given pattern.

        \item \xmlNode{input\_shape}: \xmlDesc{comma-separated integers}, 
          the input shape
      \end{itemize}

    \item \xmlNode{RepeatVector}: \xmlDesc{string}, 
      Repeats the input n times.
      The \xmlNode{RepeatVector} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{name}: \xmlDesc{string, required}, 
            the name of the layer
      \end{itemize}

      The \xmlNode{RepeatVector} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{repetition\_factor}: \xmlDesc{integer}, 
          the number of times to repeat the input
      \end{itemize}

    \item \xmlNode{Lambda}: \xmlDesc{string}, 
      Wraps arbitrary expressions as a Layer object.
      The \xmlNode{Lambda} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{name}: \xmlDesc{string, required}, 
            the name of the layer
      \end{itemize}

      The \xmlNode{Lambda} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{function}: \xmlDesc{string}, 
          The function to be evaluated. Takes input tensor as first argument.
      \end{itemize}

    \item \xmlNode{ActivityRegularization}: \xmlDesc{string}, 
      Layer that applies an update to the cost function based input activity.
      The \xmlNode{ActivityRegularization} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{name}: \xmlDesc{string, required}, 
            the name of the layer
      \end{itemize}

      The \xmlNode{ActivityRegularization} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{l1}: \xmlDesc{float}, 
          L1 regularization factor (positive float).

        \item \xmlNode{l2}: \xmlDesc{float}, 
          L2 regularization factor (positive float).
      \end{itemize}

    \item \xmlNode{Masking}: \xmlDesc{string}, 
      Masks a sequence by using a mask value to skip timesteps.
      The \xmlNode{Masking} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{name}: \xmlDesc{string, required}, 
            the name of the layer
      \end{itemize}

      The \xmlNode{Masking} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{mask\_value}: \xmlDesc{float}, 
          For each timestep in the input tensor (dimension 1 in the tensor), if all values in the
          input         tensor at that timestep are equal to mask\_value, then the timestep will be
          masked (skipped) in all         downstream layers (as long as they support masking).
      \end{itemize}

    \item \xmlNode{SpatialDropout1D}: \xmlDesc{string}, 
      Spatial 1D version of Dropout. This version performs the same function as Dropout, however,
      it drops entire 1D feature maps instead of individual elements. If adjacent frames within
      feature         maps are strongly correlated (as is normally the case in early convolution
      layers) then regular         dropout will not regularize the activations and will otherwise
      just result in an effective learning         rate decrease. In this case, SpatialDropout1D
      will help promote independence between feature         maps and should be used instead.
      The \xmlNode{SpatialDropout1D} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{name}: \xmlDesc{string, required}, 
            the name of the layer
      \end{itemize}

      The \xmlNode{SpatialDropout1D} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{rate}: \xmlDesc{float}, 
          Float between 0 and 1. Fraction of the input units to drop.
      \end{itemize}

    \item \xmlNode{SpatialDropout2D}: \xmlDesc{string}, 
      Spatial 2D version of Dropout. This version performs the same function as Dropout, however,
      it drops entire 2D feature maps instead of individual elements. If adjacent pixels within
      feature maps         are strongly correlated (as is normally the case in early convolution
      layers) then regular dropout will         not regularize the activations and will otherwise
      just result in an effective learning rate decrease.         In this case, SpatialDropout2D
      will help promote independence between feature maps and should         be used instead.
      The \xmlNode{SpatialDropout2D} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{name}: \xmlDesc{string, required}, 
            the name of the layer
      \end{itemize}

      The \xmlNode{SpatialDropout2D} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{rate}: \xmlDesc{float}, 
          Float between 0 and 1. Fraction of the input units to drop.

        \item \xmlNode{data\_format}: \xmlDesc{[channels\_last, channels\_first]}, 
          `channels\_first' or `channels\_last'. In `channels\_first' mode, the channels dimension
          (the depth) is at index 1, in `channels\_last' mode is it at index 3.
      \end{itemize}

    \item \xmlNode{SpatialDropout3D}: \xmlDesc{string}, 
      Spatial 3D version of Dropout. This version performs the same function as Dropout, however,
      it drops entire 3D feature maps instead of individual elements. If adjacent voxels within
      feature maps         are strongly correlated (as is normally the case in early convolution
      layers) then regular dropout will         not regularize the activations and will otherwise
      just result in an effective learning rate decrease.         In this case, SpatialDropout3D
      will help promote independence between feature maps and should         be used instead.
      The \xmlNode{SpatialDropout3D} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{name}: \xmlDesc{string, required}, 
            the name of the layer
      \end{itemize}

      The \xmlNode{SpatialDropout3D} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{rate}: \xmlDesc{float}, 
          Float between 0 and 1. Fraction of the input units to drop.

        \item \xmlNode{data\_format}: \xmlDesc{[channels\_last, channels\_first]}, 
          `channels\_first' or `channels\_last'. In `channels\_first' mode, the channels dimension
          (the depth)         is at index 1, in `channels\_last' mode is it at index 4.
      \end{itemize}

    \item \xmlNode{Conv1D}: \xmlDesc{string}, 
      1D convolution layer (e.g. temporal convolution). This layer creates a convolution kernel that
      is convolved with the layer input over a single spatial (or temporal) dimension to produce a
      tensor of outputs.         If use\_bias is True, a bias vector is created and added to the
      outputs. Finally, if activation is not None,         it is applied to the outputs as well.
      The \xmlNode{Conv1D} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{name}: \xmlDesc{string, required}, 
            the name of the layer
      \end{itemize}

      The \xmlNode{Conv1D} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{dim\_out}: \xmlDesc{integer}, 
          the dimensionality of the output space (i.e. the number of output filters in the
          convolution).

        \item \xmlNode{kernel\_size}: \xmlDesc{comma-separated integers}, 
          An integer or tuple/list of a single integer, specifying the length of the 1D convolution
          window.

        \item \xmlNode{strides}: \xmlDesc{comma-separated integers}, 
          An integer or tuple/list of a single integer, specifying the stride length of the
          convolution.         Specifying any stride value != 1 is incompatible with specifying any
          dilation\_rate value != 1.

        \item \xmlNode{padding}: \xmlDesc{[valid, same]}, 
          One of ``valid'', ``same'' or ``causal'' (case-insensitive). ``valid'' means no padding.
          ``same'' results in padding with zeros evenly to the left/right or up/down of the input
          such that         output has the same height/width dimension as the input. ``causal''
          results in causal (dilated) convolutions,         e.g. output[t] does not depend on
          input[t+1:]. Useful when modeling temporal data where the model should         not violate
          the temporal order.

        \item \xmlNode{data\_format}: \xmlDesc{[channels\_last, channels\_first]}, 
          A string, one of channels\_last (default) or channels\_first

        \item \xmlNode{dilation\_rate}: \xmlDesc{comma-separated integers}, 
          an integer or tuple/list of a single integer, specifying the dilation rate to use for
          dilated         convolution. Currently, specifying any dilation\_rate value != 1 is
          incompatible with specifying any         strides value != 1.

        \item \xmlNode{activation}: \xmlDesc{string}, 
          Activation function to use. If you don't specify anything, no activation is applied

        \item \xmlNode{use\_bias}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
          whether the layer uses a bias vector.

        \item \xmlNode{kernel\_initializer}: \xmlDesc{string}, 
          initializer for the kernel weights matrix (see~\ref{initializersDNN}).

        \item \xmlNode{bias\_initializer}: \xmlDesc{string}, 
          initializer for the bias vector (see ~\ref{initializersDNN}).

        \item \xmlNode{kernel\_regularizer}: \xmlDesc{string}, 
          regularizer function applied to the kernel weights matrix (see ~\ref{regularizersDNN}).

        \item \xmlNode{bias\_regularizer}: \xmlDesc{string}, 
          regularizer function applied to the bias vector (see~\ref{regularizersDNN}).

        \item \xmlNode{activity\_regularizer}: \xmlDesc{string}, 
          egularizer function applied to the output         of the layer (its ``activation'').
          (see~\ref{regularizersDNN})

        \item \xmlNode{kernel\_constraint}: \xmlDesc{string}, 
          Constraint function applied to the kernel matrix

        \item \xmlNode{bias\_constraint}: \xmlDesc{string}, 
          Constraint function applied to the bias vector
      \end{itemize}

    \item \xmlNode{Conv2D}: \xmlDesc{string}, 
      2D convolution layer (e.g. spatial convolution over images). This layer creates a convolution
      kernel         that is convolved with the layer input to produce a tensor of outputs. If
      use\_bias is True, a bias vector         is created and added to the outputs. Finally, if
      activation is not None, it is applied to the outputs         as well.
      The \xmlNode{Conv2D} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{name}: \xmlDesc{string, required}, 
            the name of the layer
      \end{itemize}

      The \xmlNode{Conv2D} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{dim\_out}: \xmlDesc{integer}, 
          the dimensionality of the output space (i.e. the number of output filters in the
          convolution).

        \item \xmlNode{kernel\_size}: \xmlDesc{comma-separated integers}, 
          An integer or tuple/list of 2 integers, specifying the height and width of the 2D
          convolution window.         Can be a single integer to specify the same value for all
          spatial dimensions.

        \item \xmlNode{strides}: \xmlDesc{comma-separated integers}, 
          An integer or tuple/list of 2 integers, specifying the strides of the convolution along
          the height         and width. Can be a single integer to specify the same value for all
          spatial dimensions. Specifying any         stride value != 1 is incompatible with
          specifying any dilation\_rate value != 1.

        \item \xmlNode{padding}: \xmlDesc{[valid, same]}, 
          one of ``valid'' or ``same'' (case-insensitive). ``valid'' means no padding. ``same''
          results in padding         with zeros evenly to the left/right or up/down of the input
          such that output has the same height/width         dimension as the input.

        \item \xmlNode{data\_format}: \xmlDesc{[channels\_last, channels\_first]}, 
          A string, one of channels\_last (default) or channels\_first

        \item \xmlNode{dilation\_rate}: \xmlDesc{comma-separated integers}, 
          an integer or tuple/list of 2 integers, specifying the dilation rate to use for dilated
          convolution.         Can be a single integer to specify the same value for all spatial
          dimensions. Currently, specifying any         dilation\_rate value != 1 is incompatible
          with specifying any stride value != 1.

        \item \xmlNode{activation}: \xmlDesc{string}, 
          Activation function to use. If you don't specify anything, no activation is applied

        \item \xmlNode{use\_bias}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
          whether the layer uses a bias vector.

        \item \xmlNode{kernel\_initializer}: \xmlDesc{string}, 
          initializer for the kernel weights matrix (see~\ref{initializersDNN}).

        \item \xmlNode{bias\_initializer}: \xmlDesc{string}, 
          initializer for the bias vector (see ~\ref{initializersDNN}).

        \item \xmlNode{kernel\_regularizer}: \xmlDesc{string}, 
          regularizer function applied to the kernel weights matrix (see ~\ref{regularizersDNN}).

        \item \xmlNode{bias\_regularizer}: \xmlDesc{string}, 
          regularizer function applied to the bias vector (see~\ref{regularizersDNN}).

        \item \xmlNode{activity\_regularizer}: \xmlDesc{string}, 
          Regularizer function applied to the output         of the layer (its ``activation'').
          (see~\ref{regularizersDNN})

        \item \xmlNode{kernel\_constraint}: \xmlDesc{string}, 
          Constraint function applied to the kernel matrix

        \item \xmlNode{bias\_constraint}: \xmlDesc{string}, 
          Constraint function applied to the bias vector
      \end{itemize}

    \item \xmlNode{Conv3D}: \xmlDesc{string}, 
      3D convolution layer (e.g. spatial convolution over volumes). This layer creates a convolution
      kernel that is convolved with the layer input to produce a tensor of outputs. If use\_bias is
      True, a         bias vector is created and added to the outputs. Finally, if activation is not
      None, it is applied to         the outputs as well.
      The \xmlNode{Conv3D} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{name}: \xmlDesc{string, required}, 
            the name of the layer
      \end{itemize}

      The \xmlNode{Conv3D} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{dim\_out}: \xmlDesc{integer}, 
          the dimensionality of the output space (i.e. the number of output filters in the
          convolution).

        \item \xmlNode{kernel\_size}: \xmlDesc{comma-separated integers}, 
          An integer or tuple/list of 3 integers, specifying the height and width of the 2D
          convolution window.         Can be a single integer to specify the same value for all
          spatial dimensions.

        \item \xmlNode{strides}: \xmlDesc{comma-separated integers}, 
          An integer or tuple/list of 3 integers, specifying the strides of the convolution along
          the height         and width. Can be a single integer to specify the same value for all
          spatial dimensions. Specifying any         stride value != 1 is incompatible with
          specifying any dilation\_rate value != 1.

        \item \xmlNode{padding}: \xmlDesc{[valid, same]}, 
          one of ``valid'' or ``same'' (case-insensitive). ``valid'' means no padding. ``same''
          results in padding         with zeros evenly to the left/right or up/down of the input
          such that output has the same height/width         dimension as the input.

        \item \xmlNode{data\_format}: \xmlDesc{[channels\_last, channels\_first]}, 
          A string, one of channels\_last (default) or channels\_first

        \item \xmlNode{dilation\_rate}: \xmlDesc{comma-separated integers}, 
          an integer or tuple/list of 2 integers, specifying the dilation rate to use for dilated
          convolution.         Can be a single integer to specify the same value for all spatial
          dimensions. Currently, specifying any         dilation\_rate value != 1 is incompatible
          with specifying any stride value != 1.

        \item \xmlNode{activation}: \xmlDesc{string}, 
          Activation function to use. If you don't specify anything, no activation is applied

        \item \xmlNode{use\_bias}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
          whether the layer uses a bias vector.

        \item \xmlNode{kernel\_initializer}: \xmlDesc{string}, 
          initializer for the kernel weights matrix (see~\ref{initializersDNN}).

        \item \xmlNode{bias\_initializer}: \xmlDesc{string}, 
          initializer for the bias vector (see ~\ref{initializersDNN}).

        \item \xmlNode{kernel\_regularizer}: \xmlDesc{string}, 
          regularizer function applied to the kernel weights matrix (see ~\ref{regularizersDNN}).

        \item \xmlNode{bias\_regularizer}: \xmlDesc{string}, 
          regularizer function applied to the bias vector (see~\ref{regularizersDNN}).

        \item \xmlNode{activity\_regularizer}: \xmlDesc{string}, 
          regularizer function applied to the output         of the layer (its ``activation'').
          (see~\ref{regularizersDNN})

        \item \xmlNode{kernel\_constraint}: \xmlDesc{string}, 
          Constraint function applied to the kernel matrix

        \item \xmlNode{bias\_constraint}: \xmlDesc{string}, 
          Constraint function applied to the bias vector
      \end{itemize}

    \item \xmlNode{SeparableConv1D}: \xmlDesc{string}, 
      Depthwise separable 1D convolution. This layer performs a depthwise convolution that
      acts separately on channels, followed by a pointwise convolution that mixes channels. If
      use\_bias         is True and a bias initializer is provided, it adds a bias vector to the
      output. It then optionally         applies an activation function to produce the final output.
      The \xmlNode{SeparableConv1D} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{name}: \xmlDesc{string, required}, 
            the name of the layer
      \end{itemize}

      The \xmlNode{SeparableConv1D} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{dim\_out}: \xmlDesc{integer}, 
          the dimensionality of the output space (i.e. the number of output filters in the
          convolution).

        \item \xmlNode{kernel\_size}: \xmlDesc{comma-separated integers}, 
          An integer or tuple/list of a single integer, specifying the length of the 1D convolution
          window.

        \item \xmlNode{strides}: \xmlDesc{comma-separated integers}, 
          An integer or tuple/list of a single integer, specifying the stride length of the
          convolution.         Specifying any stride value != 1 is incompatible with specifying any
          dilation\_rate value != 1.

        \item \xmlNode{padding}: \xmlDesc{[valid, same]}, 
          One of ``valid'', ``same'' or ``causal'' (case-insensitive). ``valid'' means no padding.
          ``same'' results in padding with zeros evenly to the left/right or up/down of the input
          such that         output has the same height/width dimension as the input. ``causal''
          results in causal (dilated) convolutions,         e.g. output[t] does not depend on
          input[t+1:]. Useful when modeling temporal data where the model should         not violate
          the temporal order.

        \item \xmlNode{data\_format}: \xmlDesc{[channels\_last, channels\_first]}, 
          A string, one of channels\_last (default) or channels\_first

        \item \xmlNode{dilation\_rate}: \xmlDesc{comma-separated integers}, 
          an integer or tuple/list of a single integer, specifying the dilation rate to use for
          dilated         convolution. Currently, specifying any dilation\_rate value != 1 is
          incompatible with specifying any         strides value != 1.

        \item \xmlNode{activation}: \xmlDesc{string}, 
          Activation function to use. If you don't specify anything, no activation is applied

        \item \xmlNode{use\_bias}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
          whether the layer uses a bias vector.

        \item \xmlNode{kernel\_initializer}: \xmlDesc{string}, 
          initializer for the kernel weights matrix (see~\ref{initializersDNN}).

        \item \xmlNode{bias\_initializer}: \xmlDesc{string}, 
          initializer for the bias vector (see ~\ref{initializersDNN}).

        \item \xmlNode{kernel\_regularizer}: \xmlDesc{string}, 
          regularizer function applied to the kernel weights matrix (see ~\ref{regularizersDNN}).

        \item \xmlNode{bias\_regularizer}: \xmlDesc{string}, 
          regularizer function applied to the bias vector (see~\ref{regularizersDNN}).

        \item \xmlNode{activity\_regularizer}: \xmlDesc{string}, 
          regularizer function applied to the output         of the layer (its ``activation'').
          (see~\ref{regularizersDNN})

        \item \xmlNode{kernel\_constraint}: \xmlDesc{string}, 
          Constraint function applied to the kernel matrix

        \item \xmlNode{bias\_constraint}: \xmlDesc{string}, 
          Constraint function applied to the bias vector

        \item \xmlNode{depth\_multiplier}: \xmlDesc{integer}, 
          The number of depthwise convolution output channels for each input channel. The total
          number of         depthwise convolution output channels will be equal to num\_filters\_in *
          depth\_multiplier.

        \item \xmlNode{depthwise\_initializer}: \xmlDesc{string}, 
          An initializer for the depthwise convolution kernel

        \item \xmlNode{pointwise\_initializer}: \xmlDesc{string}, 
          An initializer for the pointwise convolution kernel.

        \item \xmlNode{pointwise\_regularizer}: \xmlDesc{string}, 
          Optional regularizer for the pointwise convolution kernel

        \item \xmlNode{depthwise\_regularizer}: \xmlDesc{string}, 
          Optional regularizer for the depthwise convolution kernel

        \item \xmlNode{depthwise\_constraint}: \xmlDesc{string}, 
          Optional projection function to be applied to the depthwise kernel after being updated by
          an Optimizer         (e.g. used for norm constraints or value constraints for layer
          weights). The function must take as input the         unprojected variable and must return
          the projected variable (which must have the same shape).         Constraints are not safe
          to use when doing asynchronous distributed training

        \item \xmlNode{pointwise\_constraint}: \xmlDesc{string}, 
          Optional projection function to be applied to the pointwise kernel after being updated by
          an Optimizer
      \end{itemize}

    \item \xmlNode{SeparableConv2D}: \xmlDesc{string}, 
      Depthwise separable 2D convolution. Separable convolutions consist of first performing a
      depthwise         spatial convolution (which acts on each input channel separately) followed
      by a pointwise convolution         which mixes the resulting output channels. The
      depth\_multiplier argument controls how many output channels         are generated per input
      channel in the depthwise step. Intuitively, separable convolutions can be understood
      as a way to factorize a convolution kernel into two smaller kernels, or as an extreme version
      of an         Inception block.
      The \xmlNode{SeparableConv2D} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{name}: \xmlDesc{string, required}, 
            the name of the layer
      \end{itemize}

      The \xmlNode{SeparableConv2D} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{dim\_out}: \xmlDesc{integer}, 
          the dimensionality of the output space (i.e. the number of output filters in the
          convolution).

        \item \xmlNode{kernel\_size}: \xmlDesc{comma-separated integers}, 
          An integer or tuple/list of 2 integer, specifying the length of the 1D convolution window.

        \item \xmlNode{strides}: \xmlDesc{comma-separated integers}, 
          An integer or tuple/list of 2 integer, specifying the stride length of the convolution.
          Specifying any stride value != 1 is incompatible with specifying any dilation\_rate value
          != 1.

        \item \xmlNode{padding}: \xmlDesc{[valid, same]}, 
          one of ``valid'' or ``same'' (case-insensitive). ``valid'' means no padding. ``same''
          results in padding         with zeros evenly to the left/right or up/down of the input
          such that output has the same height/width         dimension as the input.

        \item \xmlNode{data\_format}: \xmlDesc{[channels\_last, channels\_first]}, 
          A string, one of channels\_last (default) or channels\_first

        \item \xmlNode{dilation\_rate}: \xmlDesc{comma-separated integers}, 
          an integer or tuple/list of 2 integer, specifying the dilation rate to use for dilated
          convolution. Currently, specifying any dilation\_rate value != 1 is incompatible with
          specifying any         strides value != 1.

        \item \xmlNode{activation}: \xmlDesc{string}, 
          Activation function to use. If you don't specify anything, no activation is applied

        \item \xmlNode{use\_bias}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
          whether the layer uses a bias vector.

        \item \xmlNode{kernel\_initializer}: \xmlDesc{string}, 
          initializer for the kernel weights matrix (see~\ref{initializersDNN}).

        \item \xmlNode{bias\_initializer}: \xmlDesc{string}, 
          initializer for the bias vector (see ~\ref{initializersDNN}).

        \item \xmlNode{kernel\_regularizer}: \xmlDesc{string}, 
          regularizer function applied to the kernel weights matrix (see ~\ref{regularizersDNN}).

        \item \xmlNode{bias\_regularizer}: \xmlDesc{string}, 
          regularizer function applied to the bias vector (see~\ref{regularizersDNN}).

        \item \xmlNode{activity\_regularizer}: \xmlDesc{string}, 
          regularizer function applied to the output         of the layer (its ``activation'').
          (see~\ref{regularizersDNN})

        \item \xmlNode{kernel\_constraint}: \xmlDesc{string}, 
          Constraint function applied to the kernel matrix

        \item \xmlNode{bias\_constraint}: \xmlDesc{string}, 
          Constraint function applied to the bias vector

        \item \xmlNode{depth\_multiplier}: \xmlDesc{integer}, 
          The number of depthwise convolution output channels for each input channel. The total
          number of         depthwise convolution output channels will be equal to num\_filters\_in *
          depth\_multiplier.

        \item \xmlNode{depthwise\_initializer}: \xmlDesc{string}, 
          An initializer for the depthwise convolution kernel

        \item \xmlNode{pointwise\_initializer}: \xmlDesc{string}, 
          An initializer for the pointwise convolution kernel.

        \item \xmlNode{pointwise\_regularizer}: \xmlDesc{string}, 
          Optional regularizer for the pointwise convolution kernel

        \item \xmlNode{depthwise\_regularizer}: \xmlDesc{string}, 
          Optional regularizer for the depthwise convolution kernel

        \item \xmlNode{depthwise\_constraint}: \xmlDesc{string}, 
          Optional projection function to be applied to the depthwise kernel after being updated by
          an Optimizer         (e.g. used for norm constraints or value constraints for layer
          weights). The function must take as input the         unprojected variable and must return
          the projected variable (which must have the same shape).         Constraints are not safe
          to use when doing asynchronous distributed training

        \item \xmlNode{pointwise\_constraint}: \xmlDesc{string}, 
          Optional projection function to be applied to the pointwise kernel after being updated by
          an Optimizer
      \end{itemize}

    \item \xmlNode{DepthwiseConv2D}: \xmlDesc{string}, 
      Depthwise 2D convolution. Depthwise convolution is a type of convolution in which a single
      convolutional filter is apply to each input channel (i.e. in a depthwise way). You can
      understand depthwise         convolution as being the first step in a depthwise separable
      convolution.         It is implemented via the following steps:         \begin{itemize}
      \item Split the input into individual channels.           \item Convolve each input with the
      layer's kernel (called a depthwise kernel).           \item Stack the convolved outputs
      together (along the channels axis).         \end{itemize}         Unlike a regular 2D
      convolution, depthwise convolution does not mix information across different input channels.
      The depth\_multiplier argument controls how many output channels are generated per input
      channel in the         depthwise step.
      The \xmlNode{DepthwiseConv2D} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{name}: \xmlDesc{string, required}, 
            the name of the layer
      \end{itemize}

      The \xmlNode{DepthwiseConv2D} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{kernel\_size}: \xmlDesc{comma-separated integers}, 
          An integer or tuple/list of 2 integers, specifying the height and width of the 2D
          convolution window.         Can be a single integer to specify the same value for all
          spatial dimensions.

        \item \xmlNode{strides}: \xmlDesc{comma-separated integers}, 
          An integer or tuple/list of 2 integers, specifying the strides of the convolution along
          the height         and width. Can be a single integer to specify the same value for all
          spatial dimensions. Specifying any         stride value != 1 is incompatible with
          specifying any dilation\_rate value != 1.

        \item \xmlNode{padding}: \xmlDesc{[valid, same]}, 
          one of ``valid'' or ``same'' (case-insensitive). ``valid'' means no padding. ``same''
          results in padding         with zeros evenly to the left/right or up/down of the input
          such that output has the same height/width         dimension as the input.

        \item \xmlNode{data\_format}: \xmlDesc{[channels\_last, channels\_first]}, 
          A string, one of channels\_last (default) or channels\_first

        \item \xmlNode{dilation\_rate}: \xmlDesc{comma-separated integers}, 
          an integer or tuple/list of 2 integer, specifying the dilation rate to use for dilated
          convolution. Currently, specifying any dilation\_rate value != 1 is incompatible with
          specifying any         strides value != 1.

        \item \xmlNode{activation}: \xmlDesc{string}, 
          Activation function to use. If you don't specify anything, no activation is applied

        \item \xmlNode{use\_bias}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
          whether the layer uses a bias vector.

        \item \xmlNode{bias\_initializer}: \xmlDesc{string}, 
          initializer for the bias vector (see ~\ref{initializersDNN}).

        \item \xmlNode{bias\_regularizer}: \xmlDesc{string}, 
          regularizer function applied to the bias vector (see~\ref{regularizersDNN}).

        \item \xmlNode{bias\_constraint}: \xmlDesc{string}, 
          Constraint function applied to the bias vector

        \item \xmlNode{depth\_multiplier}: \xmlDesc{integer}, 
          The number of depthwise convolution output channels for each input channel. The total
          number of         depthwise convolution output channels will be equal to num\_filters\_in *
          depth\_multiplier.

        \item \xmlNode{depthwise\_initializer}: \xmlDesc{string}, 
          An initializer for the depthwise convolution kernel

        \item \xmlNode{depthwise\_regularizer}: \xmlDesc{string}, 
          Optional regularizer for the depthwise convolution kernel

        \item \xmlNode{depthwise\_constraint}: \xmlDesc{string}, 
          Optional projection function to be applied to the depthwise kernel after being updated by
          an Optimizer         (e.g. used for norm constraints or value constraints for layer
          weights). The function must take as input the         unprojected variable and must return
          the projected variable (which must have the same shape).         Constraints are not safe
          to use when doing asynchronous distributed training

        \item \xmlNode{dilation\_rate}: \xmlDesc{comma-separated integers}, 
          An integer or tuple/list of 2 integers, specifying the dilation rate to use for dilated
          convolution.         Currently, specifying any dilation\_rate value != 1 is incompatible
          with specifying any strides value != 1.
      \end{itemize}

    \item \xmlNode{Conv2DTranspose}: \xmlDesc{string}, 
      Transposed convolution layer (sometimes called Deconvolution). The need for transposed
      convolutions         generally arises from the desire to use a transformation going in the
      opposite direction of a normal         convolution, i.e., from something that has the shape of
      the output of some convolution to something that         has the shape of its input while
      maintaining a connectivity pattern that is compatible with said convolution.
      The \xmlNode{Conv2DTranspose} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{name}: \xmlDesc{string, required}, 
            the name of the layer
      \end{itemize}

      The \xmlNode{Conv2DTranspose} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{dim\_out}: \xmlDesc{integer}, 
          the dimensionality of the output space (i.e. the number of output filters in the
          convolution).

        \item \xmlNode{kernel\_size}: \xmlDesc{comma-separated integers}, 
          An integer or tuple/list of 2 integer, specifying the length of the 1D convolution window.

        \item \xmlNode{strides}: \xmlDesc{comma-separated integers}, 
          An integer or tuple/list of 2 integer, specifying the stride length of the convolution.
          Specifying any stride value != 1 is incompatible with specifying any dilation\_rate value
          != 1.

        \item \xmlNode{padding}: \xmlDesc{[valid, same]}, 
          one of ``valid'' or ``same'' (case-insensitive). ``valid'' means no padding. ``same''
          results in padding         with zeros evenly to the left/right or up/down of the input
          such that output has the same height/width         dimension as the input.

        \item \xmlNode{data\_format}: \xmlDesc{[channels\_last, channels\_first]}, 
          A string, one of channels\_last (default) or channels\_first

        \item \xmlNode{dilation\_rate}: \xmlDesc{comma-separated integers}, 
          an integer or tuple/list of 2 integer, specifying the dilation rate to use for dilated
          convolution. Currently, specifying any dilation\_rate value != 1 is incompatible with
          specifying any         strides value != 1.

        \item \xmlNode{activation}: \xmlDesc{string}, 
          Activation function to use. If you don't specify anything, no activation is applied

        \item \xmlNode{use\_bias}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
          whether the layer uses a bias vector.

        \item \xmlNode{kernel\_initializer}: \xmlDesc{string}, 
          initializer for the kernel weights matrix (see~\ref{initializersDNN}).

        \item \xmlNode{bias\_initializer}: \xmlDesc{string}, 
          initializer for the bias vector (see ~\ref{initializersDNN}).

        \item \xmlNode{kernel\_regularizer}: \xmlDesc{string}, 
          regularizer function applied to the kernel weights matrix (see ~\ref{regularizersDNN}).

        \item \xmlNode{bias\_regularizer}: \xmlDesc{string}, 
          regularizer function applied to the bias vector (see~\ref{regularizersDNN}).

        \item \xmlNode{activity\_regularizer}: \xmlDesc{string}, 
          regularizer function applied to the output         of the layer (its ``activation'').
          (see~\ref{regularizersDNN})

        \item \xmlNode{kernel\_constraint}: \xmlDesc{string}, 
          Constraint function applied to the kernel matrix

        \item \xmlNode{bias\_constraint}: \xmlDesc{string}, 
          Constraint function applied to the bias vector

        \item \xmlNode{output\_padding}: \xmlDesc{comma-separated integers}, 
          An integer or tuple/list of 2 integers, specifying the amount of padding along the height
          and         width of the output tensor. Can be a single integer to specify the same value
          for all spatial dimensions.         The amount of output padding along a given dimension
          must be lower than the stride along that same dimension.
      \end{itemize}

    \item \xmlNode{Conv3DTranspose}: \xmlDesc{string}, 

      The \xmlNode{Conv3DTranspose} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{name}: \xmlDesc{string, required}, 
            the name of the layer
      \end{itemize}

      The \xmlNode{Conv3DTranspose} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{dim\_out}: \xmlDesc{integer}, 
          the dimensionality of the output space (i.e. the number of output filters in the
          convolution).

        \item \xmlNode{kernel\_size}: \xmlDesc{comma-separated integers}, 
          An integer or tuple/list of 3 integer, specifying the length of the 1D convolution window.

        \item \xmlNode{strides}: \xmlDesc{comma-separated integers}, 
          An integer or tuple/list of 3 integer, specifying the stride length of the convolution.
          Specifying any stride value != 1 is incompatible with specifying any dilation\_rate value
          != 1.

        \item \xmlNode{padding}: \xmlDesc{[valid, same]}, 
          one of ``valid'' or ``same'' (case-insensitive). ``valid'' means no padding. ``same''
          results in padding         with zeros evenly to the left/right or up/down of the input
          such that output has the same height/width         dimension as the input.

        \item \xmlNode{data\_format}: \xmlDesc{[channels\_last, channels\_first]}, 
          A string, one of channels\_last (default) or channels\_first

        \item \xmlNode{dilation\_rate}: \xmlDesc{comma-separated integers}, 
          an integer or tuple/list of 3 integer, specifying the dilation rate to use for dilated
          convolution. Currently, specifying any dilation\_rate value != 1 is incompatible with
          specifying any         strides value != 1.

        \item \xmlNode{activation}: \xmlDesc{string}, 
          Activation function to use. If you don't specify anything, no activation is applied

        \item \xmlNode{use\_bias}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
          whether the layer uses a bias vector.

        \item \xmlNode{kernel\_initializer}: \xmlDesc{string}, 
          initializer for the kernel weights matrix (see~\ref{initializersDNN}).

        \item \xmlNode{bias\_initializer}: \xmlDesc{string}, 
          initializer for the bias vector (see ~\ref{initializersDNN}).

        \item \xmlNode{kernel\_regularizer}: \xmlDesc{string}, 
          regularizer function applied to the kernel weights matrix (see ~\ref{regularizersDNN}).

        \item \xmlNode{bias\_regularizer}: \xmlDesc{string}, 
          regularizer function applied to the bias vector (see~\ref{regularizersDNN}).

        \item \xmlNode{activity\_regularizer}: \xmlDesc{string}, 
          regularizer function applied to the output         of the layer (its ``activation'').
          (see~\ref{regularizersDNN})

        \item \xmlNode{kernel\_constraint}: \xmlDesc{string}, 
          Constraint function applied to the kernel matrix

        \item \xmlNode{bias\_constraint}: \xmlDesc{string}, 
          Constraint function applied to the bias vector

        \item \xmlNode{output\_padding}: \xmlDesc{comma-separated integers}, 
          An integer or tuple/list of 2 integers, specifying the amount of padding along the height
          and         width of the output tensor. Can be a single integer to specify the same value
          for all spatial dimensions.         The amount of output padding along a given dimension
          must be lower than the stride along that same dimension.
      \end{itemize}

    \item \xmlNode{Cropping1D}: \xmlDesc{string}, 
      Cropping layer for 1D input (e.g. temporal sequence).
      The \xmlNode{Cropping1D} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{name}: \xmlDesc{string, required}, 
            the name of the layer
      \end{itemize}

      The \xmlNode{Cropping1D} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{cropping}: \xmlDesc{comma-separated integers}, 
          Int or tuple of int (length 2) How many units should be trimmed off at the beginning and
          end of the         cropping dimension (axis 1). If a single int is provided, the same
          value will be used for both.
      \end{itemize}

    \item \xmlNode{Cropping2D}: \xmlDesc{string}, 
      Cropping layer for 2D input (e.g. picture).
      The \xmlNode{Cropping2D} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{name}: \xmlDesc{string, required}, 
            the name of the layer
      \end{itemize}

      The \xmlNode{Cropping2D} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{cropping}: \xmlDesc{comma-separated integers}, 
          Int, or tuple of 2 ints, or tuple of 2 tuples of 2 ints.         \begin{itemize}
          \item If int: the same symmetric cropping is applied to height and width.           \item
          If tuple of 2 ints: interpreted as two different symmetric cropping values for height and
          width:             (symmetric\_height\_crop, symmetric\_width\_crop).           \item If
          tuple of 2 tuples of 2 ints: interpreted as ((top\_crop, bottom\_crop), (left\_crop,
          right\_crop))         \end{itemize}

        \item \xmlNode{data\_format}: \xmlDesc{[channels\_last, channels\_first]}, 
          A string, one of channels\_last (default) or channels\_first.
      \end{itemize}

    \item \xmlNode{Cropping3D}: \xmlDesc{string}, 
      Cropping layer for 3D data (e.g. spatial or spatio-temporal).
      The \xmlNode{Cropping3D} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{name}: \xmlDesc{string, required}, 
            the name of the layer
      \end{itemize}

      The \xmlNode{Cropping3D} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{cropping}: \xmlDesc{comma-separated integers}, 
          Int, or tuple of 3 ints, or tuple of 3 tuples of 3 ints.         \begin{itemize}
          \item If int: the same symmetric cropping is applied to height and width.           \item
          If tuple of 3 ints: interpreted as two different symmetric cropping values for depth,
          height and width:             (symmetric\_dim1\_crop, symmetric\_dim2\_crop,
          symmetric\_dim3\_crop).           \item If tuple of 3 tuples of 2 ints: interpreted as
          ((top\_crop, bottom\_crop), (left\_crop, right\_crop))         \end{itemize}

        \item \xmlNode{data\_format}: \xmlDesc{[channels\_last, channels\_first]}, 
          A string, one of channels\_last (default) or channels\_first.
      \end{itemize}

    \item \xmlNode{Upsampling1D}: \xmlDesc{string}, 
      Upsampling layer for 1D inputs.
      The \xmlNode{Upsampling1D} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{name}: \xmlDesc{string, required}, 
            the name of the layer
      \end{itemize}

      The \xmlNode{Upsampling1D} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{size}: \xmlDesc{integer}, 
          Upsampling factor.
      \end{itemize}

    \item \xmlNode{UpSampling2D}: \xmlDesc{string}, 
      Upsampling layer for 2D inputs.
      The \xmlNode{UpSampling2D} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{name}: \xmlDesc{string, required}, 
            the name of the layer
      \end{itemize}

      The \xmlNode{UpSampling2D} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{size}: \xmlDesc{comma-separated integers}, 
          Upsampling factor.

        \item \xmlNode{data\_format}: \xmlDesc{[channels\_last, channels\_first]}, 
          A string, one of channels\_last (default) or channels\_first.

        \item \xmlNode{interpolation}: \xmlDesc{[nearest, bilinear]}, 
          A string, one of nearest or bilinear.
      \end{itemize}

    \item \xmlNode{UpSampling3D}: \xmlDesc{string}, 
      Upsampling layer for 3D inputs.
      The \xmlNode{UpSampling3D} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{name}: \xmlDesc{string, required}, 
            the name of the layer
      \end{itemize}

      The \xmlNode{UpSampling3D} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{size}: \xmlDesc{comma-separated integers}, 
          Int, or tuple of 3 integers. The upsampling factors for dim1, dim2 and dim3.

        \item \xmlNode{data\_format}: \xmlDesc{[channels\_last, channels\_first]}, 
          A string, one of channels\_last (default) or channels\_first.
      \end{itemize}

    \item \xmlNode{ZeroPadding1D}: \xmlDesc{string}, 
      Zero-padding layer for 1D input (e.g. temporal sequence).
      The \xmlNode{ZeroPadding1D} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{name}: \xmlDesc{string, required}, 
            the name of the layer
      \end{itemize}

      The \xmlNode{ZeroPadding1D} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{padding}: \xmlDesc{comma-separated integers}, 
          Int, or tuple of int (length 2), or dictionary. - If int: How many zeros to add at the
          beginning         and end of the padding dimension (axis 1). - If tuple of int (length 2):
          How many zeros to add at the beginning         and the end of the padding dimension
      \end{itemize}

    \item \xmlNode{ZeroPadding2D}: \xmlDesc{string}, 
      Zero-padding layer for 2D input (e.g. picture).
      The \xmlNode{ZeroPadding2D} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{name}: \xmlDesc{string, required}, 
            the name of the layer
      \end{itemize}

      The \xmlNode{ZeroPadding2D} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{padding}: \xmlDesc{comma-separated integers}, 
          Int, or tuple of 2 ints, or tuple of 2 tuples of 2 ints.         \begin{itemize}
          \item If int: the same symmetric padding is applied to height and width.           \item
          If tuple of 2 ints: interpreted as two different symmetric padding values for height and
          width:           (symmetric\_height\_pad, symmetric\_width\_pad).           \item If tuple
          of 2 tuples of 2 ints: interpreted as ((top\_pad, bottom\_pad), (left\_pad, right\_pad))
          \end{itemize}

        \item \xmlNode{data\_format}: \xmlDesc{[channels\_last, channels\_first]}, 
          A string, one of channels\_last (default) or channels\_first.
      \end{itemize}

    \item \xmlNode{ZeroPadding3D}: \xmlDesc{string}, 
      Zero-padding layer for 3D data (spatial or spatio-temporal).
      The \xmlNode{ZeroPadding3D} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{name}: \xmlDesc{string, required}, 
            the name of the layer
      \end{itemize}

      The \xmlNode{ZeroPadding3D} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{padding}: \xmlDesc{comma-separated integers}, 
          Int, or tuple of 3 ints, or tuple of 3 tuples of 2 ints.         \begin{itemize}
          \item If int: the same symmetric padding is applied to height and width.           \item
          If tuple of 3 ints: interpreted as two different symmetric padding values for height and
          width:           (symmetric\_dim1\_pad, symmetric\_dim2\_pad, symmetric\_dim3\_pad).
          \item If tuple of 3 tuples of 2 ints: interpreted as ((left\_dim1\_pad, right\_dim1\_pad),
          (left\_dim2\_pad, right\_dim2\_pad), (left\_dim3\_pad, right\_dim3\_pad))
          \end{itemize}

        \item \xmlNode{data\_format}: \xmlDesc{[channels\_last, channels\_first]}, 
          A string, one of channels\_last (default) or channels\_first.
      \end{itemize}

    \item \xmlNode{MaxPooling1D}: \xmlDesc{string}, 
      Max pooling operation for 1D temporal data.
      The \xmlNode{MaxPooling1D} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{name}: \xmlDesc{string, required}, 
            the name of the layer
      \end{itemize}

      The \xmlNode{MaxPooling1D} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{pool\_size}: \xmlDesc{integer}, 
          size of the max pooling window.

        \item \xmlNode{strides}: \xmlDesc{integer}, 
          Specifies how much the pooling window moves for each pooling step.

        \item \xmlNode{padding}: \xmlDesc{[valid, same]}, 
          one of ``valid'' or ``same'' (case-insensitive). ``valid'' means no padding. ``same''
          results in padding         with zeros evenly to the left/right or up/down of the input
          such that output has the same height/width         dimension as the input.

        \item \xmlNode{data\_format}: \xmlDesc{[channels\_last, channels\_first]}, 
          A string, one of channels\_last (default) or channels\_first.
      \end{itemize}

    \item \xmlNode{MaxPooling2D}: \xmlDesc{string}, 
      Max pooling operation for 2D spatial data.
      The \xmlNode{MaxPooling2D} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{name}: \xmlDesc{string, required}, 
            the name of the layer
      \end{itemize}

      The \xmlNode{MaxPooling2D} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{pool\_size}: \xmlDesc{comma-separated integers}, 
          integer or tuple of 2 integers, window size over which to take the maximum. (2, 2) will
          take the max         value over a 2x2 pooling window. If only one integer is specified,
          the same window length will be used for         both dimensions.

        \item \xmlNode{strides}: \xmlDesc{comma-separated integers}, 
          Integer, tuple of 2 integers, or None. Strides values. Specifies how far the pooling
          window moves         for each pooling step. If None, it will default to pool\_size.

        \item \xmlNode{padding}: \xmlDesc{[valid, same]}, 
          one of ``valid'' or ``same'' (case-insensitive). ``valid'' means no padding. ``same''
          results in padding         with zeros evenly to the left/right or up/down of the input
          such that output has the same height/width         dimension as the input.

        \item \xmlNode{data\_format}: \xmlDesc{[channels\_last, channels\_first]}, 
          A string, one of channels\_last (default) or channels\_first.
      \end{itemize}

    \item \xmlNode{MaxPooling3D}: \xmlDesc{string}, 
      Max pooling operation for 3D data (spatial or spatio-temporal).
      The \xmlNode{MaxPooling3D} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{name}: \xmlDesc{string, required}, 
            the name of the layer
      \end{itemize}

      The \xmlNode{MaxPooling3D} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{pool\_size}: \xmlDesc{comma-separated integers}, 
          Tuple of 3 integers, factors by which to downscale (dim1, dim2, dim3). (2, 2, 2) will
          halve the         size of the 3D input in each dimension.

        \item \xmlNode{strides}: \xmlDesc{comma-separated integers}, 
          tuple of 3 integers, or None. Strides values.

        \item \xmlNode{padding}: \xmlDesc{[valid, same]}, 
          one of ``valid'' or ``same'' (case-insensitive). ``valid'' means no padding. ``same''
          results in padding         with zeros evenly to the left/right or up/down of the input
          such that output has the same height/width         dimension as the input.

        \item \xmlNode{data\_format}: \xmlDesc{[channels\_last, channels\_first]}, 
          A string, one of channels\_last (default) or channels\_first.
      \end{itemize}

    \item \xmlNode{AveragePooling1D}: \xmlDesc{string}, 
      Average pooling for temporal data.
      The \xmlNode{AveragePooling1D} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{name}: \xmlDesc{string, required}, 
            the name of the layer
      \end{itemize}

      The \xmlNode{AveragePooling1D} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{pool\_size}: \xmlDesc{integer}, 
          size of the average pooling windows.

        \item \xmlNode{strides}: \xmlDesc{integer}, 
          Factor by which to downscale.

        \item \xmlNode{padding}: \xmlDesc{[valid, same]}, 
          one of ``valid'' or ``same'' (case-insensitive). ``valid'' means no padding. ``same''
          results in padding         with zeros evenly to the left/right or up/down of the input
          such that output has the same height/width         dimension as the input.

        \item \xmlNode{data\_format}: \xmlDesc{[channels\_last, channels\_first]}, 
          A string, one of channels\_last (default) or channels\_first.
      \end{itemize}

    \item \xmlNode{AveragePooling2D}: \xmlDesc{string}, 
      Average pooling operation for spatial data.
      The \xmlNode{AveragePooling2D} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{name}: \xmlDesc{string, required}, 
            the name of the layer
      \end{itemize}

      The \xmlNode{AveragePooling2D} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{pool\_size}: \xmlDesc{comma-separated integers}, 
          integer or tuple of 2 integers, factors by which to downscale (vertical, horizontal). (2,
          2) will         halve the input in both spatial dimension. If only one integer is
          specified, the same window length will         be used for both dimensions.

        \item \xmlNode{strides}: \xmlDesc{comma-separated integers}, 
          Integer, tuple of 2 integers, or None. Strides values. If None, it will default to
          pool\_size.

        \item \xmlNode{padding}: \xmlDesc{[valid, same]}, 
          one of ``valid'' or ``same'' (case-insensitive). ``valid'' means no padding. ``same''
          results in padding         with zeros evenly to the left/right or up/down of the input
          such that output has the same height/width         dimension as the input.

        \item \xmlNode{data\_format}: \xmlDesc{[channels\_last, channels\_first]}, 
          A string, one of channels\_last (default) or channels\_first.
      \end{itemize}

    \item \xmlNode{AveragePooling3D}: \xmlDesc{string}, 
      Average pooling operation for 3D data (spatial or spatio-temporal).
      The \xmlNode{AveragePooling3D} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{name}: \xmlDesc{string, required}, 
            the name of the layer
      \end{itemize}

      The \xmlNode{AveragePooling3D} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{pool\_size}: \xmlDesc{comma-separated integers}, 
          tuple of 3 integers, factors by which to downscale (dim1, dim2, dim3). (2, 2, 2) will
          halve the size         of the 3D input in each dimension.

        \item \xmlNode{strides}: \xmlDesc{comma-separated integers}, 
          tuple of 3 integers, or None. Strides values.

        \item \xmlNode{padding}: \xmlDesc{[valid, same]}, 
          one of ``valid'' or ``same'' (case-insensitive). ``valid'' means no padding. ``same''
          results in padding         with zeros evenly to the left/right or up/down of the input
          such that output has the same height/width         dimension as the input.

        \item \xmlNode{data\_format}: \xmlDesc{[channels\_last, channels\_first]}, 
          A string, one of channels\_last (default) or channels\_first.
      \end{itemize}

    \item \xmlNode{GlobalMaxPooling1D}: \xmlDesc{string}, 
      Global max pooling operation for 1D temporal data.
      The \xmlNode{GlobalMaxPooling1D} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{name}: \xmlDesc{string, required}, 
            the name of the layer
      \end{itemize}

      The \xmlNode{GlobalMaxPooling1D} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{data\_format}: \xmlDesc{[channels\_last, channels\_first]}, 
          A string, one of channels\_last (default) or channels\_first.
      \end{itemize}

    \item \xmlNode{GlobalAveragePooling1D}: \xmlDesc{string}, 
      Global average pooling operation for temporal data.
      The \xmlNode{GlobalAveragePooling1D} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{name}: \xmlDesc{string, required}, 
            the name of the layer
      \end{itemize}

      The \xmlNode{GlobalAveragePooling1D} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{data\_format}: \xmlDesc{[channels\_last, channels\_first]}, 
          A string, one of channels\_last (default) or channels\_first.
      \end{itemize}

    \item \xmlNode{GlobalMaxPooling2D}: \xmlDesc{string}, 
      Global max pooling operation for spatial data.
      The \xmlNode{GlobalMaxPooling2D} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{name}: \xmlDesc{string, required}, 
            the name of the layer
      \end{itemize}

      The \xmlNode{GlobalMaxPooling2D} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{data\_format}: \xmlDesc{[channels\_last, channels\_first]}, 
          A string, one of channels\_last (default) or channels\_first.
      \end{itemize}

    \item \xmlNode{GlobalAveragePooling2D}: \xmlDesc{string}, 
      Global average pooling operation for spatial data.
      The \xmlNode{GlobalAveragePooling2D} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{name}: \xmlDesc{string, required}, 
            the name of the layer
      \end{itemize}

      The \xmlNode{GlobalAveragePooling2D} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{data\_format}: \xmlDesc{[channels\_last, channels\_first]}, 
          A string, one of channels\_last (default) or channels\_first.
      \end{itemize}

    \item \xmlNode{GlobalMaxPooling3D}: \xmlDesc{string}, 
      Global Max pooling operation for 3D data.
      The \xmlNode{GlobalMaxPooling3D} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{name}: \xmlDesc{string, required}, 
            the name of the layer
      \end{itemize}

      The \xmlNode{GlobalMaxPooling3D} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{data\_format}: \xmlDesc{[channels\_last, channels\_first]}, 
          A string, one of channels\_last (default) or channels\_first.
      \end{itemize}

    \item \xmlNode{GlobalAveragePooling3D}: \xmlDesc{string}, 
      Global Average pooling operation for 3D data.
      The \xmlNode{GlobalAveragePooling3D} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{name}: \xmlDesc{string, required}, 
            the name of the layer
      \end{itemize}

      The \xmlNode{GlobalAveragePooling3D} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{data\_format}: \xmlDesc{[channels\_last, channels\_first]}, 
          A string, one of channels\_last (default) or channels\_first.
      \end{itemize}

    \item \xmlNode{LocallyConnected1D}: \xmlDesc{string}, 
      Locally-connected layer for 1D inputs.
      The \xmlNode{LocallyConnected1D} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{name}: \xmlDesc{string, required}, 
            the name of the layer
      \end{itemize}

      The \xmlNode{LocallyConnected1D} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{dim\_out}: \xmlDesc{integer}, 
          dimensionality of the output space of this layer

        \item \xmlNode{kernel\_size}: \xmlDesc{comma-separated integers}, 
          An integer or tuple/list of a single integer, specifying the length of the 1D convolution
          window.

        \item \xmlNode{strides}: \xmlDesc{comma-separated integers}, 
          An integer or tuple/list of a single integer, specifying the stride length of the
          convolution.

        \item \xmlNode{padding}: \xmlDesc{[valid, same]}, 
          Currently only supports ``valid'' (case-insensitive). ``same'' may be supported in the
          future.         ``valid'' means no padding.

        \item \xmlNode{activation}: \xmlDesc{string}, 
          Activation function to use. If you don't specify anything, no activation is applied (ie.
          ``linear''         activation: $a(x) = x)$.

        \item \xmlNode{use\_bias}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
          whether the layer uses a bias vector.

        \item \xmlNode{kernel\_initializer}: \xmlDesc{string}, 
          initializer for the kernel weights matrix (see~\ref{initializersDNN}).

        \item \xmlNode{bias\_initializer}: \xmlDesc{string}, 
          initializer for the bias vector (see ~\ref{initializersDNN}).

        \item \xmlNode{kernel\_regularizer}: \xmlDesc{string}, 
          regularizer function applied to the kernel weights matrix (see ~\ref{regularizersDNN}).

        \item \xmlNode{bias\_regularizer}: \xmlDesc{string}, 
          regularizer function applied to the bias vector (see~\ref{regularizersDNN}).

        \item \xmlNode{activity\_regularizer}: \xmlDesc{string}, 
          regularizer function applied to the output         of the layer (its ``activation'').
          (see~\ref{regularizersDNN})

        \item \xmlNode{kernel\_constraint}: \xmlDesc{string}, 
          constraint function applied to the kernel weights matrix (see~\ref{constraintsDNN}).

        \item \xmlNode{bias\_constraint}: \xmlDesc{string}, 
          constraint function applied to the bias vector (see ~\ref{constraintsDNN})
      \end{itemize}

    \item \xmlNode{LocallyConnected2D}: \xmlDesc{string}, 
      Locally-connected layer for 2D inputs.
      The \xmlNode{LocallyConnected2D} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{name}: \xmlDesc{string, required}, 
            the name of the layer
      \end{itemize}

      The \xmlNode{LocallyConnected2D} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{dim\_out}: \xmlDesc{integer}, 
          dimensionality of the output space of this layer

        \item \xmlNode{kernel\_size}: \xmlDesc{comma-separated integers}, 
          An integer or tuple/list of 2 integers, specifying the width and height of the 2D
          convolution window.         Can be a single integer to specify the same value for all
          spatial dimensions.

        \item \xmlNode{strides}: \xmlDesc{comma-separated integers}, 
          An integer or tuple/list of 2 integers, specifying the strides of the convolution along
          the width and         height. Can be a single integer to specify the same value for all
          spatial dimensions.

        \item \xmlNode{padding}: \xmlDesc{[valid, same]}, 
          Currently only support ``valid'' (case-insensitive).

        \item \xmlNode{data\_format}: \xmlDesc{[channels\_last, channels\_first]}, 
          A string, one of channels\_last (default) or channels\_first.

        \item \xmlNode{activation}: \xmlDesc{string}, 
          Activation function to use. If you don't specify anything, no activation is applied (ie.
          ``linear''         activation: $a(x) = x)$.

        \item \xmlNode{use\_bias}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
          whether the layer uses a bias vector.

        \item \xmlNode{kernel\_initializer}: \xmlDesc{string}, 
          initializer for the kernel weights matrix (see~\ref{initializersDNN}).

        \item \xmlNode{bias\_initializer}: \xmlDesc{string}, 
          initializer for the bias vector (see ~\ref{initializersDNN}).

        \item \xmlNode{kernel\_regularizer}: \xmlDesc{string}, 
          regularizer function applied to the kernel weights matrix (see ~\ref{regularizersDNN}).

        \item \xmlNode{bias\_regularizer}: \xmlDesc{string}, 
          regularizer function applied to the bias vector (see~\ref{regularizersDNN}).

        \item \xmlNode{activity\_regularizer}: \xmlDesc{string}, 
          regularizer function applied to the output         of the layer (its ``activation'').
          (see~\ref{regularizersDNN})

        \item \xmlNode{kernel\_constraint}: \xmlDesc{string}, 
          constraint function applied to the kernel weights matrix (see~\ref{constraintsDNN}).

        \item \xmlNode{bias\_constraint}: \xmlDesc{string}, 
          constraint function applied to the bias vector (see ~\ref{constraintsDNN})
      \end{itemize}

    \item \xmlNode{RNN}: \xmlDesc{string}, 
      Fully-connected RNN where the output is to be fed back to input.
      The \xmlNode{RNN} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{name}: \xmlDesc{string, required}, 
            the name of the layer
      \end{itemize}

      The \xmlNode{RNN} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{dim\_out}: \xmlDesc{integer}, 
          dimensionality of the output space of this layer

        \item \xmlNode{return\_sequences}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
          Whether to return the last output in the output sequence, or the full sequence.

        \item \xmlNode{return\_state}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
          Whether to return the last state in addition to the output.

        \item \xmlNode{go\_backwards}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
          If True, process the input sequence backwards and return the reversed sequence.

        \item \xmlNode{stateful}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
          If True, the last state for each sample at index i in a batch will be used as initial
          state for the         sample of index i in the following batch.

        \item \xmlNode{unroll}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
          If True, the network will be unrolled, else a symbolic loop will be used. Unrolling can
          speed-up a         RNN, although it tends to be more memory-intensive. Unrolling is only
          suitable for short sequences.
      \end{itemize}

    \item \xmlNode{SimpleRNN}: \xmlDesc{string}, 
      Fully-connected RNN where the output is to be fed back to input.
      The \xmlNode{SimpleRNN} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{name}: \xmlDesc{string, required}, 
            the name of the layer
      \end{itemize}

      The \xmlNode{SimpleRNN} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{dim\_out}: \xmlDesc{integer}, 
          dimensionality of the output space of this layer

        \item \xmlNode{activation}: \xmlDesc{string}, 
          Activation function to use. If you don't specify anything, no activation is applied (ie.
          ``linear''         activation: $a(x) = x)$.

        \item \xmlNode{use\_bias}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
          whether the layer uses a bias vector.

        \item \xmlNode{kernel\_initializer}: \xmlDesc{string}, 
          initializer for the kernel weights matrix (see~\ref{initializersDNN}).

        \item \xmlNode{recurrent\_initializer}: \xmlDesc{string}, 
          Initializer for the recurrent\_kernel weights matrix, used for the linear transformation
          of the         recurrent state (see~\ref{initializersDNN}).

        \item \xmlNode{bias\_initializer}: \xmlDesc{string}, 
          initializer for the bias vector (see ~\ref{initializersDNN}).

        \item \xmlNode{kernel\_regularizer}: \xmlDesc{string}, 
          regularizer function applied to the kernel weights matrix (see ~\ref{regularizersDNN}).

        \item \xmlNode{recurrent\_regularizer}: \xmlDesc{string}, 
          Regularizer function applied to the recurrent\_kernel weights matrix(see
          ~\ref{regularizersDNN}).

        \item \xmlNode{bias\_regularizer}: \xmlDesc{string}, 
          regularizer function applied to the bias vector (see~\ref{regularizersDNN}).

        \item \xmlNode{activity\_regularizer}: \xmlDesc{string}, 
          regularizer function applied to the output         of the layer (its ``activation'').
          (see~\ref{regularizersDNN})

        \item \xmlNode{kernel\_constraint}: \xmlDesc{string}, 
          constraint function applied to the kernel weights matrix (see~\ref{constraintsDNN}).

        \item \xmlNode{recurrent\_constraint}: \xmlDesc{string}, 
          Constraint function applied to the recurrent\_kernel weights
          matrix(see~\ref{constraintsDNN}).

        \item \xmlNode{bias\_constraint}: \xmlDesc{string}, 
          constraint function applied to the bias vector (see ~\ref{constraintsDNN})

        \item \xmlNode{dropout}: \xmlDesc{float}, 
          Float between 0 and 1. Fraction of the units to drop for the linear transformation of the
          inputs.

        \item \xmlNode{recurrent\_dropout}: \xmlDesc{float}, 
          Float between 0 and 1. Fraction of the units to drop for the linear transformation of the
          recurrent state.

        \item \xmlNode{return\_sequences}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
          Whether to return the last output in the output sequence, or the full sequence.

        \item \xmlNode{return\_state}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
          Whether to return the last state in addition to the output.

        \item \xmlNode{go\_backwards}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
          If True, process the input sequence backwards and return the reversed sequence.

        \item \xmlNode{stateful}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
          If True, the last state for each sample at index i in a batch will be used as initial
          state for the         sample of index i in the following batch.

        \item \xmlNode{unroll}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
          If True, the network will be unrolled, else a symbolic loop will be used. Unrolling can
          speed-up a         RNN, although it tends to be more memory-intensive. Unrolling is only
          suitable for short sequences.
      \end{itemize}

    \item \xmlNode{GRU}: \xmlDesc{string}, 
      Gated Recurrent Unit.
      The \xmlNode{GRU} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{name}: \xmlDesc{string, required}, 
            the name of the layer
      \end{itemize}

      The \xmlNode{GRU} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{dim\_out}: \xmlDesc{integer}, 
          dimensionality of the output space of this layer

        \item \xmlNode{activation}: \xmlDesc{string}, 
          Activation function to use. If you don't specify anything, no activation is applied (ie.
          ``linear''         activation: $a(x) = x)$.

        \item \xmlNode{recurrent\_activation}: \xmlDesc{string}, 
          Activation function to use for the recurrent step.

        \item \xmlNode{use\_bias}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
          whether the layer uses a bias vector.

        \item \xmlNode{kernel\_initializer}: \xmlDesc{string}, 
          initializer for the kernel weights matrix (see~\ref{initializersDNN}).

        \item \xmlNode{recurrent\_initializer}: \xmlDesc{string}, 
          Initializer for the recurrent\_kernel weights matrix, used for the linear transformation
          of the         recurrent state (see~\ref{initializersDNN}).

        \item \xmlNode{bias\_initializer}: \xmlDesc{string}, 
          initializer for the bias vector (see ~\ref{initializersDNN}).

        \item \xmlNode{kernel\_regularizer}: \xmlDesc{string}, 
          regularizer function applied to the kernel weights matrix (see ~\ref{regularizersDNN}).

        \item \xmlNode{recurrent\_regularizer}: \xmlDesc{string}, 
          Regularizer function applied to the recurrent\_kernel weights matrix(see
          ~\ref{regularizersDNN}).

        \item \xmlNode{bias\_regularizer}: \xmlDesc{string}, 
          regularizer function applied to the bias vector (see~\ref{regularizersDNN}).

        \item \xmlNode{activity\_regularizer}: \xmlDesc{string}, 
          regularizer function applied to the output         of the layer (its ``activation'').
          (see~\ref{regularizersDNN})

        \item \xmlNode{kernel\_constraint}: \xmlDesc{string}, 
          constraint function applied to the kernel weights matrix (see~\ref{constraintsDNN}).

        \item \xmlNode{recurrent\_constraint}: \xmlDesc{string}, 
          Constraint function applied to the recurrent\_kernel weights
          matrix(see~\ref{constraintsDNN}).

        \item \xmlNode{bias\_constraint}: \xmlDesc{string}, 
          constraint function applied to the bias vector (see ~\ref{constraintsDNN})

        \item \xmlNode{dropout}: \xmlDesc{float}, 
          Float between 0 and 1. Fraction of the units to drop for the linear transformation of the
          inputs.

        \item \xmlNode{recurrent\_dropout}: \xmlDesc{float}, 
          Float between 0 and 1. Fraction of the units to drop for the linear transformation of the
          recurrent state.

        \item \xmlNode{return\_sequences}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
          Whether to return the last output in the output sequence, or the full sequence.

        \item \xmlNode{return\_state}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
          Whether to return the last state in addition to the output.

        \item \xmlNode{go\_backwards}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
          If True, process the input sequence backwards and return the reversed sequence.

        \item \xmlNode{stateful}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
          If True, the last state for each sample at index i in a batch will be used as initial
          state for the         sample of index i in the following batch.

        \item \xmlNode{unroll}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
          If True, the network will be unrolled, else a symbolic loop will be used. Unrolling can
          speed-up a         RNN, although it tends to be more memory-intensive. Unrolling is only
          suitable for short sequences.

        \item \xmlNode{reset\_after}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
          GRU convention (whether to apply reset gate after or before matrix multiplication).
          False = ``before'', True = ``after'' (default and CuDNN compatible).
      \end{itemize}

    \item \xmlNode{LSTM}: \xmlDesc{string}, 
      Long Short-Term Memory layer
      The \xmlNode{LSTM} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{name}: \xmlDesc{string, required}, 
            the name of the layer
      \end{itemize}

      The \xmlNode{LSTM} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{dim\_out}: \xmlDesc{integer}, 
          dimensionality of the output space of this layer

        \item \xmlNode{activation}: \xmlDesc{string}, 
          Activation function to use. If you don't specify anything, no activation is applied (ie.
          ``linear''         activation: $a(x) = x)$.

        \item \xmlNode{recurrent\_activation}: \xmlDesc{string}, 
          Activation function to use for the recurrent step.

        \item \xmlNode{use\_bias}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
          whether the layer uses a bias vector.

        \item \xmlNode{kernel\_initializer}: \xmlDesc{string}, 
          initializer for the kernel weights matrix (see~\ref{initializersDNN}).

        \item \xmlNode{recurrent\_initializer}: \xmlDesc{string}, 
          Initializer for the recurrent\_kernel weights matrix, used for the linear transformation
          of the         recurrent state (see~\ref{initializersDNN}).

        \item \xmlNode{bias\_initializer}: \xmlDesc{string}, 
          initializer for the bias vector (see ~\ref{initializersDNN}).

        \item \xmlNode{kernel\_regularizer}: \xmlDesc{string}, 
          regularizer function applied to the kernel weights matrix (see ~\ref{regularizersDNN}).

        \item \xmlNode{recurrent\_regularizer}: \xmlDesc{string}, 
          Regularizer function applied to the recurrent\_kernel weights matrix(see
          ~\ref{regularizersDNN}).

        \item \xmlNode{bias\_regularizer}: \xmlDesc{string}, 
          regularizer function applied to the bias vector (see~\ref{regularizersDNN}).

        \item \xmlNode{activity\_regularizer}: \xmlDesc{string}, 
          regularizer function applied to the output         of the layer (its ``activation'').
          (see~\ref{regularizersDNN})

        \item \xmlNode{kernel\_constraint}: \xmlDesc{string}, 
          constraint function applied to the kernel weights matrix (see~\ref{constraintsDNN}).

        \item \xmlNode{recurrent\_constraint}: \xmlDesc{string}, 
          Constraint function applied to the recurrent\_kernel weights
          matrix(see~\ref{constraintsDNN}).

        \item \xmlNode{bias\_constraint}: \xmlDesc{string}, 
          constraint function applied to the bias vector (see ~\ref{constraintsDNN})

        \item \xmlNode{dropout}: \xmlDesc{float}, 
          Float between 0 and 1. Fraction of the units to drop for the linear transformation of the
          inputs.

        \item \xmlNode{recurrent\_dropout}: \xmlDesc{float}, 
          Float between 0 and 1. Fraction of the units to drop for the linear transformation of the
          recurrent state.

        \item \xmlNode{return\_sequences}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
          Whether to return the last output in the output sequence, or the full sequence.

        \item \xmlNode{return\_state}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
          Whether to return the last state in addition to the output.

        \item \xmlNode{go\_backwards}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
          If True, process the input sequence backwards and return the reversed sequence.

        \item \xmlNode{stateful}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
          If True, the last state for each sample at index i in a batch will be used as initial
          state for the         sample of index i in the following batch.

        \item \xmlNode{unroll}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
          If True, the network will be unrolled, else a symbolic loop will be used. Unrolling can
          speed-up a         RNN, although it tends to be more memory-intensive. Unrolling is only
          suitable for short sequences.

        \item \xmlNode{unit\_forget\_bias}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
          If True, add 1 to the bias of the forget gate at initialization. Setting it to true will
          also         force bias\_initializer=``zeros''.
      \end{itemize}

    \item \xmlNode{ConvLSTM2D}: \xmlDesc{string}, 
      2D Convolutional LSTM. Similar to an LSTM layer, but the input transformations and recurrent
      transformations are both convolutional.
      The \xmlNode{ConvLSTM2D} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{name}: \xmlDesc{string, required}, 
            the name of the layer
      \end{itemize}

      The \xmlNode{ConvLSTM2D} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{dim\_out}: \xmlDesc{integer}, 
          dimensionality of the output space of this layer

        \item \xmlNode{kernel\_size}: \xmlDesc{comma-separated integers}, 
          An integer or tuple/list of n integers, specifying the dimensions of the convolution
          window.

        \item \xmlNode{strides}: \xmlDesc{comma-separated integers}, 
          An integer or tuple/list of n integers, specifying the strides of the convolution.
          Specifying any         stride value != 1 is incompatible with specifying any
          dilation\_rate value != 1.

        \item \xmlNode{padding}: \xmlDesc{[valid, same]}, 
          One of ``valid'' or ``same'' (case-insensitive). ``valid'' means no padding. ``same''
          results in padding        evenly to the left/right or up/down of the input such that
          output has the same height/width dimension as        the input.

        \item \xmlNode{data\_format}: \xmlDesc{[channels\_last, channels\_first]}, 
          A string, one of channels\_last (default) or channels\_first.

        \item \xmlNode{dilation\_rate}: \xmlDesc{comma-separated integers}, 
          An integer or tuple/list of n integers, specifying the dilation rate to use for dilated
          convolution.         Currently, specifying any dilation\_rate value != 1 is incompatible
          with specifying any strides value != 1.

        \item \xmlNode{activation}: \xmlDesc{string}, 
          Activation function to use. If you don't specify anything, no activation is applied (ie.
          ``linear''         activation: $a(x) = x)$.

        \item \xmlNode{recurrent\_activation}: \xmlDesc{string}, 
          Activation function to use for the recurrent step.

        \item \xmlNode{use\_bias}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
          whether the layer uses a bias vector.

        \item \xmlNode{kernel\_initializer}: \xmlDesc{string}, 
          initializer for the kernel weights matrix (see~\ref{initializersDNN}).

        \item \xmlNode{recurrent\_initializer}: \xmlDesc{string}, 
          Initializer for the recurrent\_kernel weights matrix, used for the linear transformation
          of the         recurrent state (see~\ref{initializersDNN}).

        \item \xmlNode{bias\_initializer}: \xmlDesc{string}, 
          initializer for the bias vector (see ~\ref{initializersDNN}).

        \item \xmlNode{kernel\_regularizer}: \xmlDesc{string}, 
          regularizer function applied to the kernel weights matrix (see ~\ref{regularizersDNN}).

        \item \xmlNode{recurrent\_regularizer}: \xmlDesc{string}, 
          Regularizer function applied to the recurrent\_kernel weights matrix(see
          ~\ref{regularizersDNN}).

        \item \xmlNode{bias\_regularizer}: \xmlDesc{string}, 
          regularizer function applied to the bias vector (see~\ref{regularizersDNN}).

        \item \xmlNode{activity\_regularizer}: \xmlDesc{string}, 
          regularizer function applied to the output         of the layer (its ``activation'').
          (see~\ref{regularizersDNN})

        \item \xmlNode{kernel\_constraint}: \xmlDesc{string}, 
          constraint function applied to the kernel weights matrix (see~\ref{constraintsDNN}).

        \item \xmlNode{recurrent\_constraint}: \xmlDesc{string}, 
          Constraint function applied to the recurrent\_kernel weights
          matrix(see~\ref{constraintsDNN}).

        \item \xmlNode{bias\_constraint}: \xmlDesc{string}, 
          constraint function applied to the bias vector (see ~\ref{constraintsDNN})

        \item \xmlNode{dropout}: \xmlDesc{float}, 
          Float between 0 and 1. Fraction of the units to drop for the linear transformation of the
          inputs.

        \item \xmlNode{recurrent\_dropout}: \xmlDesc{float}, 
          Float between 0 and 1. Fraction of the units to drop for the linear transformation of the
          recurrent state.

        \item \xmlNode{return\_sequences}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
          Whether to return the last output in the output sequence, or the full sequence.

        \item \xmlNode{return\_state}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
          Whether to return the last state in addition to the output.

        \item \xmlNode{go\_backwards}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
          If True, process the input sequence backwards and return the reversed sequence.

        \item \xmlNode{stateful}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
          If True, the last state for each sample at index i in a batch will be used as initial
          state for the         sample of index i in the following batch.

        \item \xmlNode{unroll}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
          If True, the network will be unrolled, else a symbolic loop will be used. Unrolling can
          speed-up a         RNN, although it tends to be more memory-intensive. Unrolling is only
          suitable for short sequences.

        \item \xmlNode{unit\_forget\_bias}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
          If True, add 1 to the bias of the forget gate at initialization. Setting it to true will
          also         force bias\_initializer=``zeros''.
      \end{itemize}

    \item \xmlNode{Embdedding}: \xmlDesc{string}, 
      Turns positive integers (indexes) into dense vectors of fixed size.         e.g. [[4], [20]]
      -> [[0.25, 0.1], [0.6, -0.2]]         This layer can only be used as the first layer in a
      model.
      The \xmlNode{Embdedding} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{name}: \xmlDesc{string, required}, 
            the name of the layer
      \end{itemize}

      The \xmlNode{Embdedding} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{input\_dim}: \xmlDesc{integer}, 
          Size of the vocabulary.

        \item \xmlNode{output\_dim}: \xmlDesc{string}, 
          Dimension of the dense embedding.

        \item \xmlNode{embeddings\_initializer}: \xmlDesc{string}, 
          Initializer for the embeddings matrix (see~\ref{initializersDNN}).

        \item \xmlNode{embeddings\_regularizer}: \xmlDesc{string}, 
          Regularizer function applied to the embeddings matrix (see ~\ref{regularizersDNN}).

        \item \xmlNode{embdeddings\_constraint}: \xmlDesc{string}, 
          Constraint function applied to the embeddings matrix (see~\ref{constraintsDNN}).

        \item \xmlNode{mask\_zero}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
          whether or not the input value 0 is a special ``padding'' value that should be masked out.
          This is useful when using recurrent layers which may take variable length input. If this
          is True, then         all subsequent layers in the model need to support masking or an
          exception will be raised. If mask\_zero         is set to True, as a consequence, index 0
          cannot be used in the vocabulary (input\_dim should equal size         of vocabulary + 1).

        \item \xmlNode{input\_length}: \xmlDesc{integer}, 
          Length of input sequences, when it is constant. This argument is required if you are going
          to         connect Flatten then Dense layers upstream (without it, the shape of the dense
          outputs cannot be computed).
      \end{itemize}

    \item \xmlNode{LeakyReLU}: \xmlDesc{string}, 
      Leaky version of a Rectified Linear Unit.
      The \xmlNode{LeakyReLU} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{name}: \xmlDesc{string, required}, 
            the name of the layer
      \end{itemize}

      The \xmlNode{LeakyReLU} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{alpha}: \xmlDesc{float}, 
          Negative slope coefficient.
      \end{itemize}

    \item \xmlNode{PReLU}: \xmlDesc{string}, 
      Parametric Rectified Linear Unit.
      The \xmlNode{PReLU} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{name}: \xmlDesc{string, required}, 
            the name of the layer
      \end{itemize}

      The \xmlNode{PReLU} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{alpha\_initializer}: \xmlDesc{string}, 
          Initializer function for the weights.

        \item \xmlNode{alpha\_regularizer}: \xmlDesc{string}, 
          Regularizer for the weights.

        \item \xmlNode{alpha\_constraint}: \xmlDesc{string}, 
          Constraint for the weights.

        \item \xmlNode{shared\_axes}: \xmlDesc{comma-separated floats}, 
          The axes along which to share learnable parameters for the activation function.
      \end{itemize}

    \item \xmlNode{ELU}: \xmlDesc{string}, 
      Exponential Linear Unit.
      The \xmlNode{ELU} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{name}: \xmlDesc{string, required}, 
            the name of the layer
      \end{itemize}

      The \xmlNode{ELU} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{alpha}: \xmlDesc{float}, 
          Scale for the negative factor.
      \end{itemize}

    \item \xmlNode{ThresholdedReLU}: \xmlDesc{string}, 
      Thresholded Rectified Linear Unit.
      The \xmlNode{ThresholdedReLU} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{name}: \xmlDesc{string, required}, 
            the name of the layer
      \end{itemize}

      The \xmlNode{ThresholdedReLU} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{theta}: \xmlDesc{float}, 
          Float >= 0. Threshold location of activation.
      \end{itemize}

    \item \xmlNode{Softmax}: \xmlDesc{string}, 
      Softmax activation function.
      The \xmlNode{Softmax} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{name}: \xmlDesc{string, required}, 
            the name of the layer
      \end{itemize}

      The \xmlNode{Softmax} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{axis}: \xmlDesc{comma-separated integers}, 
          Integer, or list of Integers, axis along which the softmax normalization is applied.
      \end{itemize}

    \item \xmlNode{ReLU}: \xmlDesc{string}, 
      Rectified Linear Unit activation function.
      The \xmlNode{ReLU} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{name}: \xmlDesc{string, required}, 
            the name of the layer
      \end{itemize}

      The \xmlNode{ReLU} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{max\_value}: \xmlDesc{float}, 
          Float >= 0. Maximum activation value. Default to None, which means unlimited.

        \item \xmlNode{negative\_slope}: \xmlDesc{float}, 
          Float >= 0. Negative slope coefficient.

        \item \xmlNode{threshold}: \xmlDesc{float}, 
          Float >= 0. Threshold value for thresholded activation.
      \end{itemize}

    \item \xmlNode{BatchNormalization}: \xmlDesc{string}, 
      Layer that normalizes its inputs. Batch normalization applies a transformation that maintains
      the mean output close to 0 and the output standard deviation close to 1.
      The \xmlNode{BatchNormalization} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{name}: \xmlDesc{string, required}, 
            the name of the layer
      \end{itemize}

      The \xmlNode{BatchNormalization} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{axis}: \xmlDesc{integer}, 
          the axis that should be normalized (typically the features axis).

        \item \xmlNode{momentum}: \xmlDesc{float}, 
          Momentum for the moving average.

        \item \xmlNode{epsilon}: \xmlDesc{float}, 
          Small float added to variance to avoid dividing by zero.

        \item \xmlNode{center}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
          If True, add offset of beta to normalized tensor. If False, beta is ignored.

        \item \xmlNode{scale}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
          If True, multiply by gamma. If False, gamma is not used.

        \item \xmlNode{beta\_initializer}: \xmlDesc{string}, 
          Initializer for the beta weight.

        \item \xmlNode{gamma\_initializer}: \xmlDesc{string}, 
          Initializer for the gamma weight.

        \item \xmlNode{moving\_mean\_initializer}: \xmlDesc{string}, 
          Initializer for the moving mean.

        \item \xmlNode{moving\_variance\_initializer}: \xmlDesc{string}, 
          Initializer for the moving variance.

        \item \xmlNode{beta\_regularizer}: \xmlDesc{string}, 
          Optional regularizer for the beta weight.

        \item \xmlNode{gamma\_regularizer}: \xmlDesc{string}, 
          Optional regularizer for the gamma weight.

        \item \xmlNode{beta\_constraint}: \xmlDesc{string}, 
          Optional constraint for the beta weight.

        \item \xmlNode{gamma\_constraint}: \xmlDesc{string}, 
          Optional constraint for the gamma weight.
      \end{itemize}

    \item \xmlNode{GaussianNoise}: \xmlDesc{string}, 
      Apply additive zero-centered Gaussian noise. This is useful to mitigate overfitting (you could
      see         it as a form of random data augmentation). Gaussian Noise (GS) is a natural choice
      as corruption process         for real valued inputs. As it is a regularization layer, it is
      only active at training time.
      The \xmlNode{GaussianNoise} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{name}: \xmlDesc{string, required}, 
            the name of the layer
      \end{itemize}

      The \xmlNode{GaussianNoise} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{stddev}: \xmlDesc{float}, 
          standard deviation of the noise distribution.
      \end{itemize}

    \item \xmlNode{GaussianDropout}: \xmlDesc{string}, 
      Apply multiplicative 1-centered Gaussian noise. As it is a regularization layer, it is only
      active         at training time.
      The \xmlNode{GaussianDropout} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{name}: \xmlDesc{string, required}, 
            the name of the layer
      \end{itemize}

      The \xmlNode{GaussianDropout} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{rate}: \xmlDesc{float}, 
          drop probability (as with Dropout). The multiplicative noise will have standard deviation
          $sqrt(rate / (1 - rate))$.
      \end{itemize}

    \item \xmlNode{layer\_layout}: \xmlDesc{comma-separated strings}, 
      The layout of the neural network layers, i.e., the list of names of neural network layers
  \end{itemize}
