

\subsubsection{LinearDiscriminantAnalysisClassifier}
  The \xmlNode{LinearDiscriminantAnalysisClassifier} is a classifier with a linear decision
  boundary,     generated by fitting class conditional densities to the data and using Bayes' rule.
  The model fits a Gaussian density to each class, assuming that all classes share the same
  covariance matrix.     The fitted model can also be used to reduce the dimensionality of the input
  by projecting it to the most discriminative     directions, using the transform method.
  \zNormalizationNotPerformed{LinearDiscriminantAnalysisClassifier}

  The \xmlNode{LinearDiscriminantAnalysisClassifier} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{LinearDiscriminantAnalysisClassifier} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.
  \default{time}

    \item \xmlNode{featureSelection}:
      Apply feature selection algorithm

      The \xmlNode{featureSelection} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{RFE}:
          The \xmlString{RFE} (Recursive Feature Elimination) is a feature selection algorithm.
          Feature selection refers to techniques that select a subset of the most relevant features
          for a model (ROM).         Fewer features can allow ROMs to run more efficiently (less
          space or time complexity) and be more effective.         Indeed, some ROMs (machine
          learning algorithms) can be misled by irrelevant input features, resulting in worse
          predictive performance.         RFE is a wrapper-type feature selection algorithm. This
          means that a different ROM is given and used in the core of the         method,         is
          wrapped by RFE, and used to help select features.         \\RFE works by searching for a
          subset of features by starting with all features in the training dataset and successfully
          removing         features until the desired number remains.         This is achieved by
          fitting the given ROME used in the core of the model, ranking features by importance,
          discarding the least important features, and re-fitting the model. This process is
          repeated until a specified number of         features remains.         When the full model
          is created, a measure of variable importance is computed that ranks the predictors from
          most         important to least.         At each stage of the search, the least important
          predictors are iteratively eliminated prior to rebuilding the model.         Features are
          scored either using the ROM model (if the model provides a mean to compute feature
          importances) or by         using a statistical method.         \\In RAVEN the
          \xmlString{RFE} class refers to an augmentation of the basic algorithm, since it allows,
          optionally,         to perform the search on multiple groups of targets (separately) and
          then combine the results of the search in a         single set. In addition, when the RFE
          search is concluded, the user can request to identify the set of features         that
          bring to a minimization of the score (i.e. maximimization of the accuracy).         In
          addition, using the ``applyClusteringFiltering'' option, the algorithm can, using an
          hierarchal clustering algorithm,         identify highly correlated features to speed up
          the subsequential search.
          The \xmlNode{RFE} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{RFE} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{nFeaturesToSelect}: \xmlDesc{integer}, 
              Exact Number of features to select. If not inputted, ``nFeaturesToSelect'' will be set
              to $1/2$ of the features in the training dataset.
  \default{None}

            \item \xmlNode{maxNumberFeatures}: \xmlDesc{integer}, 
              Maximum Number of features to select, the algorithm will automatically determine the
              feature list to minimize a total score.
  \default{None}

            \item \xmlNode{onlyOutputScore}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              If maxNumberFeatures is on, only output score should beconsidered? Or, in case of
              particular models (e.g. DMDC), state variable space score should be considered as
              well.
  \default{False}

            \item \xmlNode{applyClusteringFiltering}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              Applying clustering correlation before RFE search? If true, an hierarchal clustering
              is applied on the feature         space aimed to remove features that are correlated
              before the actual RFE search is performed. This approach can stabilize and
              accelerate the process in case of large feature spaces (e.g > 500 features).
  \default{False}

            \item \xmlNode{applyCrossCorrelation}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              In case of subgroupping, should a cross correleation analysis should be performed
              cross sub-groups?         If it is activated, a cross correleation analysis is used to
              additionally filter the features selected for each         sub-groupping search.
  \default{False}

            \item \xmlNode{step}: \xmlDesc{float}, 
              If greater than or equal to 1, then step corresponds to the (integer) number
              of features to remove at each iteration. If within (0.0, 1.0), then step
              corresponds to the percentage (rounded down) of features to remove at         each
              iteration.
  \default{1}

            \item \xmlNode{subGroup}: \xmlDesc{comma-separated strings, integers, and floats}, 
              Subgroup of output variables on which to perform the search. Multiple nodes of this
              type can be inputted. The RFE search will be then performed in each ``subgroup''
              separately and then the the union of the different feature sets are used for the final
              ROM.
          \end{itemize}

        \item \xmlNode{VarianceThreshold}:
          The \xmlString{VarianceThreshold} is a feature selector that removes     all low-variance
          features. This feature selection algorithm looks only at the features and not     the
          desired outputs. The variance threshold can be set by the user.
          The \xmlNode{VarianceThreshold} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{VarianceThreshold} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{threshold}: \xmlDesc{float}, 
              Features with a training-set variance lower than this threshold                   will
              be removed. The default is to keep all features with non-zero
              variance, i.e. remove the features that have the same value in all
              samples.
  \default{0.0}
          \end{itemize}
      \end{itemize}

    \item \xmlNode{featureSpaceTransformation}:
      Use dimensionality reduction technique to perform a trasformation of the training dataset
      into an uncorrelated one. The dimensionality of the problem will not be reduced but
      the data will be transformed in the transformed space. E.g if the number of features
      are 5, the method projects such features into a new uncorrelated space (still 5-dimensional).
      In case of time-dependent ROMs, all the samples are concatenated in a global 2D matrix
      (n\_samples*n\_timesteps,n\_features) before applying the transformation and then reconstructed
      back into the original shape (before fitting the model).

      The \xmlNode{featureSpaceTransformation} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{transformationMethod}: \xmlDesc{[PCA, KernelLinearPCA, KernelPolyPCA, KernelRbfPCA, KernelSigmoidPCA, KernelCosinePCA, ICA]}, 
          Transformation method to use. Eight options (5 Kernel PCAs) are available:
          \begin{itemize}                     \item \textit{PCA}, Principal Component Analysis;
          \item \textit{KernelLinearPCA}, Kernel (Linear) Principal component analysis;
          \item \textit{KernelPolyPCA}, Kernel (Poly) Principal component analysis;
          \item \textit{KernelRbfPCA}, Kernel(Rbf) Principal component analysis;
          \item \textit{KernelSigmoidPCA}, Kernel (Sigmoid) Principal component analysis;
          \item \textit{KernelCosinePCA}, Kernel (Cosine) Principal component analysis;
          \item \textit{ICA}, Independent component analysis;                    \end{itemize}
  \default{PCA}

        \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
          List of IDs of features/variables to include in the transformation process.
  \default{None}

        \item \xmlNode{whichSpace}: \xmlDesc{string}, 
          Which space to search? Target or Feature?
  \default{Feature}
      \end{itemize}

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{solver}: \xmlDesc{string}, 
      Solver to use, possible values:
      \begin{itemize}                                                    \item svd: Singular value
      decomposition (default). Does not compute the covariance matrix,
      therefore this solver is recommended for data with a large number of features.
      \item lsqr: Least squares solution. Can be combined with shrinkage or custom covariance
      estimator.                                                    \item eigen: Eigenvalue
      decomposition. Can be combined with shrinkage or custom covariance estimator.
      \end{itemize}
  \default{svd}

    \item \xmlNode{Shrinkage}: \xmlDesc{float or string}, 
      Shrinkage parameter, possible values: 1) None: no shrinkage (default),
      2) `auto': automatic shrinkage using the Ledoit-Wolf lemma,
      3) float between 0 an d1: fixed shrinkage parameter.
      This should be left to None if covariance\_estimator is used. Note that shrinkage works
      only with `lsqr' and `eigen' solvers.
  \default{None}

    \item \xmlNode{priors}: \xmlDesc{comma-separated floats}, 
      The class prior probabilities. By default, the class proportions are inferred from the
      training data.
  \default{None}

    \item \xmlNode{n\_components}: \xmlDesc{integer}, 
      Number of components (<= min(n\_classes - 1, n\_features)) for dimensionality reduction.
      If None, will be set to min(n\_classes - 1, n\_features). This parameter only affects the
      transform                                                  method.
  \default{None}

    \item \xmlNode{store\_covariance}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      If True, explicitely compute the weighted within-class covariance matrix when solver
      is `svd'. The matrix is always computed and stored for the other solvers.
  \default{False}

    \item \xmlNode{tol}: \xmlDesc{float}, 
      Absolute threshold for a singular value of X to be considered significant, used to estimate
      the rank of X.                                                  Dimensions whose singular
      values are non-significant are discarded. Only used if solver is `svd'.
  \default{0.0001}

    \item \xmlNode{covariance\_estimator}: \xmlDesc{integer}, 
      covariance estimator (not supported)
  \default{None}
  \end{itemize}


\subsubsection{QuadraticDiscriminantAnalysisClassifier}
  The \xmlNode{QuadraticDiscriminantAnalysisClassifier} is a classifier with a quadratic decision
  boundary,     generated by fitting class conditional densities to the data and using Bayes' rule.
  The model fits a Gaussian density to each class
  \zNormalizationNotPerformed{QuadraticDiscriminantAnalysisClassifier}

  The \xmlNode{QuadraticDiscriminantAnalysisClassifier} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{QuadraticDiscriminantAnalysisClassifier} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.
  \default{time}

    \item \xmlNode{featureSelection}:
      Apply feature selection algorithm

      The \xmlNode{featureSelection} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{RFE}:
          The \xmlString{RFE} (Recursive Feature Elimination) is a feature selection algorithm.
          Feature selection refers to techniques that select a subset of the most relevant features
          for a model (ROM).         Fewer features can allow ROMs to run more efficiently (less
          space or time complexity) and be more effective.         Indeed, some ROMs (machine
          learning algorithms) can be misled by irrelevant input features, resulting in worse
          predictive performance.         RFE is a wrapper-type feature selection algorithm. This
          means that a different ROM is given and used in the core of the         method,         is
          wrapped by RFE, and used to help select features.         \\RFE works by searching for a
          subset of features by starting with all features in the training dataset and successfully
          removing         features until the desired number remains.         This is achieved by
          fitting the given ROME used in the core of the model, ranking features by importance,
          discarding the least important features, and re-fitting the model. This process is
          repeated until a specified number of         features remains.         When the full model
          is created, a measure of variable importance is computed that ranks the predictors from
          most         important to least.         At each stage of the search, the least important
          predictors are iteratively eliminated prior to rebuilding the model.         Features are
          scored either using the ROM model (if the model provides a mean to compute feature
          importances) or by         using a statistical method.         \\In RAVEN the
          \xmlString{RFE} class refers to an augmentation of the basic algorithm, since it allows,
          optionally,         to perform the search on multiple groups of targets (separately) and
          then combine the results of the search in a         single set. In addition, when the RFE
          search is concluded, the user can request to identify the set of features         that
          bring to a minimization of the score (i.e. maximimization of the accuracy).         In
          addition, using the ``applyClusteringFiltering'' option, the algorithm can, using an
          hierarchal clustering algorithm,         identify highly correlated features to speed up
          the subsequential search.
          The \xmlNode{RFE} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{RFE} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{nFeaturesToSelect}: \xmlDesc{integer}, 
              Exact Number of features to select. If not inputted, ``nFeaturesToSelect'' will be set
              to $1/2$ of the features in the training dataset.
  \default{None}

            \item \xmlNode{maxNumberFeatures}: \xmlDesc{integer}, 
              Maximum Number of features to select, the algorithm will automatically determine the
              feature list to minimize a total score.
  \default{None}

            \item \xmlNode{onlyOutputScore}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              If maxNumberFeatures is on, only output score should beconsidered? Or, in case of
              particular models (e.g. DMDC), state variable space score should be considered as
              well.
  \default{False}

            \item \xmlNode{applyClusteringFiltering}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              Applying clustering correlation before RFE search? If true, an hierarchal clustering
              is applied on the feature         space aimed to remove features that are correlated
              before the actual RFE search is performed. This approach can stabilize and
              accelerate the process in case of large feature spaces (e.g > 500 features).
  \default{False}

            \item \xmlNode{applyCrossCorrelation}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              In case of subgroupping, should a cross correleation analysis should be performed
              cross sub-groups?         If it is activated, a cross correleation analysis is used to
              additionally filter the features selected for each         sub-groupping search.
  \default{False}

            \item \xmlNode{step}: \xmlDesc{float}, 
              If greater than or equal to 1, then step corresponds to the (integer) number
              of features to remove at each iteration. If within (0.0, 1.0), then step
              corresponds to the percentage (rounded down) of features to remove at         each
              iteration.
  \default{1}

            \item \xmlNode{subGroup}: \xmlDesc{comma-separated strings, integers, and floats}, 
              Subgroup of output variables on which to perform the search. Multiple nodes of this
              type can be inputted. The RFE search will be then performed in each ``subgroup''
              separately and then the the union of the different feature sets are used for the final
              ROM.
          \end{itemize}

        \item \xmlNode{VarianceThreshold}:
          The \xmlString{VarianceThreshold} is a feature selector that removes     all low-variance
          features. This feature selection algorithm looks only at the features and not     the
          desired outputs. The variance threshold can be set by the user.
          The \xmlNode{VarianceThreshold} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{VarianceThreshold} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{threshold}: \xmlDesc{float}, 
              Features with a training-set variance lower than this threshold                   will
              be removed. The default is to keep all features with non-zero
              variance, i.e. remove the features that have the same value in all
              samples.
  \default{0.0}
          \end{itemize}
      \end{itemize}

    \item \xmlNode{featureSpaceTransformation}:
      Use dimensionality reduction technique to perform a trasformation of the training dataset
      into an uncorrelated one. The dimensionality of the problem will not be reduced but
      the data will be transformed in the transformed space. E.g if the number of features
      are 5, the method projects such features into a new uncorrelated space (still 5-dimensional).
      In case of time-dependent ROMs, all the samples are concatenated in a global 2D matrix
      (n\_samples*n\_timesteps,n\_features) before applying the transformation and then reconstructed
      back into the original shape (before fitting the model).

      The \xmlNode{featureSpaceTransformation} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{transformationMethod}: \xmlDesc{[PCA, KernelLinearPCA, KernelPolyPCA, KernelRbfPCA, KernelSigmoidPCA, KernelCosinePCA, ICA]}, 
          Transformation method to use. Eight options (5 Kernel PCAs) are available:
          \begin{itemize}                     \item \textit{PCA}, Principal Component Analysis;
          \item \textit{KernelLinearPCA}, Kernel (Linear) Principal component analysis;
          \item \textit{KernelPolyPCA}, Kernel (Poly) Principal component analysis;
          \item \textit{KernelRbfPCA}, Kernel(Rbf) Principal component analysis;
          \item \textit{KernelSigmoidPCA}, Kernel (Sigmoid) Principal component analysis;
          \item \textit{KernelCosinePCA}, Kernel (Cosine) Principal component analysis;
          \item \textit{ICA}, Independent component analysis;                    \end{itemize}
  \default{PCA}

        \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
          List of IDs of features/variables to include in the transformation process.
  \default{None}

        \item \xmlNode{whichSpace}: \xmlDesc{string}, 
          Which space to search? Target or Feature?
  \default{Feature}
      \end{itemize}

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{priors}: \xmlDesc{comma-separated floats}, 
      The class prior probabilities. By default, the class
      proportions are inferred from the training data.
  \default{None}

    \item \xmlNode{reg\_param}: \xmlDesc{float}, 
      Regularizes the per-class covariance estimates by transforming
      S2 as S2 = (1 - reg\_param) * S2 + reg\_param * np.eye(n\_features),
      where S2 corresponds to the                                                  scaling\_
      attribute of a given class.
  \default{0.0}

    \item \xmlNode{store\_covariance}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      If True, the class covariance matrices are explicitely
      computed and stored in the self.covariance\_ attribute.
  \default{False}

    \item \xmlNode{tol}: \xmlDesc{float}, 
      Absolute threshold for a singular value to be considered
      significant, used to estimate the rank of Xk where Xk is the centered
      matrix of samples in class k. This parameter does not affect
      the predictions. It only controls a warning that is raised when
      features are considered to be colinear.
  \default{0.0001}
  \end{itemize}


\subsubsection{ARDRegression}
  The \xmlNode{ARDRegression} is Bayesian ARD regression.                             Fit the
  weights of a regression model, using an ARD prior. The weights of the
  regression model are assumed to be in Gaussian distributions. Also estimate the
  parameters lambda (precisions of the distributions of the weights) and
  alpha (precision of the distribution of the noise).                             The estimation is
  done by an iterative procedures (Evidence Maximization).
  \zNormalizationNotPerformed{ARDRegression}

  The \xmlNode{ARDRegression} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{ARDRegression} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.
  \default{time}

    \item \xmlNode{featureSelection}:
      Apply feature selection algorithm

      The \xmlNode{featureSelection} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{RFE}:
          The \xmlString{RFE} (Recursive Feature Elimination) is a feature selection algorithm.
          Feature selection refers to techniques that select a subset of the most relevant features
          for a model (ROM).         Fewer features can allow ROMs to run more efficiently (less
          space or time complexity) and be more effective.         Indeed, some ROMs (machine
          learning algorithms) can be misled by irrelevant input features, resulting in worse
          predictive performance.         RFE is a wrapper-type feature selection algorithm. This
          means that a different ROM is given and used in the core of the         method,         is
          wrapped by RFE, and used to help select features.         \\RFE works by searching for a
          subset of features by starting with all features in the training dataset and successfully
          removing         features until the desired number remains.         This is achieved by
          fitting the given ROME used in the core of the model, ranking features by importance,
          discarding the least important features, and re-fitting the model. This process is
          repeated until a specified number of         features remains.         When the full model
          is created, a measure of variable importance is computed that ranks the predictors from
          most         important to least.         At each stage of the search, the least important
          predictors are iteratively eliminated prior to rebuilding the model.         Features are
          scored either using the ROM model (if the model provides a mean to compute feature
          importances) or by         using a statistical method.         \\In RAVEN the
          \xmlString{RFE} class refers to an augmentation of the basic algorithm, since it allows,
          optionally,         to perform the search on multiple groups of targets (separately) and
          then combine the results of the search in a         single set. In addition, when the RFE
          search is concluded, the user can request to identify the set of features         that
          bring to a minimization of the score (i.e. maximimization of the accuracy).         In
          addition, using the ``applyClusteringFiltering'' option, the algorithm can, using an
          hierarchal clustering algorithm,         identify highly correlated features to speed up
          the subsequential search.
          The \xmlNode{RFE} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{RFE} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{nFeaturesToSelect}: \xmlDesc{integer}, 
              Exact Number of features to select. If not inputted, ``nFeaturesToSelect'' will be set
              to $1/2$ of the features in the training dataset.
  \default{None}

            \item \xmlNode{maxNumberFeatures}: \xmlDesc{integer}, 
              Maximum Number of features to select, the algorithm will automatically determine the
              feature list to minimize a total score.
  \default{None}

            \item \xmlNode{onlyOutputScore}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              If maxNumberFeatures is on, only output score should beconsidered? Or, in case of
              particular models (e.g. DMDC), state variable space score should be considered as
              well.
  \default{False}

            \item \xmlNode{applyClusteringFiltering}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              Applying clustering correlation before RFE search? If true, an hierarchal clustering
              is applied on the feature         space aimed to remove features that are correlated
              before the actual RFE search is performed. This approach can stabilize and
              accelerate the process in case of large feature spaces (e.g > 500 features).
  \default{False}

            \item \xmlNode{applyCrossCorrelation}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              In case of subgroupping, should a cross correleation analysis should be performed
              cross sub-groups?         If it is activated, a cross correleation analysis is used to
              additionally filter the features selected for each         sub-groupping search.
  \default{False}

            \item \xmlNode{step}: \xmlDesc{float}, 
              If greater than or equal to 1, then step corresponds to the (integer) number
              of features to remove at each iteration. If within (0.0, 1.0), then step
              corresponds to the percentage (rounded down) of features to remove at         each
              iteration.
  \default{1}

            \item \xmlNode{subGroup}: \xmlDesc{comma-separated strings, integers, and floats}, 
              Subgroup of output variables on which to perform the search. Multiple nodes of this
              type can be inputted. The RFE search will be then performed in each ``subgroup''
              separately and then the the union of the different feature sets are used for the final
              ROM.
          \end{itemize}

        \item \xmlNode{VarianceThreshold}:
          The \xmlString{VarianceThreshold} is a feature selector that removes     all low-variance
          features. This feature selection algorithm looks only at the features and not     the
          desired outputs. The variance threshold can be set by the user.
          The \xmlNode{VarianceThreshold} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{VarianceThreshold} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{threshold}: \xmlDesc{float}, 
              Features with a training-set variance lower than this threshold                   will
              be removed. The default is to keep all features with non-zero
              variance, i.e. remove the features that have the same value in all
              samples.
  \default{0.0}
          \end{itemize}
      \end{itemize}

    \item \xmlNode{featureSpaceTransformation}:
      Use dimensionality reduction technique to perform a trasformation of the training dataset
      into an uncorrelated one. The dimensionality of the problem will not be reduced but
      the data will be transformed in the transformed space. E.g if the number of features
      are 5, the method projects such features into a new uncorrelated space (still 5-dimensional).
      In case of time-dependent ROMs, all the samples are concatenated in a global 2D matrix
      (n\_samples*n\_timesteps,n\_features) before applying the transformation and then reconstructed
      back into the original shape (before fitting the model).

      The \xmlNode{featureSpaceTransformation} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{transformationMethod}: \xmlDesc{[PCA, KernelLinearPCA, KernelPolyPCA, KernelRbfPCA, KernelSigmoidPCA, KernelCosinePCA, ICA]}, 
          Transformation method to use. Eight options (5 Kernel PCAs) are available:
          \begin{itemize}                     \item \textit{PCA}, Principal Component Analysis;
          \item \textit{KernelLinearPCA}, Kernel (Linear) Principal component analysis;
          \item \textit{KernelPolyPCA}, Kernel (Poly) Principal component analysis;
          \item \textit{KernelRbfPCA}, Kernel(Rbf) Principal component analysis;
          \item \textit{KernelSigmoidPCA}, Kernel (Sigmoid) Principal component analysis;
          \item \textit{KernelCosinePCA}, Kernel (Cosine) Principal component analysis;
          \item \textit{ICA}, Independent component analysis;                    \end{itemize}
  \default{PCA}

        \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
          List of IDs of features/variables to include in the transformation process.
  \default{None}

        \item \xmlNode{whichSpace}: \xmlDesc{string}, 
          Which space to search? Target or Feature?
  \default{Feature}
      \end{itemize}

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{n\_iter}: \xmlDesc{integer}, 
      Maximum number of iterations.
  \default{300}

    \item \xmlNode{tol}: \xmlDesc{float}, 
      Tolerance for stopping criterion
  \default{0.001}

    \item \xmlNode{alpha\_1}: \xmlDesc{float}, 
      Hyper-parameter : shape parameter for the Gamma
      distribution prior over the alpha parameter.
  \default{1e-06}

    \item \xmlNode{alpha\_2}: \xmlDesc{float}, 
      Hyper-parameter : inverse scale parameter (rate parameter)
      for the Gamma distribution prior over the alpha parameter.
  \default{1e-06}

    \item \xmlNode{lambda\_1}: \xmlDesc{float}, 
      Hyper-parameter : shape parameter for the Gamma distribution
      prior over the lambda parameter.
  \default{1e-06}

    \item \xmlNode{lambda\_2}: \xmlDesc{float}, 
      Hyper-parameter : inverse scale parameter (rate parameter) for
      the Gamma distribution prior over the lambda parameter.
  \default{1e-06}

    \item \xmlNode{compute\_score}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      If True, compute the objective function at each step of the
      model.
  \default{False}

    \item \xmlNode{threshold\_lambda}: \xmlDesc{float}, 
      threshold for removing (pruning) weights with
      shigh precision from the computation..
  \default{10000}

    \item \xmlNode{fit\_intercept}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Whether to calculate the intercept for this model. Specifies if a constant (a.k.a. bias or
      intercept)                                                   should be added to the decision
      function.
  \default{True}

    \item \xmlNode{normalize}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      This parameter is ignored when fit\_intercept is set to False. If True,
      the regressors X will be normalized before regression by subtracting the mean and
      dividing by the l2-norm.
  \default{True}

    \item \xmlNode{verbose}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Verbose mode when fitting the model.
  \default{False}
  \end{itemize}


\subsubsection{BayesianRidge}
  The \xmlNode{BayesianRidge} is Bayesian Ridge regression.                         It estimates a
  probabilistic model of the regression problem as                         described above. The
  prior for the coefficient is given by a                         spherical Gaussian:
  $p(w|\lambda) = \mathcal{N}(w|0,\lambda^{-1}\mathbf{I}\_{p})$                         The
  parameters $w$, $\alpha$ and $\lambda$ are estimated jointly during                         the
  fit of the model, the regularization parameters $\alpha$ and $\lambda$
  being estimated by maximizing the log marginal likelihood.
  \zNormalizationNotPerformed{BayesianRidge}

  The \xmlNode{BayesianRidge} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{BayesianRidge} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.
  \default{time}

    \item \xmlNode{featureSelection}:
      Apply feature selection algorithm

      The \xmlNode{featureSelection} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{RFE}:
          The \xmlString{RFE} (Recursive Feature Elimination) is a feature selection algorithm.
          Feature selection refers to techniques that select a subset of the most relevant features
          for a model (ROM).         Fewer features can allow ROMs to run more efficiently (less
          space or time complexity) and be more effective.         Indeed, some ROMs (machine
          learning algorithms) can be misled by irrelevant input features, resulting in worse
          predictive performance.         RFE is a wrapper-type feature selection algorithm. This
          means that a different ROM is given and used in the core of the         method,         is
          wrapped by RFE, and used to help select features.         \\RFE works by searching for a
          subset of features by starting with all features in the training dataset and successfully
          removing         features until the desired number remains.         This is achieved by
          fitting the given ROME used in the core of the model, ranking features by importance,
          discarding the least important features, and re-fitting the model. This process is
          repeated until a specified number of         features remains.         When the full model
          is created, a measure of variable importance is computed that ranks the predictors from
          most         important to least.         At each stage of the search, the least important
          predictors are iteratively eliminated prior to rebuilding the model.         Features are
          scored either using the ROM model (if the model provides a mean to compute feature
          importances) or by         using a statistical method.         \\In RAVEN the
          \xmlString{RFE} class refers to an augmentation of the basic algorithm, since it allows,
          optionally,         to perform the search on multiple groups of targets (separately) and
          then combine the results of the search in a         single set. In addition, when the RFE
          search is concluded, the user can request to identify the set of features         that
          bring to a minimization of the score (i.e. maximimization of the accuracy).         In
          addition, using the ``applyClusteringFiltering'' option, the algorithm can, using an
          hierarchal clustering algorithm,         identify highly correlated features to speed up
          the subsequential search.
          The \xmlNode{RFE} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{RFE} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{nFeaturesToSelect}: \xmlDesc{integer}, 
              Exact Number of features to select. If not inputted, ``nFeaturesToSelect'' will be set
              to $1/2$ of the features in the training dataset.
  \default{None}

            \item \xmlNode{maxNumberFeatures}: \xmlDesc{integer}, 
              Maximum Number of features to select, the algorithm will automatically determine the
              feature list to minimize a total score.
  \default{None}

            \item \xmlNode{onlyOutputScore}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              If maxNumberFeatures is on, only output score should beconsidered? Or, in case of
              particular models (e.g. DMDC), state variable space score should be considered as
              well.
  \default{False}

            \item \xmlNode{applyClusteringFiltering}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              Applying clustering correlation before RFE search? If true, an hierarchal clustering
              is applied on the feature         space aimed to remove features that are correlated
              before the actual RFE search is performed. This approach can stabilize and
              accelerate the process in case of large feature spaces (e.g > 500 features).
  \default{False}

            \item \xmlNode{applyCrossCorrelation}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              In case of subgroupping, should a cross correleation analysis should be performed
              cross sub-groups?         If it is activated, a cross correleation analysis is used to
              additionally filter the features selected for each         sub-groupping search.
  \default{False}

            \item \xmlNode{step}: \xmlDesc{float}, 
              If greater than or equal to 1, then step corresponds to the (integer) number
              of features to remove at each iteration. If within (0.0, 1.0), then step
              corresponds to the percentage (rounded down) of features to remove at         each
              iteration.
  \default{1}

            \item \xmlNode{subGroup}: \xmlDesc{comma-separated strings, integers, and floats}, 
              Subgroup of output variables on which to perform the search. Multiple nodes of this
              type can be inputted. The RFE search will be then performed in each ``subgroup''
              separately and then the the union of the different feature sets are used for the final
              ROM.
          \end{itemize}

        \item \xmlNode{VarianceThreshold}:
          The \xmlString{VarianceThreshold} is a feature selector that removes     all low-variance
          features. This feature selection algorithm looks only at the features and not     the
          desired outputs. The variance threshold can be set by the user.
          The \xmlNode{VarianceThreshold} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{VarianceThreshold} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{threshold}: \xmlDesc{float}, 
              Features with a training-set variance lower than this threshold                   will
              be removed. The default is to keep all features with non-zero
              variance, i.e. remove the features that have the same value in all
              samples.
  \default{0.0}
          \end{itemize}
      \end{itemize}

    \item \xmlNode{featureSpaceTransformation}:
      Use dimensionality reduction technique to perform a trasformation of the training dataset
      into an uncorrelated one. The dimensionality of the problem will not be reduced but
      the data will be transformed in the transformed space. E.g if the number of features
      are 5, the method projects such features into a new uncorrelated space (still 5-dimensional).
      In case of time-dependent ROMs, all the samples are concatenated in a global 2D matrix
      (n\_samples*n\_timesteps,n\_features) before applying the transformation and then reconstructed
      back into the original shape (before fitting the model).

      The \xmlNode{featureSpaceTransformation} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{transformationMethod}: \xmlDesc{[PCA, KernelLinearPCA, KernelPolyPCA, KernelRbfPCA, KernelSigmoidPCA, KernelCosinePCA, ICA]}, 
          Transformation method to use. Eight options (5 Kernel PCAs) are available:
          \begin{itemize}                     \item \textit{PCA}, Principal Component Analysis;
          \item \textit{KernelLinearPCA}, Kernel (Linear) Principal component analysis;
          \item \textit{KernelPolyPCA}, Kernel (Poly) Principal component analysis;
          \item \textit{KernelRbfPCA}, Kernel(Rbf) Principal component analysis;
          \item \textit{KernelSigmoidPCA}, Kernel (Sigmoid) Principal component analysis;
          \item \textit{KernelCosinePCA}, Kernel (Cosine) Principal component analysis;
          \item \textit{ICA}, Independent component analysis;                    \end{itemize}
  \default{PCA}

        \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
          List of IDs of features/variables to include in the transformation process.
  \default{None}

        \item \xmlNode{whichSpace}: \xmlDesc{string}, 
          Which space to search? Target or Feature?
  \default{Feature}
      \end{itemize}

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{n\_iter}: \xmlDesc{integer}, 
      Maximum number of iterations.
  \default{300}

    \item \xmlNode{tol}: \xmlDesc{float}, 
      Tolerance for stopping criterion
  \default{0.001}

    \item \xmlNode{alpha\_1}: \xmlDesc{float}, 
      Hyper-parameter : shape parameter for the Gamma
      distribution prior over the alpha parameter.
  \default{1e-06}

    \item \xmlNode{alpha\_2}: \xmlDesc{float}, 
      Hyper-parameter : inverse scale parameter (rate parameter)
      for the Gamma distribution prior over the alpha parameter.
  \default{1e-06}

    \item \xmlNode{lambda\_1}: \xmlDesc{float}, 
      Hyper-parameter : shape parameter for the Gamma distribution
      prior over the lambda parameter.
  \default{1e-06}

    \item \xmlNode{lambda\_2}: \xmlDesc{float}, 
      Hyper-parameter : inverse scale parameter (rate parameter) for
      the Gamma distribution prior over the lambda parameter.
  \default{1e-06}

    \item \xmlNode{alpha\_init}: \xmlDesc{float}, 
      Initial value for alpha (precision of the noise).
      If not set, alpha\_init is $1/Var(y)$.
  \default{None}

    \item \xmlNode{lambda\_init}: \xmlDesc{float}, 
      Initial value for lambda (precision of the weights).
  \default{1.0}

    \item \xmlNode{compute\_score}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      If True, compute the objective function at each step of the
      model.
  \default{False}

    \item \xmlNode{fit\_intercept}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Whether to calculate the intercept for this model. Specifies if a constant (a.k.a. bias or
      intercept)                                                   should be added to the decision
      function.
  \default{True}

    \item \xmlNode{normalize}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      This parameter is ignored when fit\_intercept is set to False. If True,
      the regressors X will be normalized before regression by subtracting the mean and
      dividing by the l2-norm.
  \default{False}

    \item \xmlNode{verbose}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Verbose mode when fitting the model.
  \default{False}
  \end{itemize}


\subsubsection{ElasticNet}
  The \xmlNode{ElasticNet} employs                         Linear regression with combined L1 and L2
  priors as regularizer.                         It minimizes the objective function:
  \begin{equation}                         1/(2*n\_{samples}) *||y - Xw||^2\_2+alpha*l1\_ratio*||w||\_1
  + 0.5 *alpha*(1 - l1\_ratio)*||w||^2\_2                         \end{equation}
  \zNormalizationNotPerformed{ElasticNet}

  The \xmlNode{ElasticNet} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{ElasticNet} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.
  \default{time}

    \item \xmlNode{featureSelection}:
      Apply feature selection algorithm

      The \xmlNode{featureSelection} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{RFE}:
          The \xmlString{RFE} (Recursive Feature Elimination) is a feature selection algorithm.
          Feature selection refers to techniques that select a subset of the most relevant features
          for a model (ROM).         Fewer features can allow ROMs to run more efficiently (less
          space or time complexity) and be more effective.         Indeed, some ROMs (machine
          learning algorithms) can be misled by irrelevant input features, resulting in worse
          predictive performance.         RFE is a wrapper-type feature selection algorithm. This
          means that a different ROM is given and used in the core of the         method,         is
          wrapped by RFE, and used to help select features.         \\RFE works by searching for a
          subset of features by starting with all features in the training dataset and successfully
          removing         features until the desired number remains.         This is achieved by
          fitting the given ROME used in the core of the model, ranking features by importance,
          discarding the least important features, and re-fitting the model. This process is
          repeated until a specified number of         features remains.         When the full model
          is created, a measure of variable importance is computed that ranks the predictors from
          most         important to least.         At each stage of the search, the least important
          predictors are iteratively eliminated prior to rebuilding the model.         Features are
          scored either using the ROM model (if the model provides a mean to compute feature
          importances) or by         using a statistical method.         \\In RAVEN the
          \xmlString{RFE} class refers to an augmentation of the basic algorithm, since it allows,
          optionally,         to perform the search on multiple groups of targets (separately) and
          then combine the results of the search in a         single set. In addition, when the RFE
          search is concluded, the user can request to identify the set of features         that
          bring to a minimization of the score (i.e. maximimization of the accuracy).         In
          addition, using the ``applyClusteringFiltering'' option, the algorithm can, using an
          hierarchal clustering algorithm,         identify highly correlated features to speed up
          the subsequential search.
          The \xmlNode{RFE} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{RFE} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{nFeaturesToSelect}: \xmlDesc{integer}, 
              Exact Number of features to select. If not inputted, ``nFeaturesToSelect'' will be set
              to $1/2$ of the features in the training dataset.
  \default{None}

            \item \xmlNode{maxNumberFeatures}: \xmlDesc{integer}, 
              Maximum Number of features to select, the algorithm will automatically determine the
              feature list to minimize a total score.
  \default{None}

            \item \xmlNode{onlyOutputScore}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              If maxNumberFeatures is on, only output score should beconsidered? Or, in case of
              particular models (e.g. DMDC), state variable space score should be considered as
              well.
  \default{False}

            \item \xmlNode{applyClusteringFiltering}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              Applying clustering correlation before RFE search? If true, an hierarchal clustering
              is applied on the feature         space aimed to remove features that are correlated
              before the actual RFE search is performed. This approach can stabilize and
              accelerate the process in case of large feature spaces (e.g > 500 features).
  \default{False}

            \item \xmlNode{applyCrossCorrelation}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              In case of subgroupping, should a cross correleation analysis should be performed
              cross sub-groups?         If it is activated, a cross correleation analysis is used to
              additionally filter the features selected for each         sub-groupping search.
  \default{False}

            \item \xmlNode{step}: \xmlDesc{float}, 
              If greater than or equal to 1, then step corresponds to the (integer) number
              of features to remove at each iteration. If within (0.0, 1.0), then step
              corresponds to the percentage (rounded down) of features to remove at         each
              iteration.
  \default{1}

            \item \xmlNode{subGroup}: \xmlDesc{comma-separated strings, integers, and floats}, 
              Subgroup of output variables on which to perform the search. Multiple nodes of this
              type can be inputted. The RFE search will be then performed in each ``subgroup''
              separately and then the the union of the different feature sets are used for the final
              ROM.
          \end{itemize}

        \item \xmlNode{VarianceThreshold}:
          The \xmlString{VarianceThreshold} is a feature selector that removes     all low-variance
          features. This feature selection algorithm looks only at the features and not     the
          desired outputs. The variance threshold can be set by the user.
          The \xmlNode{VarianceThreshold} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{VarianceThreshold} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{threshold}: \xmlDesc{float}, 
              Features with a training-set variance lower than this threshold                   will
              be removed. The default is to keep all features with non-zero
              variance, i.e. remove the features that have the same value in all
              samples.
  \default{0.0}
          \end{itemize}
      \end{itemize}

    \item \xmlNode{featureSpaceTransformation}:
      Use dimensionality reduction technique to perform a trasformation of the training dataset
      into an uncorrelated one. The dimensionality of the problem will not be reduced but
      the data will be transformed in the transformed space. E.g if the number of features
      are 5, the method projects such features into a new uncorrelated space (still 5-dimensional).
      In case of time-dependent ROMs, all the samples are concatenated in a global 2D matrix
      (n\_samples*n\_timesteps,n\_features) before applying the transformation and then reconstructed
      back into the original shape (before fitting the model).

      The \xmlNode{featureSpaceTransformation} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{transformationMethod}: \xmlDesc{[PCA, KernelLinearPCA, KernelPolyPCA, KernelRbfPCA, KernelSigmoidPCA, KernelCosinePCA, ICA]}, 
          Transformation method to use. Eight options (5 Kernel PCAs) are available:
          \begin{itemize}                     \item \textit{PCA}, Principal Component Analysis;
          \item \textit{KernelLinearPCA}, Kernel (Linear) Principal component analysis;
          \item \textit{KernelPolyPCA}, Kernel (Poly) Principal component analysis;
          \item \textit{KernelRbfPCA}, Kernel(Rbf) Principal component analysis;
          \item \textit{KernelSigmoidPCA}, Kernel (Sigmoid) Principal component analysis;
          \item \textit{KernelCosinePCA}, Kernel (Cosine) Principal component analysis;
          \item \textit{ICA}, Independent component analysis;                    \end{itemize}
  \default{PCA}

        \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
          List of IDs of features/variables to include in the transformation process.
  \default{None}

        \item \xmlNode{whichSpace}: \xmlDesc{string}, 
          Which space to search? Target or Feature?
  \default{Feature}
      \end{itemize}

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{tol}: \xmlDesc{float}, 
      Tolerance for stopping criterion
  \default{0.0001}

    \item \xmlNode{alpha}: \xmlDesc{float}, 
      specifies a constant                                                  that multiplies the
      penalty terms.                                                  $alpha = 0$ is equivalent to
      an ordinary least square, solved by the
      \textbf{LinearRegression} object.
  \default{1.0}

    \item \xmlNode{l1\_ratio}: \xmlDesc{float}, 
      specifies the                                                  ElasticNet mixing parameter,
      with $0 <= l1\_ratio <= 1$.                                                  For $l1\_ratio =
      0$ the penalty is an L2 penalty.                                                  For
      $l1\_ratio = 1$ it is an L1 penalty.                                                  For $0 <
      l1\_ratio < 1$, the penalty is a combination of L1 and L2.
  \default{0.5}

    \item \xmlNode{fit\_intercept}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Whether the intercept should be estimated or not. If False,
      the data is assumed to be already centered.
  \default{True}

    \item \xmlNode{precompute}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Whether to use a precomputed Gram matrix to speed up calculations.
      For sparse input this option is always True to preserve sparsity.
  \default{False}

    \item \xmlNode{max\_iter}: \xmlDesc{integer}, 
      The maximum number of iterations.
  \default{1000}

    \item \xmlNode{positive}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      When set to True, forces the coefficients to be positive.
  \default{True}

    \item \xmlNode{selection}: \xmlDesc{[cyclic, random]}, 
      If set to ``random'', a random coefficient is updated every iteration
      rather than looping over features sequentially by default. This (setting to `random'')
      often leads to significantly faster convergence especially when tol is higher than $1e-4$
  \default{cyclic}

    \item \xmlNode{normalize}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      This parameter is ignored when fit\_intercept is set to False. If True,
      the regressors X will be normalized before regression by subtracting the mean and
      dividing by the l2-norm.
  \default{False}

    \item \xmlNode{warm\_start}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      When set to True, reuse the solution of the previous call
      to fit as initialization, otherwise, just erase the previous solution.
  \default{False}
  \end{itemize}


\subsubsection{ElasticNetCV}
  The \xmlNode{ElasticNetCV} employs                         Linear regression with combined L1 and
  L2 priors as regularizer.                         This model is similar to the
  \xmlNode{ElasticNet}                         with the addition of an iterative fitting along a
  regularization path (via cross-validation).
  \zNormalizationNotPerformed{ElasticNetCV}

  The \xmlNode{ElasticNetCV} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{ElasticNetCV} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.
  \default{time}

    \item \xmlNode{featureSelection}:
      Apply feature selection algorithm

      The \xmlNode{featureSelection} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{RFE}:
          The \xmlString{RFE} (Recursive Feature Elimination) is a feature selection algorithm.
          Feature selection refers to techniques that select a subset of the most relevant features
          for a model (ROM).         Fewer features can allow ROMs to run more efficiently (less
          space or time complexity) and be more effective.         Indeed, some ROMs (machine
          learning algorithms) can be misled by irrelevant input features, resulting in worse
          predictive performance.         RFE is a wrapper-type feature selection algorithm. This
          means that a different ROM is given and used in the core of the         method,         is
          wrapped by RFE, and used to help select features.         \\RFE works by searching for a
          subset of features by starting with all features in the training dataset and successfully
          removing         features until the desired number remains.         This is achieved by
          fitting the given ROME used in the core of the model, ranking features by importance,
          discarding the least important features, and re-fitting the model. This process is
          repeated until a specified number of         features remains.         When the full model
          is created, a measure of variable importance is computed that ranks the predictors from
          most         important to least.         At each stage of the search, the least important
          predictors are iteratively eliminated prior to rebuilding the model.         Features are
          scored either using the ROM model (if the model provides a mean to compute feature
          importances) or by         using a statistical method.         \\In RAVEN the
          \xmlString{RFE} class refers to an augmentation of the basic algorithm, since it allows,
          optionally,         to perform the search on multiple groups of targets (separately) and
          then combine the results of the search in a         single set. In addition, when the RFE
          search is concluded, the user can request to identify the set of features         that
          bring to a minimization of the score (i.e. maximimization of the accuracy).         In
          addition, using the ``applyClusteringFiltering'' option, the algorithm can, using an
          hierarchal clustering algorithm,         identify highly correlated features to speed up
          the subsequential search.
          The \xmlNode{RFE} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{RFE} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{nFeaturesToSelect}: \xmlDesc{integer}, 
              Exact Number of features to select. If not inputted, ``nFeaturesToSelect'' will be set
              to $1/2$ of the features in the training dataset.
  \default{None}

            \item \xmlNode{maxNumberFeatures}: \xmlDesc{integer}, 
              Maximum Number of features to select, the algorithm will automatically determine the
              feature list to minimize a total score.
  \default{None}

            \item \xmlNode{onlyOutputScore}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              If maxNumberFeatures is on, only output score should beconsidered? Or, in case of
              particular models (e.g. DMDC), state variable space score should be considered as
              well.
  \default{False}

            \item \xmlNode{applyClusteringFiltering}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              Applying clustering correlation before RFE search? If true, an hierarchal clustering
              is applied on the feature         space aimed to remove features that are correlated
              before the actual RFE search is performed. This approach can stabilize and
              accelerate the process in case of large feature spaces (e.g > 500 features).
  \default{False}

            \item \xmlNode{applyCrossCorrelation}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              In case of subgroupping, should a cross correleation analysis should be performed
              cross sub-groups?         If it is activated, a cross correleation analysis is used to
              additionally filter the features selected for each         sub-groupping search.
  \default{False}

            \item \xmlNode{step}: \xmlDesc{float}, 
              If greater than or equal to 1, then step corresponds to the (integer) number
              of features to remove at each iteration. If within (0.0, 1.0), then step
              corresponds to the percentage (rounded down) of features to remove at         each
              iteration.
  \default{1}

            \item \xmlNode{subGroup}: \xmlDesc{comma-separated strings, integers, and floats}, 
              Subgroup of output variables on which to perform the search. Multiple nodes of this
              type can be inputted. The RFE search will be then performed in each ``subgroup''
              separately and then the the union of the different feature sets are used for the final
              ROM.
          \end{itemize}

        \item \xmlNode{VarianceThreshold}:
          The \xmlString{VarianceThreshold} is a feature selector that removes     all low-variance
          features. This feature selection algorithm looks only at the features and not     the
          desired outputs. The variance threshold can be set by the user.
          The \xmlNode{VarianceThreshold} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{VarianceThreshold} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{threshold}: \xmlDesc{float}, 
              Features with a training-set variance lower than this threshold                   will
              be removed. The default is to keep all features with non-zero
              variance, i.e. remove the features that have the same value in all
              samples.
  \default{0.0}
          \end{itemize}
      \end{itemize}

    \item \xmlNode{featureSpaceTransformation}:
      Use dimensionality reduction technique to perform a trasformation of the training dataset
      into an uncorrelated one. The dimensionality of the problem will not be reduced but
      the data will be transformed in the transformed space. E.g if the number of features
      are 5, the method projects such features into a new uncorrelated space (still 5-dimensional).
      In case of time-dependent ROMs, all the samples are concatenated in a global 2D matrix
      (n\_samples*n\_timesteps,n\_features) before applying the transformation and then reconstructed
      back into the original shape (before fitting the model).

      The \xmlNode{featureSpaceTransformation} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{transformationMethod}: \xmlDesc{[PCA, KernelLinearPCA, KernelPolyPCA, KernelRbfPCA, KernelSigmoidPCA, KernelCosinePCA, ICA]}, 
          Transformation method to use. Eight options (5 Kernel PCAs) are available:
          \begin{itemize}                     \item \textit{PCA}, Principal Component Analysis;
          \item \textit{KernelLinearPCA}, Kernel (Linear) Principal component analysis;
          \item \textit{KernelPolyPCA}, Kernel (Poly) Principal component analysis;
          \item \textit{KernelRbfPCA}, Kernel(Rbf) Principal component analysis;
          \item \textit{KernelSigmoidPCA}, Kernel (Sigmoid) Principal component analysis;
          \item \textit{KernelCosinePCA}, Kernel (Cosine) Principal component analysis;
          \item \textit{ICA}, Independent component analysis;                    \end{itemize}
  \default{PCA}

        \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
          List of IDs of features/variables to include in the transformation process.
  \default{None}

        \item \xmlNode{whichSpace}: \xmlDesc{string}, 
          Which space to search? Target or Feature?
  \default{Feature}
      \end{itemize}

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{tol}: \xmlDesc{float}, 
      Tolerance for stopping criterion
  \default{0.0001}

    \item \xmlNode{eps}: \xmlDesc{float}, 
      Length of the path. $eps=1e-3$ means that
      $alpha\_min / alpha\_max = 1e-3$.
  \default{0.001}

    \item \xmlNode{l1\_ratio}: \xmlDesc{float}, 
      specifies the                                                  float between 0 and 1 passed to
      ElasticNet (scaling between l1 and l2 penalties).
      For $l1\_ratio = 0$ the penalty is an L2 penalty. For $l1\_ratio = 1$ it is
      an L1 penalty. For $0 < l1\_ratio < 1$, the penalty is a combination of L1
      and L2 This parameter can be a list, in which case the different values
      are tested by cross-validation and the one giving the best prediction score
      is used. Note that a good choice of list of values for l1\_ratio is often to
      put more values close to 1 (i.e. Lasso) and less close to 0 (i.e. Ridge),
      as in $[.1, .5, .7, .9, .95, .99, 1]$.
  \default{0.5}

    \item \xmlNode{fit\_intercept}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Whether the intercept should be estimated or not. If False,
      the data is assumed to be already centered.
  \default{True}

    \item \xmlNode{precompute}: \xmlDesc{string}, 
      Whether to use a precomputed Gram matrix to speed up calculations.
      For sparse input this option is always True to preserve sparsity.
  \default{auto}

    \item \xmlNode{max\_iter}: \xmlDesc{integer}, 
      The maximum number of iterations.
  \default{1000}

    \item \xmlNode{cv}: \xmlDesc{integer}, 
      Determines the cross-validation splitting strategy.
      It specifies the number of folds.
  \default{None}

    \item \xmlNode{positive}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      When set to True, forces the coefficients to be positive.
  \default{True}

    \item \xmlNode{selection}: \xmlDesc{[cyclic, random]}, 
      If set to ``random'', a random coefficient is updated every iteration
      rather than looping over features sequentially by default. This (setting to `random'')
      often leads to significantly faster convergence especially when tol is higher than $1e-4$
  \default{cyclic}

    \item \xmlNode{normalize}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      This parameter is ignored when fit\_intercept is set to False. If True,
      the regressors X will be normalized before regression by subtracting the mean and
      dividing by the l2-norm.
  \default{False}

    \item \xmlNode{n\_alphas}: \xmlDesc{integer}, 
      Number of alphas along the regularization path,
      used for each l1\_ratio.
  \default{100}
  \end{itemize}


\subsubsection{Lars}
  The \xmlNode{Lars} (\textit{Least Angle Regression model})                         is a regression
  algorithm for high-dimensional data.                         The LARS algorithm provides a means
  of producing an estimate of which variables                         to include, as well as their
  coefficients, when a response variable is                         determined by a linear
  combination of a subset of potential covariates.
  \zNormalizationNotPerformed{Lars}

  The \xmlNode{Lars} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{Lars} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.
  \default{time}

    \item \xmlNode{featureSelection}:
      Apply feature selection algorithm

      The \xmlNode{featureSelection} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{RFE}:
          The \xmlString{RFE} (Recursive Feature Elimination) is a feature selection algorithm.
          Feature selection refers to techniques that select a subset of the most relevant features
          for a model (ROM).         Fewer features can allow ROMs to run more efficiently (less
          space or time complexity) and be more effective.         Indeed, some ROMs (machine
          learning algorithms) can be misled by irrelevant input features, resulting in worse
          predictive performance.         RFE is a wrapper-type feature selection algorithm. This
          means that a different ROM is given and used in the core of the         method,         is
          wrapped by RFE, and used to help select features.         \\RFE works by searching for a
          subset of features by starting with all features in the training dataset and successfully
          removing         features until the desired number remains.         This is achieved by
          fitting the given ROME used in the core of the model, ranking features by importance,
          discarding the least important features, and re-fitting the model. This process is
          repeated until a specified number of         features remains.         When the full model
          is created, a measure of variable importance is computed that ranks the predictors from
          most         important to least.         At each stage of the search, the least important
          predictors are iteratively eliminated prior to rebuilding the model.         Features are
          scored either using the ROM model (if the model provides a mean to compute feature
          importances) or by         using a statistical method.         \\In RAVEN the
          \xmlString{RFE} class refers to an augmentation of the basic algorithm, since it allows,
          optionally,         to perform the search on multiple groups of targets (separately) and
          then combine the results of the search in a         single set. In addition, when the RFE
          search is concluded, the user can request to identify the set of features         that
          bring to a minimization of the score (i.e. maximimization of the accuracy).         In
          addition, using the ``applyClusteringFiltering'' option, the algorithm can, using an
          hierarchal clustering algorithm,         identify highly correlated features to speed up
          the subsequential search.
          The \xmlNode{RFE} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{RFE} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{nFeaturesToSelect}: \xmlDesc{integer}, 
              Exact Number of features to select. If not inputted, ``nFeaturesToSelect'' will be set
              to $1/2$ of the features in the training dataset.
  \default{None}

            \item \xmlNode{maxNumberFeatures}: \xmlDesc{integer}, 
              Maximum Number of features to select, the algorithm will automatically determine the
              feature list to minimize a total score.
  \default{None}

            \item \xmlNode{onlyOutputScore}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              If maxNumberFeatures is on, only output score should beconsidered? Or, in case of
              particular models (e.g. DMDC), state variable space score should be considered as
              well.
  \default{False}

            \item \xmlNode{applyClusteringFiltering}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              Applying clustering correlation before RFE search? If true, an hierarchal clustering
              is applied on the feature         space aimed to remove features that are correlated
              before the actual RFE search is performed. This approach can stabilize and
              accelerate the process in case of large feature spaces (e.g > 500 features).
  \default{False}

            \item \xmlNode{applyCrossCorrelation}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              In case of subgroupping, should a cross correleation analysis should be performed
              cross sub-groups?         If it is activated, a cross correleation analysis is used to
              additionally filter the features selected for each         sub-groupping search.
  \default{False}

            \item \xmlNode{step}: \xmlDesc{float}, 
              If greater than or equal to 1, then step corresponds to the (integer) number
              of features to remove at each iteration. If within (0.0, 1.0), then step
              corresponds to the percentage (rounded down) of features to remove at         each
              iteration.
  \default{1}

            \item \xmlNode{subGroup}: \xmlDesc{comma-separated strings, integers, and floats}, 
              Subgroup of output variables on which to perform the search. Multiple nodes of this
              type can be inputted. The RFE search will be then performed in each ``subgroup''
              separately and then the the union of the different feature sets are used for the final
              ROM.
          \end{itemize}

        \item \xmlNode{VarianceThreshold}:
          The \xmlString{VarianceThreshold} is a feature selector that removes     all low-variance
          features. This feature selection algorithm looks only at the features and not     the
          desired outputs. The variance threshold can be set by the user.
          The \xmlNode{VarianceThreshold} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{VarianceThreshold} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{threshold}: \xmlDesc{float}, 
              Features with a training-set variance lower than this threshold                   will
              be removed. The default is to keep all features with non-zero
              variance, i.e. remove the features that have the same value in all
              samples.
  \default{0.0}
          \end{itemize}
      \end{itemize}

    \item \xmlNode{featureSpaceTransformation}:
      Use dimensionality reduction technique to perform a trasformation of the training dataset
      into an uncorrelated one. The dimensionality of the problem will not be reduced but
      the data will be transformed in the transformed space. E.g if the number of features
      are 5, the method projects such features into a new uncorrelated space (still 5-dimensional).
      In case of time-dependent ROMs, all the samples are concatenated in a global 2D matrix
      (n\_samples*n\_timesteps,n\_features) before applying the transformation and then reconstructed
      back into the original shape (before fitting the model).

      The \xmlNode{featureSpaceTransformation} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{transformationMethod}: \xmlDesc{[PCA, KernelLinearPCA, KernelPolyPCA, KernelRbfPCA, KernelSigmoidPCA, KernelCosinePCA, ICA]}, 
          Transformation method to use. Eight options (5 Kernel PCAs) are available:
          \begin{itemize}                     \item \textit{PCA}, Principal Component Analysis;
          \item \textit{KernelLinearPCA}, Kernel (Linear) Principal component analysis;
          \item \textit{KernelPolyPCA}, Kernel (Poly) Principal component analysis;
          \item \textit{KernelRbfPCA}, Kernel(Rbf) Principal component analysis;
          \item \textit{KernelSigmoidPCA}, Kernel (Sigmoid) Principal component analysis;
          \item \textit{KernelCosinePCA}, Kernel (Cosine) Principal component analysis;
          \item \textit{ICA}, Independent component analysis;                    \end{itemize}
  \default{PCA}

        \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
          List of IDs of features/variables to include in the transformation process.
  \default{None}

        \item \xmlNode{whichSpace}: \xmlDesc{string}, 
          Which space to search? Target or Feature?
  \default{Feature}
      \end{itemize}

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{eps}: \xmlDesc{float}, 
      The machine-precision regularization in the computation of the Cholesky
      diagonal factors. Increase this for very ill-conditioned systems. Unlike the tol
      parameter in some iterative optimization-based algorithms, this parameter does not
      control the tolerance of the optimization.
  \default{2.220446049250313e-16}

    \item \xmlNode{fit\_intercept}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Whether the intercept should be estimated or not. If False,
      the data is assumed to be already centered.
  \default{True}

    \item \xmlNode{precompute}: \xmlDesc{string}, 
      Whether to use a precomputed Gram matrix to speed up calculations.
      For sparse input this option is always True to preserve sparsity.
  \default{auto}

    \item \xmlNode{normalize}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      This parameter is ignored when fit\_intercept is set to False. If True,
      the regressors X will be normalized before regression by subtracting the mean and
      dividing by the l2-norm.
  \default{True}

    \item \xmlNode{n\_nonzero\_coefs}: \xmlDesc{integer}, 
      Target number of non-zero coefficients.
  \default{500}

    \item \xmlNode{verbose}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Sets the verbosity amount.
  \default{False}

    \item \xmlNode{fit\_path}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      If True the full path is stored in the coef\_path\_ attribute.
      If you compute the solution for a large problem or many targets,
      setting fit\_path to False will lead to a speedup, especially with a
      small alpha.
  \default{True}
  \end{itemize}


\subsubsection{LarsCV}
  The \xmlNode{LarsCV} is Cross-validated \textit{Least Angle Regression model} model
  is a regression algorithm for high-dimensional data.                         The LARS algorithm
  provides a means of producing an estimate of which variables                         to include,
  as well as their coefficients, when a response variable is                         determined by a
  linear combination of a subset of potential covariates.                         This method is an
  augmentation of the Lars method with the addition of cross-validation
  embedded tecniques.                         \zNormalizationNotPerformed{LarsCV}

  The \xmlNode{LarsCV} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{LarsCV} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.
  \default{time}

    \item \xmlNode{featureSelection}:
      Apply feature selection algorithm

      The \xmlNode{featureSelection} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{RFE}:
          The \xmlString{RFE} (Recursive Feature Elimination) is a feature selection algorithm.
          Feature selection refers to techniques that select a subset of the most relevant features
          for a model (ROM).         Fewer features can allow ROMs to run more efficiently (less
          space or time complexity) and be more effective.         Indeed, some ROMs (machine
          learning algorithms) can be misled by irrelevant input features, resulting in worse
          predictive performance.         RFE is a wrapper-type feature selection algorithm. This
          means that a different ROM is given and used in the core of the         method,         is
          wrapped by RFE, and used to help select features.         \\RFE works by searching for a
          subset of features by starting with all features in the training dataset and successfully
          removing         features until the desired number remains.         This is achieved by
          fitting the given ROME used in the core of the model, ranking features by importance,
          discarding the least important features, and re-fitting the model. This process is
          repeated until a specified number of         features remains.         When the full model
          is created, a measure of variable importance is computed that ranks the predictors from
          most         important to least.         At each stage of the search, the least important
          predictors are iteratively eliminated prior to rebuilding the model.         Features are
          scored either using the ROM model (if the model provides a mean to compute feature
          importances) or by         using a statistical method.         \\In RAVEN the
          \xmlString{RFE} class refers to an augmentation of the basic algorithm, since it allows,
          optionally,         to perform the search on multiple groups of targets (separately) and
          then combine the results of the search in a         single set. In addition, when the RFE
          search is concluded, the user can request to identify the set of features         that
          bring to a minimization of the score (i.e. maximimization of the accuracy).         In
          addition, using the ``applyClusteringFiltering'' option, the algorithm can, using an
          hierarchal clustering algorithm,         identify highly correlated features to speed up
          the subsequential search.
          The \xmlNode{RFE} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{RFE} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{nFeaturesToSelect}: \xmlDesc{integer}, 
              Exact Number of features to select. If not inputted, ``nFeaturesToSelect'' will be set
              to $1/2$ of the features in the training dataset.
  \default{None}

            \item \xmlNode{maxNumberFeatures}: \xmlDesc{integer}, 
              Maximum Number of features to select, the algorithm will automatically determine the
              feature list to minimize a total score.
  \default{None}

            \item \xmlNode{onlyOutputScore}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              If maxNumberFeatures is on, only output score should beconsidered? Or, in case of
              particular models (e.g. DMDC), state variable space score should be considered as
              well.
  \default{False}

            \item \xmlNode{applyClusteringFiltering}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              Applying clustering correlation before RFE search? If true, an hierarchal clustering
              is applied on the feature         space aimed to remove features that are correlated
              before the actual RFE search is performed. This approach can stabilize and
              accelerate the process in case of large feature spaces (e.g > 500 features).
  \default{False}

            \item \xmlNode{applyCrossCorrelation}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              In case of subgroupping, should a cross correleation analysis should be performed
              cross sub-groups?         If it is activated, a cross correleation analysis is used to
              additionally filter the features selected for each         sub-groupping search.
  \default{False}

            \item \xmlNode{step}: \xmlDesc{float}, 
              If greater than or equal to 1, then step corresponds to the (integer) number
              of features to remove at each iteration. If within (0.0, 1.0), then step
              corresponds to the percentage (rounded down) of features to remove at         each
              iteration.
  \default{1}

            \item \xmlNode{subGroup}: \xmlDesc{comma-separated strings, integers, and floats}, 
              Subgroup of output variables on which to perform the search. Multiple nodes of this
              type can be inputted. The RFE search will be then performed in each ``subgroup''
              separately and then the the union of the different feature sets are used for the final
              ROM.
          \end{itemize}

        \item \xmlNode{VarianceThreshold}:
          The \xmlString{VarianceThreshold} is a feature selector that removes     all low-variance
          features. This feature selection algorithm looks only at the features and not     the
          desired outputs. The variance threshold can be set by the user.
          The \xmlNode{VarianceThreshold} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{VarianceThreshold} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{threshold}: \xmlDesc{float}, 
              Features with a training-set variance lower than this threshold                   will
              be removed. The default is to keep all features with non-zero
              variance, i.e. remove the features that have the same value in all
              samples.
  \default{0.0}
          \end{itemize}
      \end{itemize}

    \item \xmlNode{featureSpaceTransformation}:
      Use dimensionality reduction technique to perform a trasformation of the training dataset
      into an uncorrelated one. The dimensionality of the problem will not be reduced but
      the data will be transformed in the transformed space. E.g if the number of features
      are 5, the method projects such features into a new uncorrelated space (still 5-dimensional).
      In case of time-dependent ROMs, all the samples are concatenated in a global 2D matrix
      (n\_samples*n\_timesteps,n\_features) before applying the transformation and then reconstructed
      back into the original shape (before fitting the model).

      The \xmlNode{featureSpaceTransformation} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{transformationMethod}: \xmlDesc{[PCA, KernelLinearPCA, KernelPolyPCA, KernelRbfPCA, KernelSigmoidPCA, KernelCosinePCA, ICA]}, 
          Transformation method to use. Eight options (5 Kernel PCAs) are available:
          \begin{itemize}                     \item \textit{PCA}, Principal Component Analysis;
          \item \textit{KernelLinearPCA}, Kernel (Linear) Principal component analysis;
          \item \textit{KernelPolyPCA}, Kernel (Poly) Principal component analysis;
          \item \textit{KernelRbfPCA}, Kernel(Rbf) Principal component analysis;
          \item \textit{KernelSigmoidPCA}, Kernel (Sigmoid) Principal component analysis;
          \item \textit{KernelCosinePCA}, Kernel (Cosine) Principal component analysis;
          \item \textit{ICA}, Independent component analysis;                    \end{itemize}
  \default{PCA}

        \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
          List of IDs of features/variables to include in the transformation process.
  \default{None}

        \item \xmlNode{whichSpace}: \xmlDesc{string}, 
          Which space to search? Target or Feature?
  \default{Feature}
      \end{itemize}

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{eps}: \xmlDesc{float}, 
      The machine-precision regularization in the computation of the Cholesky
      diagonal factors. Increase this for very ill-conditioned systems. Unlike the tol
      parameter in some iterative optimization-based algorithms, this parameter does not
      control the tolerance of the optimization.
  \default{2.220446049250313e-16}

    \item \xmlNode{fit\_intercept}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Whether the intercept should be estimated or not. If False,
      the data is assumed to be already centered.
  \default{True}

    \item \xmlNode{precompute}: \xmlDesc{string}, 
      Whether to use a precomputed Gram matrix to speed up calculations.
      For sparse input this option is always True to preserve sparsity.
  \default{auto}

    \item \xmlNode{normalize}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      This parameter is ignored when fit\_intercept is set to False. If True,
      the regressors X will be normalized before regression by subtracting the mean and
      dividing by the l2-norm.
  \default{True}

    \item \xmlNode{max\_n\_alphas}: \xmlDesc{integer}, 
      The maximum number of points on the path used to compute the
      residuals in the cross-validation.
  \default{1000}

    \item \xmlNode{cv}: \xmlDesc{integer}, 
      Determines the cross-validation splitting strategy.
      It specifies the number of folds..
  \default{None}

    \item \xmlNode{verbose}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Sets the verbosity amount.
  \default{False}

    \item \xmlNode{max\_iter}: \xmlDesc{integer}, 
      Maximum number of iterations to perform.
  \default{500}
  \end{itemize}


\subsubsection{Lasso}
  The \xmlNode{Lasso} (\textit{Linear Model trained with L1 prior as regularizer})
  is an algorithm for regression problem                         It minimizes the usual sum of
  squared errors, with a bound on the sum of the                         absolute values of the
  coefficients:                         \begin{equation}                          (1 / (2 *
  n\_samples)) * ||y - Xw||^2\_2 + alpha * ||w||\_1                         \end{equation}
  \zNormalizationNotPerformed{Lasso}

  The \xmlNode{Lasso} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{Lasso} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.
  \default{time}

    \item \xmlNode{featureSelection}:
      Apply feature selection algorithm

      The \xmlNode{featureSelection} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{RFE}:
          The \xmlString{RFE} (Recursive Feature Elimination) is a feature selection algorithm.
          Feature selection refers to techniques that select a subset of the most relevant features
          for a model (ROM).         Fewer features can allow ROMs to run more efficiently (less
          space or time complexity) and be more effective.         Indeed, some ROMs (machine
          learning algorithms) can be misled by irrelevant input features, resulting in worse
          predictive performance.         RFE is a wrapper-type feature selection algorithm. This
          means that a different ROM is given and used in the core of the         method,         is
          wrapped by RFE, and used to help select features.         \\RFE works by searching for a
          subset of features by starting with all features in the training dataset and successfully
          removing         features until the desired number remains.         This is achieved by
          fitting the given ROME used in the core of the model, ranking features by importance,
          discarding the least important features, and re-fitting the model. This process is
          repeated until a specified number of         features remains.         When the full model
          is created, a measure of variable importance is computed that ranks the predictors from
          most         important to least.         At each stage of the search, the least important
          predictors are iteratively eliminated prior to rebuilding the model.         Features are
          scored either using the ROM model (if the model provides a mean to compute feature
          importances) or by         using a statistical method.         \\In RAVEN the
          \xmlString{RFE} class refers to an augmentation of the basic algorithm, since it allows,
          optionally,         to perform the search on multiple groups of targets (separately) and
          then combine the results of the search in a         single set. In addition, when the RFE
          search is concluded, the user can request to identify the set of features         that
          bring to a minimization of the score (i.e. maximimization of the accuracy).         In
          addition, using the ``applyClusteringFiltering'' option, the algorithm can, using an
          hierarchal clustering algorithm,         identify highly correlated features to speed up
          the subsequential search.
          The \xmlNode{RFE} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{RFE} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{nFeaturesToSelect}: \xmlDesc{integer}, 
              Exact Number of features to select. If not inputted, ``nFeaturesToSelect'' will be set
              to $1/2$ of the features in the training dataset.
  \default{None}

            \item \xmlNode{maxNumberFeatures}: \xmlDesc{integer}, 
              Maximum Number of features to select, the algorithm will automatically determine the
              feature list to minimize a total score.
  \default{None}

            \item \xmlNode{onlyOutputScore}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              If maxNumberFeatures is on, only output score should beconsidered? Or, in case of
              particular models (e.g. DMDC), state variable space score should be considered as
              well.
  \default{False}

            \item \xmlNode{applyClusteringFiltering}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              Applying clustering correlation before RFE search? If true, an hierarchal clustering
              is applied on the feature         space aimed to remove features that are correlated
              before the actual RFE search is performed. This approach can stabilize and
              accelerate the process in case of large feature spaces (e.g > 500 features).
  \default{False}

            \item \xmlNode{applyCrossCorrelation}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              In case of subgroupping, should a cross correleation analysis should be performed
              cross sub-groups?         If it is activated, a cross correleation analysis is used to
              additionally filter the features selected for each         sub-groupping search.
  \default{False}

            \item \xmlNode{step}: \xmlDesc{float}, 
              If greater than or equal to 1, then step corresponds to the (integer) number
              of features to remove at each iteration. If within (0.0, 1.0), then step
              corresponds to the percentage (rounded down) of features to remove at         each
              iteration.
  \default{1}

            \item \xmlNode{subGroup}: \xmlDesc{comma-separated strings, integers, and floats}, 
              Subgroup of output variables on which to perform the search. Multiple nodes of this
              type can be inputted. The RFE search will be then performed in each ``subgroup''
              separately and then the the union of the different feature sets are used for the final
              ROM.
          \end{itemize}

        \item \xmlNode{VarianceThreshold}:
          The \xmlString{VarianceThreshold} is a feature selector that removes     all low-variance
          features. This feature selection algorithm looks only at the features and not     the
          desired outputs. The variance threshold can be set by the user.
          The \xmlNode{VarianceThreshold} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{VarianceThreshold} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{threshold}: \xmlDesc{float}, 
              Features with a training-set variance lower than this threshold                   will
              be removed. The default is to keep all features with non-zero
              variance, i.e. remove the features that have the same value in all
              samples.
  \default{0.0}
          \end{itemize}
      \end{itemize}

    \item \xmlNode{featureSpaceTransformation}:
      Use dimensionality reduction technique to perform a trasformation of the training dataset
      into an uncorrelated one. The dimensionality of the problem will not be reduced but
      the data will be transformed in the transformed space. E.g if the number of features
      are 5, the method projects such features into a new uncorrelated space (still 5-dimensional).
      In case of time-dependent ROMs, all the samples are concatenated in a global 2D matrix
      (n\_samples*n\_timesteps,n\_features) before applying the transformation and then reconstructed
      back into the original shape (before fitting the model).

      The \xmlNode{featureSpaceTransformation} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{transformationMethod}: \xmlDesc{[PCA, KernelLinearPCA, KernelPolyPCA, KernelRbfPCA, KernelSigmoidPCA, KernelCosinePCA, ICA]}, 
          Transformation method to use. Eight options (5 Kernel PCAs) are available:
          \begin{itemize}                     \item \textit{PCA}, Principal Component Analysis;
          \item \textit{KernelLinearPCA}, Kernel (Linear) Principal component analysis;
          \item \textit{KernelPolyPCA}, Kernel (Poly) Principal component analysis;
          \item \textit{KernelRbfPCA}, Kernel(Rbf) Principal component analysis;
          \item \textit{KernelSigmoidPCA}, Kernel (Sigmoid) Principal component analysis;
          \item \textit{KernelCosinePCA}, Kernel (Cosine) Principal component analysis;
          \item \textit{ICA}, Independent component analysis;                    \end{itemize}
  \default{PCA}

        \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
          List of IDs of features/variables to include in the transformation process.
  \default{None}

        \item \xmlNode{whichSpace}: \xmlDesc{string}, 
          Which space to search? Target or Feature?
  \default{Feature}
      \end{itemize}

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{alpha}: \xmlDesc{float}, 
      Constant that multiplies the L1 term. Defaults to 1.0.
      $alpha = 0$ is equivalent to an ordinary least square, solved by
      the LinearRegression object. For numerical reasons, using $alpha = 0$
      with the Lasso object is not advised.
  \default{1.0}

    \item \xmlNode{tol}: \xmlDesc{float}, 
      The tolerance for the optimization: if the updates are smaller
      than tol, the optimization code checks the dual gap for optimality and
      continues until it is smaller than tol..
  \default{0.0001}

    \item \xmlNode{fit\_intercept}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Whether the intercept should be estimated or not. If False,
      the data is assumed to be already centered.
  \default{True}

    \item \xmlNode{precompute}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Whether to use a precomputed Gram matrix to speed up calculations.
      For sparse input this option is always True to preserve sparsity.
  \default{False}

    \item \xmlNode{normalize}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      This parameter is ignored when fit\_intercept is set to False. If True,
      the regressors X will be normalized before regression by subtracting the mean and
      dividing by the l2-norm.
  \default{False}

    \item \xmlNode{max\_iter}: \xmlDesc{integer}, 
      The maximum number of iterations.
  \default{1000}

    \item \xmlNode{positive}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      When set to True, forces the coefficients to be positive.
  \default{False}

    \item \xmlNode{selection}: \xmlDesc{[cyclic, random]}, 
      If set to ``random'', a random coefficient is updated every iteration
      rather than looping over features sequentially by default. This (setting to `random'')
      often leads to significantly faster convergence especially when tol is higher than $1e-4$
  \default{cyclic}

    \item \xmlNode{warm\_start}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      When set to True, reuse the solution of the previous call
      to fit as initialization, otherwise, just erase the previous solution.
  \default{False}
  \end{itemize}


\subsubsection{LassoCV}
  The \xmlNode{LassoCV} (\textit{Lasso linear model with iterative fitting along a regularization
  path})                         is an algorithm for regression problem. The best model is selected
  by cross-validation.                         It minimizes the usual sum of squared errors, with a
  bound on the sum of the                         absolute values of the coefficients:
  \begin{equation}                          (1 / (2 * n\_samples)) * ||y - Xw||^2\_2 + alpha *
  ||w||\_1                         \end{equation}
  \zNormalizationNotPerformed{LassoCV}

  The \xmlNode{LassoCV} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{LassoCV} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.
  \default{time}

    \item \xmlNode{featureSelection}:
      Apply feature selection algorithm

      The \xmlNode{featureSelection} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{RFE}:
          The \xmlString{RFE} (Recursive Feature Elimination) is a feature selection algorithm.
          Feature selection refers to techniques that select a subset of the most relevant features
          for a model (ROM).         Fewer features can allow ROMs to run more efficiently (less
          space or time complexity) and be more effective.         Indeed, some ROMs (machine
          learning algorithms) can be misled by irrelevant input features, resulting in worse
          predictive performance.         RFE is a wrapper-type feature selection algorithm. This
          means that a different ROM is given and used in the core of the         method,         is
          wrapped by RFE, and used to help select features.         \\RFE works by searching for a
          subset of features by starting with all features in the training dataset and successfully
          removing         features until the desired number remains.         This is achieved by
          fitting the given ROME used in the core of the model, ranking features by importance,
          discarding the least important features, and re-fitting the model. This process is
          repeated until a specified number of         features remains.         When the full model
          is created, a measure of variable importance is computed that ranks the predictors from
          most         important to least.         At each stage of the search, the least important
          predictors are iteratively eliminated prior to rebuilding the model.         Features are
          scored either using the ROM model (if the model provides a mean to compute feature
          importances) or by         using a statistical method.         \\In RAVEN the
          \xmlString{RFE} class refers to an augmentation of the basic algorithm, since it allows,
          optionally,         to perform the search on multiple groups of targets (separately) and
          then combine the results of the search in a         single set. In addition, when the RFE
          search is concluded, the user can request to identify the set of features         that
          bring to a minimization of the score (i.e. maximimization of the accuracy).         In
          addition, using the ``applyClusteringFiltering'' option, the algorithm can, using an
          hierarchal clustering algorithm,         identify highly correlated features to speed up
          the subsequential search.
          The \xmlNode{RFE} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{RFE} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{nFeaturesToSelect}: \xmlDesc{integer}, 
              Exact Number of features to select. If not inputted, ``nFeaturesToSelect'' will be set
              to $1/2$ of the features in the training dataset.
  \default{None}

            \item \xmlNode{maxNumberFeatures}: \xmlDesc{integer}, 
              Maximum Number of features to select, the algorithm will automatically determine the
              feature list to minimize a total score.
  \default{None}

            \item \xmlNode{onlyOutputScore}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              If maxNumberFeatures is on, only output score should beconsidered? Or, in case of
              particular models (e.g. DMDC), state variable space score should be considered as
              well.
  \default{False}

            \item \xmlNode{applyClusteringFiltering}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              Applying clustering correlation before RFE search? If true, an hierarchal clustering
              is applied on the feature         space aimed to remove features that are correlated
              before the actual RFE search is performed. This approach can stabilize and
              accelerate the process in case of large feature spaces (e.g > 500 features).
  \default{False}

            \item \xmlNode{applyCrossCorrelation}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              In case of subgroupping, should a cross correleation analysis should be performed
              cross sub-groups?         If it is activated, a cross correleation analysis is used to
              additionally filter the features selected for each         sub-groupping search.
  \default{False}

            \item \xmlNode{step}: \xmlDesc{float}, 
              If greater than or equal to 1, then step corresponds to the (integer) number
              of features to remove at each iteration. If within (0.0, 1.0), then step
              corresponds to the percentage (rounded down) of features to remove at         each
              iteration.
  \default{1}

            \item \xmlNode{subGroup}: \xmlDesc{comma-separated strings, integers, and floats}, 
              Subgroup of output variables on which to perform the search. Multiple nodes of this
              type can be inputted. The RFE search will be then performed in each ``subgroup''
              separately and then the the union of the different feature sets are used for the final
              ROM.
          \end{itemize}

        \item \xmlNode{VarianceThreshold}:
          The \xmlString{VarianceThreshold} is a feature selector that removes     all low-variance
          features. This feature selection algorithm looks only at the features and not     the
          desired outputs. The variance threshold can be set by the user.
          The \xmlNode{VarianceThreshold} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{VarianceThreshold} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{threshold}: \xmlDesc{float}, 
              Features with a training-set variance lower than this threshold                   will
              be removed. The default is to keep all features with non-zero
              variance, i.e. remove the features that have the same value in all
              samples.
  \default{0.0}
          \end{itemize}
      \end{itemize}

    \item \xmlNode{featureSpaceTransformation}:
      Use dimensionality reduction technique to perform a trasformation of the training dataset
      into an uncorrelated one. The dimensionality of the problem will not be reduced but
      the data will be transformed in the transformed space. E.g if the number of features
      are 5, the method projects such features into a new uncorrelated space (still 5-dimensional).
      In case of time-dependent ROMs, all the samples are concatenated in a global 2D matrix
      (n\_samples*n\_timesteps,n\_features) before applying the transformation and then reconstructed
      back into the original shape (before fitting the model).

      The \xmlNode{featureSpaceTransformation} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{transformationMethod}: \xmlDesc{[PCA, KernelLinearPCA, KernelPolyPCA, KernelRbfPCA, KernelSigmoidPCA, KernelCosinePCA, ICA]}, 
          Transformation method to use. Eight options (5 Kernel PCAs) are available:
          \begin{itemize}                     \item \textit{PCA}, Principal Component Analysis;
          \item \textit{KernelLinearPCA}, Kernel (Linear) Principal component analysis;
          \item \textit{KernelPolyPCA}, Kernel (Poly) Principal component analysis;
          \item \textit{KernelRbfPCA}, Kernel(Rbf) Principal component analysis;
          \item \textit{KernelSigmoidPCA}, Kernel (Sigmoid) Principal component analysis;
          \item \textit{KernelCosinePCA}, Kernel (Cosine) Principal component analysis;
          \item \textit{ICA}, Independent component analysis;                    \end{itemize}
  \default{PCA}

        \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
          List of IDs of features/variables to include in the transformation process.
  \default{None}

        \item \xmlNode{whichSpace}: \xmlDesc{string}, 
          Which space to search? Target or Feature?
  \default{Feature}
      \end{itemize}

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{tol}: \xmlDesc{float}, 
      Tolerance for stopping criterion
  \default{0.0001}

    \item \xmlNode{eps}: \xmlDesc{float}, 
      Length of the path. $eps=1e-3$ means that
      $alpha\_min / alpha\_max = 1e-3$.
  \default{0.001}

    \item \xmlNode{n\_alphas}: \xmlDesc{integer}, 
      The maximum number of iterations.
  \default{100}

    \item \xmlNode{fit\_intercept}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Whether the intercept should be estimated or not. If False,
      the data is assumed to be already centered.
  \default{True}

    \item \xmlNode{normalize}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      This parameter is ignored when fit\_intercept is set to False. If True,
      the regressors X will be normalized before regression by subtracting the mean and
      dividing by the l2-norm.
  \default{False}

    \item \xmlNode{precompute}: \xmlDesc{string}, 
      Whether to use a precomputed Gram matrix to speed up calculations.
      For sparse input this option is always True to preserve sparsity.
  \default{auto}

    \item \xmlNode{max\_iter}: \xmlDesc{integer}, 
      The maximum number of iterations.
  \default{1000}

    \item \xmlNode{positive}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      When set to True, forces the coefficients to be positive.
  \default{False}

    \item \xmlNode{selection}: \xmlDesc{[cyclic, random]}, 
      If set to ``random'', a random coefficient is updated every iteration
      rather than looping over features sequentially by default. This (setting to `random'')
      often leads to significantly faster convergence especially when tol is higher than $1e-4$
  \default{cyclic}

    \item \xmlNode{cv}: \xmlDesc{integer}, 
      Determines the cross-validation splitting strategy.
      It specifies the number of folds..
  \default{None}

    \item \xmlNode{alphas}: \xmlDesc{comma-separated floats}, 
      List of alphas where to compute the models. If None alphas
      are set automatically.
  \default{None}

    \item \xmlNode{verbose}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Amount of verbosity.
  \default{False}
  \end{itemize}


\subsubsection{LassoLars}
  The \xmlNode{LassoLars} (\textit{Lasso model fit with Least Angle Regression})
  It is a Linear Model trained with an L1 prior as regularizer.                         The
  optimization objective for Lasso is:                         \begin{equation}
  (1 / (2 * n\_samples)) * ||y - Xw||^2\_2 + alpha * ||w||\_1                         \end{equation}
  \zNormalizationNotPerformed{LassoLars}

  The \xmlNode{LassoLars} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{LassoLars} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.
  \default{time}

    \item \xmlNode{featureSelection}:
      Apply feature selection algorithm

      The \xmlNode{featureSelection} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{RFE}:
          The \xmlString{RFE} (Recursive Feature Elimination) is a feature selection algorithm.
          Feature selection refers to techniques that select a subset of the most relevant features
          for a model (ROM).         Fewer features can allow ROMs to run more efficiently (less
          space or time complexity) and be more effective.         Indeed, some ROMs (machine
          learning algorithms) can be misled by irrelevant input features, resulting in worse
          predictive performance.         RFE is a wrapper-type feature selection algorithm. This
          means that a different ROM is given and used in the core of the         method,         is
          wrapped by RFE, and used to help select features.         \\RFE works by searching for a
          subset of features by starting with all features in the training dataset and successfully
          removing         features until the desired number remains.         This is achieved by
          fitting the given ROME used in the core of the model, ranking features by importance,
          discarding the least important features, and re-fitting the model. This process is
          repeated until a specified number of         features remains.         When the full model
          is created, a measure of variable importance is computed that ranks the predictors from
          most         important to least.         At each stage of the search, the least important
          predictors are iteratively eliminated prior to rebuilding the model.         Features are
          scored either using the ROM model (if the model provides a mean to compute feature
          importances) or by         using a statistical method.         \\In RAVEN the
          \xmlString{RFE} class refers to an augmentation of the basic algorithm, since it allows,
          optionally,         to perform the search on multiple groups of targets (separately) and
          then combine the results of the search in a         single set. In addition, when the RFE
          search is concluded, the user can request to identify the set of features         that
          bring to a minimization of the score (i.e. maximimization of the accuracy).         In
          addition, using the ``applyClusteringFiltering'' option, the algorithm can, using an
          hierarchal clustering algorithm,         identify highly correlated features to speed up
          the subsequential search.
          The \xmlNode{RFE} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{RFE} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{nFeaturesToSelect}: \xmlDesc{integer}, 
              Exact Number of features to select. If not inputted, ``nFeaturesToSelect'' will be set
              to $1/2$ of the features in the training dataset.
  \default{None}

            \item \xmlNode{maxNumberFeatures}: \xmlDesc{integer}, 
              Maximum Number of features to select, the algorithm will automatically determine the
              feature list to minimize a total score.
  \default{None}

            \item \xmlNode{onlyOutputScore}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              If maxNumberFeatures is on, only output score should beconsidered? Or, in case of
              particular models (e.g. DMDC), state variable space score should be considered as
              well.
  \default{False}

            \item \xmlNode{applyClusteringFiltering}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              Applying clustering correlation before RFE search? If true, an hierarchal clustering
              is applied on the feature         space aimed to remove features that are correlated
              before the actual RFE search is performed. This approach can stabilize and
              accelerate the process in case of large feature spaces (e.g > 500 features).
  \default{False}

            \item \xmlNode{applyCrossCorrelation}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              In case of subgroupping, should a cross correleation analysis should be performed
              cross sub-groups?         If it is activated, a cross correleation analysis is used to
              additionally filter the features selected for each         sub-groupping search.
  \default{False}

            \item \xmlNode{step}: \xmlDesc{float}, 
              If greater than or equal to 1, then step corresponds to the (integer) number
              of features to remove at each iteration. If within (0.0, 1.0), then step
              corresponds to the percentage (rounded down) of features to remove at         each
              iteration.
  \default{1}

            \item \xmlNode{subGroup}: \xmlDesc{comma-separated strings, integers, and floats}, 
              Subgroup of output variables on which to perform the search. Multiple nodes of this
              type can be inputted. The RFE search will be then performed in each ``subgroup''
              separately and then the the union of the different feature sets are used for the final
              ROM.
          \end{itemize}

        \item \xmlNode{VarianceThreshold}:
          The \xmlString{VarianceThreshold} is a feature selector that removes     all low-variance
          features. This feature selection algorithm looks only at the features and not     the
          desired outputs. The variance threshold can be set by the user.
          The \xmlNode{VarianceThreshold} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{VarianceThreshold} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{threshold}: \xmlDesc{float}, 
              Features with a training-set variance lower than this threshold                   will
              be removed. The default is to keep all features with non-zero
              variance, i.e. remove the features that have the same value in all
              samples.
  \default{0.0}
          \end{itemize}
      \end{itemize}

    \item \xmlNode{featureSpaceTransformation}:
      Use dimensionality reduction technique to perform a trasformation of the training dataset
      into an uncorrelated one. The dimensionality of the problem will not be reduced but
      the data will be transformed in the transformed space. E.g if the number of features
      are 5, the method projects such features into a new uncorrelated space (still 5-dimensional).
      In case of time-dependent ROMs, all the samples are concatenated in a global 2D matrix
      (n\_samples*n\_timesteps,n\_features) before applying the transformation and then reconstructed
      back into the original shape (before fitting the model).

      The \xmlNode{featureSpaceTransformation} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{transformationMethod}: \xmlDesc{[PCA, KernelLinearPCA, KernelPolyPCA, KernelRbfPCA, KernelSigmoidPCA, KernelCosinePCA, ICA]}, 
          Transformation method to use. Eight options (5 Kernel PCAs) are available:
          \begin{itemize}                     \item \textit{PCA}, Principal Component Analysis;
          \item \textit{KernelLinearPCA}, Kernel (Linear) Principal component analysis;
          \item \textit{KernelPolyPCA}, Kernel (Poly) Principal component analysis;
          \item \textit{KernelRbfPCA}, Kernel(Rbf) Principal component analysis;
          \item \textit{KernelSigmoidPCA}, Kernel (Sigmoid) Principal component analysis;
          \item \textit{KernelCosinePCA}, Kernel (Cosine) Principal component analysis;
          \item \textit{ICA}, Independent component analysis;                    \end{itemize}
  \default{PCA}

        \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
          List of IDs of features/variables to include in the transformation process.
  \default{None}

        \item \xmlNode{whichSpace}: \xmlDesc{string}, 
          Which space to search? Target or Feature?
  \default{Feature}
      \end{itemize}

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{alpha}: \xmlDesc{float}, 
      Constant that multiplies the L1 term. Defaults to 1.0.
      $alpha = 0$ is equivalent to an ordinary least square, solved by
      the LinearRegression object. For numerical reasons, using $alpha = 0$
      with the Lasso object is not advised.
  \default{1.0}

    \item \xmlNode{fit\_intercept}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Whether the intercept should be estimated or not. If False,
      the data is assumed to be already centered.
  \default{True}

    \item \xmlNode{normalize}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      This parameter is ignored when fit\_intercept is set to False. If True,
      the regressors X will be normalized before regression by subtracting the mean and
      dividing by the l2-norm.
  \default{False}

    \item \xmlNode{precompute}: \xmlDesc{string}, 
      Whether to use a precomputed Gram matrix to speed up calculations.
      For sparse input this option is always True to preserve sparsity.
  \default{auto}

    \item \xmlNode{max\_iter}: \xmlDesc{integer}, 
      The maximum number of iterations.
  \default{500}

    \item \xmlNode{eps}: \xmlDesc{float}, 
      The machine-precision regularization in the computation of the Cholesky
      diagonal factors. Increase this for very ill-conditioned systems. Unlike the tol
      parameter in some iterative optimization-based algorithms, this parameter does not
      control the tolerance of the optimization.
  \default{2.220446049250313e-16}

    \item \xmlNode{positive}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      When set to True, forces the coefficients to be positive.
  \default{False}

    \item \xmlNode{verbose}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Amount of verbosity.
  \default{False}
  \end{itemize}


\subsubsection{LassoLarsCV}
  The \xmlNode{LassoLarsCV} (\textit{Cross-validated Lasso model fit with Least Angle Regression})
  This model is an augomentation of the LassoLars model with the addition of
  cross validation tecniques.                         The optimization objective for Lasso is:
  \begin{equation}                          (1 / (2 * n\_samples)) * ||y - Xw||^2\_2 + alpha *
  ||w||\_1                         \end{equation}
  \zNormalizationNotPerformed{LassoLarsCV}

  The \xmlNode{LassoLarsCV} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{LassoLarsCV} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.
  \default{time}

    \item \xmlNode{featureSelection}:
      Apply feature selection algorithm

      The \xmlNode{featureSelection} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{RFE}:
          The \xmlString{RFE} (Recursive Feature Elimination) is a feature selection algorithm.
          Feature selection refers to techniques that select a subset of the most relevant features
          for a model (ROM).         Fewer features can allow ROMs to run more efficiently (less
          space or time complexity) and be more effective.         Indeed, some ROMs (machine
          learning algorithms) can be misled by irrelevant input features, resulting in worse
          predictive performance.         RFE is a wrapper-type feature selection algorithm. This
          means that a different ROM is given and used in the core of the         method,         is
          wrapped by RFE, and used to help select features.         \\RFE works by searching for a
          subset of features by starting with all features in the training dataset and successfully
          removing         features until the desired number remains.         This is achieved by
          fitting the given ROME used in the core of the model, ranking features by importance,
          discarding the least important features, and re-fitting the model. This process is
          repeated until a specified number of         features remains.         When the full model
          is created, a measure of variable importance is computed that ranks the predictors from
          most         important to least.         At each stage of the search, the least important
          predictors are iteratively eliminated prior to rebuilding the model.         Features are
          scored either using the ROM model (if the model provides a mean to compute feature
          importances) or by         using a statistical method.         \\In RAVEN the
          \xmlString{RFE} class refers to an augmentation of the basic algorithm, since it allows,
          optionally,         to perform the search on multiple groups of targets (separately) and
          then combine the results of the search in a         single set. In addition, when the RFE
          search is concluded, the user can request to identify the set of features         that
          bring to a minimization of the score (i.e. maximimization of the accuracy).         In
          addition, using the ``applyClusteringFiltering'' option, the algorithm can, using an
          hierarchal clustering algorithm,         identify highly correlated features to speed up
          the subsequential search.
          The \xmlNode{RFE} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{RFE} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{nFeaturesToSelect}: \xmlDesc{integer}, 
              Exact Number of features to select. If not inputted, ``nFeaturesToSelect'' will be set
              to $1/2$ of the features in the training dataset.
  \default{None}

            \item \xmlNode{maxNumberFeatures}: \xmlDesc{integer}, 
              Maximum Number of features to select, the algorithm will automatically determine the
              feature list to minimize a total score.
  \default{None}

            \item \xmlNode{onlyOutputScore}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              If maxNumberFeatures is on, only output score should beconsidered? Or, in case of
              particular models (e.g. DMDC), state variable space score should be considered as
              well.
  \default{False}

            \item \xmlNode{applyClusteringFiltering}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              Applying clustering correlation before RFE search? If true, an hierarchal clustering
              is applied on the feature         space aimed to remove features that are correlated
              before the actual RFE search is performed. This approach can stabilize and
              accelerate the process in case of large feature spaces (e.g > 500 features).
  \default{False}

            \item \xmlNode{applyCrossCorrelation}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              In case of subgroupping, should a cross correleation analysis should be performed
              cross sub-groups?         If it is activated, a cross correleation analysis is used to
              additionally filter the features selected for each         sub-groupping search.
  \default{False}

            \item \xmlNode{step}: \xmlDesc{float}, 
              If greater than or equal to 1, then step corresponds to the (integer) number
              of features to remove at each iteration. If within (0.0, 1.0), then step
              corresponds to the percentage (rounded down) of features to remove at         each
              iteration.
  \default{1}

            \item \xmlNode{subGroup}: \xmlDesc{comma-separated strings, integers, and floats}, 
              Subgroup of output variables on which to perform the search. Multiple nodes of this
              type can be inputted. The RFE search will be then performed in each ``subgroup''
              separately and then the the union of the different feature sets are used for the final
              ROM.
          \end{itemize}

        \item \xmlNode{VarianceThreshold}:
          The \xmlString{VarianceThreshold} is a feature selector that removes     all low-variance
          features. This feature selection algorithm looks only at the features and not     the
          desired outputs. The variance threshold can be set by the user.
          The \xmlNode{VarianceThreshold} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{VarianceThreshold} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{threshold}: \xmlDesc{float}, 
              Features with a training-set variance lower than this threshold                   will
              be removed. The default is to keep all features with non-zero
              variance, i.e. remove the features that have the same value in all
              samples.
  \default{0.0}
          \end{itemize}
      \end{itemize}

    \item \xmlNode{featureSpaceTransformation}:
      Use dimensionality reduction technique to perform a trasformation of the training dataset
      into an uncorrelated one. The dimensionality of the problem will not be reduced but
      the data will be transformed in the transformed space. E.g if the number of features
      are 5, the method projects such features into a new uncorrelated space (still 5-dimensional).
      In case of time-dependent ROMs, all the samples are concatenated in a global 2D matrix
      (n\_samples*n\_timesteps,n\_features) before applying the transformation and then reconstructed
      back into the original shape (before fitting the model).

      The \xmlNode{featureSpaceTransformation} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{transformationMethod}: \xmlDesc{[PCA, KernelLinearPCA, KernelPolyPCA, KernelRbfPCA, KernelSigmoidPCA, KernelCosinePCA, ICA]}, 
          Transformation method to use. Eight options (5 Kernel PCAs) are available:
          \begin{itemize}                     \item \textit{PCA}, Principal Component Analysis;
          \item \textit{KernelLinearPCA}, Kernel (Linear) Principal component analysis;
          \item \textit{KernelPolyPCA}, Kernel (Poly) Principal component analysis;
          \item \textit{KernelRbfPCA}, Kernel(Rbf) Principal component analysis;
          \item \textit{KernelSigmoidPCA}, Kernel (Sigmoid) Principal component analysis;
          \item \textit{KernelCosinePCA}, Kernel (Cosine) Principal component analysis;
          \item \textit{ICA}, Independent component analysis;                    \end{itemize}
  \default{PCA}

        \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
          List of IDs of features/variables to include in the transformation process.
  \default{None}

        \item \xmlNode{whichSpace}: \xmlDesc{string}, 
          Which space to search? Target or Feature?
  \default{Feature}
      \end{itemize}

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{fit\_intercept}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Whether the intercept should be estimated or not. If False,
      the data is assumed to be already centered.
  \default{True}

    \item \xmlNode{max\_iter}: \xmlDesc{integer}, 
      The maximum number of iterations.
  \default{500}

    \item \xmlNode{normalize}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      This parameter is ignored when fit\_intercept is set to False. If True,
      the regressors X will be normalized before regression by subtracting the mean and
      dividing by the l2-norm.
  \default{True}

    \item \xmlNode{precompute}: \xmlDesc{string}, 
      Whether to use a precomputed Gram matrix to speed up calculations.
      For sparse input this option is always True to preserve sparsity.
  \default{auto}

    \item \xmlNode{max\_n\_alphas}: \xmlDesc{integer}, 
      The maximum number of points on the path used to compute the residuals in
      the cross-validation
  \default{1000}

    \item \xmlNode{eps}: \xmlDesc{float}, 
      The machine-precision regularization in the computation of the Cholesky
      diagonal factors. Increase this for very ill-conditioned systems. Unlike the tol
      parameter in some iterative optimization-based algorithms, this parameter does not
      control the tolerance of the optimization.
  \default{2.220446049250313e-16}

    \item \xmlNode{positive}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      When set to True, forces the coefficients to be positive.
  \default{False}

    \item \xmlNode{cv}: \xmlDesc{integer}, 
      Determines the cross-validation splitting strategy.
      It specifies the number of folds..
  \default{None}

    \item \xmlNode{verbose}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Amount of verbosity.
  \default{False}
  \end{itemize}


\subsubsection{LassoLarsIC}
  The \xmlNode{LassoLarsIC} (\textit{Lasso model fit with Lars using BIC or AIC for model
  selection})                         is a Lasso model fit with Lars using BIC or AIC for model
  selection.                         The optimization objective for Lasso is:
  $(1 / (2 * n\_samples)) * ||y - Xw||^2\_2 + alpha * ||w||\_1$                         AIC is the
  Akaike information criterion and BIC is the Bayes Information criterion. Such criteria
  are useful to select the value of the regularization parameter by making a trade-off between the
  goodness of fit and the complexity of the model. A good model should explain well the data
  while being simple.                         \zNormalizationNotPerformed{LassoLarsIC}

  The \xmlNode{LassoLarsIC} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{LassoLarsIC} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.
  \default{time}

    \item \xmlNode{featureSelection}:
      Apply feature selection algorithm

      The \xmlNode{featureSelection} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{RFE}:
          The \xmlString{RFE} (Recursive Feature Elimination) is a feature selection algorithm.
          Feature selection refers to techniques that select a subset of the most relevant features
          for a model (ROM).         Fewer features can allow ROMs to run more efficiently (less
          space or time complexity) and be more effective.         Indeed, some ROMs (machine
          learning algorithms) can be misled by irrelevant input features, resulting in worse
          predictive performance.         RFE is a wrapper-type feature selection algorithm. This
          means that a different ROM is given and used in the core of the         method,         is
          wrapped by RFE, and used to help select features.         \\RFE works by searching for a
          subset of features by starting with all features in the training dataset and successfully
          removing         features until the desired number remains.         This is achieved by
          fitting the given ROME used in the core of the model, ranking features by importance,
          discarding the least important features, and re-fitting the model. This process is
          repeated until a specified number of         features remains.         When the full model
          is created, a measure of variable importance is computed that ranks the predictors from
          most         important to least.         At each stage of the search, the least important
          predictors are iteratively eliminated prior to rebuilding the model.         Features are
          scored either using the ROM model (if the model provides a mean to compute feature
          importances) or by         using a statistical method.         \\In RAVEN the
          \xmlString{RFE} class refers to an augmentation of the basic algorithm, since it allows,
          optionally,         to perform the search on multiple groups of targets (separately) and
          then combine the results of the search in a         single set. In addition, when the RFE
          search is concluded, the user can request to identify the set of features         that
          bring to a minimization of the score (i.e. maximimization of the accuracy).         In
          addition, using the ``applyClusteringFiltering'' option, the algorithm can, using an
          hierarchal clustering algorithm,         identify highly correlated features to speed up
          the subsequential search.
          The \xmlNode{RFE} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{RFE} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{nFeaturesToSelect}: \xmlDesc{integer}, 
              Exact Number of features to select. If not inputted, ``nFeaturesToSelect'' will be set
              to $1/2$ of the features in the training dataset.
  \default{None}

            \item \xmlNode{maxNumberFeatures}: \xmlDesc{integer}, 
              Maximum Number of features to select, the algorithm will automatically determine the
              feature list to minimize a total score.
  \default{None}

            \item \xmlNode{onlyOutputScore}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              If maxNumberFeatures is on, only output score should beconsidered? Or, in case of
              particular models (e.g. DMDC), state variable space score should be considered as
              well.
  \default{False}

            \item \xmlNode{applyClusteringFiltering}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              Applying clustering correlation before RFE search? If true, an hierarchal clustering
              is applied on the feature         space aimed to remove features that are correlated
              before the actual RFE search is performed. This approach can stabilize and
              accelerate the process in case of large feature spaces (e.g > 500 features).
  \default{False}

            \item \xmlNode{applyCrossCorrelation}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              In case of subgroupping, should a cross correleation analysis should be performed
              cross sub-groups?         If it is activated, a cross correleation analysis is used to
              additionally filter the features selected for each         sub-groupping search.
  \default{False}

            \item \xmlNode{step}: \xmlDesc{float}, 
              If greater than or equal to 1, then step corresponds to the (integer) number
              of features to remove at each iteration. If within (0.0, 1.0), then step
              corresponds to the percentage (rounded down) of features to remove at         each
              iteration.
  \default{1}

            \item \xmlNode{subGroup}: \xmlDesc{comma-separated strings, integers, and floats}, 
              Subgroup of output variables on which to perform the search. Multiple nodes of this
              type can be inputted. The RFE search will be then performed in each ``subgroup''
              separately and then the the union of the different feature sets are used for the final
              ROM.
          \end{itemize}

        \item \xmlNode{VarianceThreshold}:
          The \xmlString{VarianceThreshold} is a feature selector that removes     all low-variance
          features. This feature selection algorithm looks only at the features and not     the
          desired outputs. The variance threshold can be set by the user.
          The \xmlNode{VarianceThreshold} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{VarianceThreshold} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{threshold}: \xmlDesc{float}, 
              Features with a training-set variance lower than this threshold                   will
              be removed. The default is to keep all features with non-zero
              variance, i.e. remove the features that have the same value in all
              samples.
  \default{0.0}
          \end{itemize}
      \end{itemize}

    \item \xmlNode{featureSpaceTransformation}:
      Use dimensionality reduction technique to perform a trasformation of the training dataset
      into an uncorrelated one. The dimensionality of the problem will not be reduced but
      the data will be transformed in the transformed space. E.g if the number of features
      are 5, the method projects such features into a new uncorrelated space (still 5-dimensional).
      In case of time-dependent ROMs, all the samples are concatenated in a global 2D matrix
      (n\_samples*n\_timesteps,n\_features) before applying the transformation and then reconstructed
      back into the original shape (before fitting the model).

      The \xmlNode{featureSpaceTransformation} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{transformationMethod}: \xmlDesc{[PCA, KernelLinearPCA, KernelPolyPCA, KernelRbfPCA, KernelSigmoidPCA, KernelCosinePCA, ICA]}, 
          Transformation method to use. Eight options (5 Kernel PCAs) are available:
          \begin{itemize}                     \item \textit{PCA}, Principal Component Analysis;
          \item \textit{KernelLinearPCA}, Kernel (Linear) Principal component analysis;
          \item \textit{KernelPolyPCA}, Kernel (Poly) Principal component analysis;
          \item \textit{KernelRbfPCA}, Kernel(Rbf) Principal component analysis;
          \item \textit{KernelSigmoidPCA}, Kernel (Sigmoid) Principal component analysis;
          \item \textit{KernelCosinePCA}, Kernel (Cosine) Principal component analysis;
          \item \textit{ICA}, Independent component analysis;                    \end{itemize}
  \default{PCA}

        \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
          List of IDs of features/variables to include in the transformation process.
  \default{None}

        \item \xmlNode{whichSpace}: \xmlDesc{string}, 
          Which space to search? Target or Feature?
  \default{Feature}
      \end{itemize}

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{criterion}: \xmlDesc{[bic, aic]}, 
      The type of criterion to use.
  \default{aic}

    \item \xmlNode{fit\_intercept}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Whether the intercept should be estimated or not. If False,
      the data is assumed to be already centered.
  \default{True}

    \item \xmlNode{normalize}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      This parameter is ignored when fit\_intercept is set to False. If True,
      the regressors X will be normalized before regression by subtracting the mean and
      dividing by the l2-norm.
  \default{True}

    \item \xmlNode{max\_iter}: \xmlDesc{integer}, 
      The maximum number of iterations.
  \default{500}

    \item \xmlNode{precompute}: \xmlDesc{string}, 
      Whether to use a precomputed Gram matrix to speed up calculations.
      For sparse input this option is always True to preserve sparsity.
  \default{auto}

    \item \xmlNode{eps}: \xmlDesc{float}, 
      The machine-precision regularization in the computation of the Cholesky
      diagonal factors. Increase this for very ill-conditioned systems. Unlike the tol
      parameter in some iterative optimization-based algorithms, this parameter does not
      control the tolerance of the optimization.
  \default{2.220446049250313e-16}

    \item \xmlNode{positive}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      When set to True, forces the coefficients to be positive.
  \default{False}

    \item \xmlNode{verbose}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Amount of verbosity.
  \default{False}
  \end{itemize}


\subsubsection{LinearRegression}
  The \xmlNode{LinearRegression}                         is an Ordinary least squares Linear
  Regression.                         LinearRegression fits a linear model with coefficients $w =
  (w1, …, wp)$ to                         minimize the residual sum of squares between the observed
  targets in the                         dataset, and the targets predicted by the linear
  approximation.                         \zNormalizationNotPerformed{LinearRegression}

  The \xmlNode{LinearRegression} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{LinearRegression} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.
  \default{time}

    \item \xmlNode{featureSelection}:
      Apply feature selection algorithm

      The \xmlNode{featureSelection} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{RFE}:
          The \xmlString{RFE} (Recursive Feature Elimination) is a feature selection algorithm.
          Feature selection refers to techniques that select a subset of the most relevant features
          for a model (ROM).         Fewer features can allow ROMs to run more efficiently (less
          space or time complexity) and be more effective.         Indeed, some ROMs (machine
          learning algorithms) can be misled by irrelevant input features, resulting in worse
          predictive performance.         RFE is a wrapper-type feature selection algorithm. This
          means that a different ROM is given and used in the core of the         method,         is
          wrapped by RFE, and used to help select features.         \\RFE works by searching for a
          subset of features by starting with all features in the training dataset and successfully
          removing         features until the desired number remains.         This is achieved by
          fitting the given ROME used in the core of the model, ranking features by importance,
          discarding the least important features, and re-fitting the model. This process is
          repeated until a specified number of         features remains.         When the full model
          is created, a measure of variable importance is computed that ranks the predictors from
          most         important to least.         At each stage of the search, the least important
          predictors are iteratively eliminated prior to rebuilding the model.         Features are
          scored either using the ROM model (if the model provides a mean to compute feature
          importances) or by         using a statistical method.         \\In RAVEN the
          \xmlString{RFE} class refers to an augmentation of the basic algorithm, since it allows,
          optionally,         to perform the search on multiple groups of targets (separately) and
          then combine the results of the search in a         single set. In addition, when the RFE
          search is concluded, the user can request to identify the set of features         that
          bring to a minimization of the score (i.e. maximimization of the accuracy).         In
          addition, using the ``applyClusteringFiltering'' option, the algorithm can, using an
          hierarchal clustering algorithm,         identify highly correlated features to speed up
          the subsequential search.
          The \xmlNode{RFE} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{RFE} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{nFeaturesToSelect}: \xmlDesc{integer}, 
              Exact Number of features to select. If not inputted, ``nFeaturesToSelect'' will be set
              to $1/2$ of the features in the training dataset.
  \default{None}

            \item \xmlNode{maxNumberFeatures}: \xmlDesc{integer}, 
              Maximum Number of features to select, the algorithm will automatically determine the
              feature list to minimize a total score.
  \default{None}

            \item \xmlNode{onlyOutputScore}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              If maxNumberFeatures is on, only output score should beconsidered? Or, in case of
              particular models (e.g. DMDC), state variable space score should be considered as
              well.
  \default{False}

            \item \xmlNode{applyClusteringFiltering}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              Applying clustering correlation before RFE search? If true, an hierarchal clustering
              is applied on the feature         space aimed to remove features that are correlated
              before the actual RFE search is performed. This approach can stabilize and
              accelerate the process in case of large feature spaces (e.g > 500 features).
  \default{False}

            \item \xmlNode{applyCrossCorrelation}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              In case of subgroupping, should a cross correleation analysis should be performed
              cross sub-groups?         If it is activated, a cross correleation analysis is used to
              additionally filter the features selected for each         sub-groupping search.
  \default{False}

            \item \xmlNode{step}: \xmlDesc{float}, 
              If greater than or equal to 1, then step corresponds to the (integer) number
              of features to remove at each iteration. If within (0.0, 1.0), then step
              corresponds to the percentage (rounded down) of features to remove at         each
              iteration.
  \default{1}

            \item \xmlNode{subGroup}: \xmlDesc{comma-separated strings, integers, and floats}, 
              Subgroup of output variables on which to perform the search. Multiple nodes of this
              type can be inputted. The RFE search will be then performed in each ``subgroup''
              separately and then the the union of the different feature sets are used for the final
              ROM.
          \end{itemize}

        \item \xmlNode{VarianceThreshold}:
          The \xmlString{VarianceThreshold} is a feature selector that removes     all low-variance
          features. This feature selection algorithm looks only at the features and not     the
          desired outputs. The variance threshold can be set by the user.
          The \xmlNode{VarianceThreshold} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{VarianceThreshold} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{threshold}: \xmlDesc{float}, 
              Features with a training-set variance lower than this threshold                   will
              be removed. The default is to keep all features with non-zero
              variance, i.e. remove the features that have the same value in all
              samples.
  \default{0.0}
          \end{itemize}
      \end{itemize}

    \item \xmlNode{featureSpaceTransformation}:
      Use dimensionality reduction technique to perform a trasformation of the training dataset
      into an uncorrelated one. The dimensionality of the problem will not be reduced but
      the data will be transformed in the transformed space. E.g if the number of features
      are 5, the method projects such features into a new uncorrelated space (still 5-dimensional).
      In case of time-dependent ROMs, all the samples are concatenated in a global 2D matrix
      (n\_samples*n\_timesteps,n\_features) before applying the transformation and then reconstructed
      back into the original shape (before fitting the model).

      The \xmlNode{featureSpaceTransformation} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{transformationMethod}: \xmlDesc{[PCA, KernelLinearPCA, KernelPolyPCA, KernelRbfPCA, KernelSigmoidPCA, KernelCosinePCA, ICA]}, 
          Transformation method to use. Eight options (5 Kernel PCAs) are available:
          \begin{itemize}                     \item \textit{PCA}, Principal Component Analysis;
          \item \textit{KernelLinearPCA}, Kernel (Linear) Principal component analysis;
          \item \textit{KernelPolyPCA}, Kernel (Poly) Principal component analysis;
          \item \textit{KernelRbfPCA}, Kernel(Rbf) Principal component analysis;
          \item \textit{KernelSigmoidPCA}, Kernel (Sigmoid) Principal component analysis;
          \item \textit{KernelCosinePCA}, Kernel (Cosine) Principal component analysis;
          \item \textit{ICA}, Independent component analysis;                    \end{itemize}
  \default{PCA}

        \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
          List of IDs of features/variables to include in the transformation process.
  \default{None}

        \item \xmlNode{whichSpace}: \xmlDesc{string}, 
          Which space to search? Target or Feature?
  \default{Feature}
      \end{itemize}

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{fit\_intercept}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Whether the intercept should be estimated or not. If False,
      the data is assumed to be already centered.
  \default{True}

    \item \xmlNode{normalize}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      This parameter is ignored when fit\_intercept is set to False. If True,
      the regressors X will be normalized before regression by subtracting the mean and
      dividing by the l2-norm.
  \default{False}
  \end{itemize}


\subsubsection{LogisticRegression}
  The \xmlNode{LogisticRegression}  is                             a logit, MaxEnt classifier.
  In the multiclass case, the training algorithm uses the one-vs-rest (OvR) scheme
  if the ``multi\_class'' option is set to ``ovr'', and uses the cross-entropy loss if the
  ``multi\_class'' option is set to ``multinomial''. (Currently the ``multinomial'' option
  is supported only by the ``lbfgs'', ``sag'', ``saga'' and ``newton-cg'' solvers.)
  This class implements regularized logistic regression using the ``liblinear'' library, ``newton-
  cg'',                             ``sag'', ``saga'' and ``lbfgs'' solvers. Regularization is
  applied by default. It can handle both dense and sparse input.                             The
  ``newton-cg'', ``sag'', and ``lbfgs'' solvers support only L2 regularization with primal
  formulation,                             or no regularization. The ``liblinear'' solver supports
  both L1 and L2 regularization, with a dual formulation                             only for the L2
  penalty. The Elastic-Net regularization is only supported by the ``saga'' solver.
  \zNormalizationPerformed{LogisticRegression}

  The \xmlNode{LogisticRegression} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{LogisticRegression} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.
  \default{time}

    \item \xmlNode{featureSelection}:
      Apply feature selection algorithm

      The \xmlNode{featureSelection} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{RFE}:
          The \xmlString{RFE} (Recursive Feature Elimination) is a feature selection algorithm.
          Feature selection refers to techniques that select a subset of the most relevant features
          for a model (ROM).         Fewer features can allow ROMs to run more efficiently (less
          space or time complexity) and be more effective.         Indeed, some ROMs (machine
          learning algorithms) can be misled by irrelevant input features, resulting in worse
          predictive performance.         RFE is a wrapper-type feature selection algorithm. This
          means that a different ROM is given and used in the core of the         method,         is
          wrapped by RFE, and used to help select features.         \\RFE works by searching for a
          subset of features by starting with all features in the training dataset and successfully
          removing         features until the desired number remains.         This is achieved by
          fitting the given ROME used in the core of the model, ranking features by importance,
          discarding the least important features, and re-fitting the model. This process is
          repeated until a specified number of         features remains.         When the full model
          is created, a measure of variable importance is computed that ranks the predictors from
          most         important to least.         At each stage of the search, the least important
          predictors are iteratively eliminated prior to rebuilding the model.         Features are
          scored either using the ROM model (if the model provides a mean to compute feature
          importances) or by         using a statistical method.         \\In RAVEN the
          \xmlString{RFE} class refers to an augmentation of the basic algorithm, since it allows,
          optionally,         to perform the search on multiple groups of targets (separately) and
          then combine the results of the search in a         single set. In addition, when the RFE
          search is concluded, the user can request to identify the set of features         that
          bring to a minimization of the score (i.e. maximimization of the accuracy).         In
          addition, using the ``applyClusteringFiltering'' option, the algorithm can, using an
          hierarchal clustering algorithm,         identify highly correlated features to speed up
          the subsequential search.
          The \xmlNode{RFE} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{RFE} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{nFeaturesToSelect}: \xmlDesc{integer}, 
              Exact Number of features to select. If not inputted, ``nFeaturesToSelect'' will be set
              to $1/2$ of the features in the training dataset.
  \default{None}

            \item \xmlNode{maxNumberFeatures}: \xmlDesc{integer}, 
              Maximum Number of features to select, the algorithm will automatically determine the
              feature list to minimize a total score.
  \default{None}

            \item \xmlNode{onlyOutputScore}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              If maxNumberFeatures is on, only output score should beconsidered? Or, in case of
              particular models (e.g. DMDC), state variable space score should be considered as
              well.
  \default{False}

            \item \xmlNode{applyClusteringFiltering}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              Applying clustering correlation before RFE search? If true, an hierarchal clustering
              is applied on the feature         space aimed to remove features that are correlated
              before the actual RFE search is performed. This approach can stabilize and
              accelerate the process in case of large feature spaces (e.g > 500 features).
  \default{False}

            \item \xmlNode{applyCrossCorrelation}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              In case of subgroupping, should a cross correleation analysis should be performed
              cross sub-groups?         If it is activated, a cross correleation analysis is used to
              additionally filter the features selected for each         sub-groupping search.
  \default{False}

            \item \xmlNode{step}: \xmlDesc{float}, 
              If greater than or equal to 1, then step corresponds to the (integer) number
              of features to remove at each iteration. If within (0.0, 1.0), then step
              corresponds to the percentage (rounded down) of features to remove at         each
              iteration.
  \default{1}

            \item \xmlNode{subGroup}: \xmlDesc{comma-separated strings, integers, and floats}, 
              Subgroup of output variables on which to perform the search. Multiple nodes of this
              type can be inputted. The RFE search will be then performed in each ``subgroup''
              separately and then the the union of the different feature sets are used for the final
              ROM.
          \end{itemize}

        \item \xmlNode{VarianceThreshold}:
          The \xmlString{VarianceThreshold} is a feature selector that removes     all low-variance
          features. This feature selection algorithm looks only at the features and not     the
          desired outputs. The variance threshold can be set by the user.
          The \xmlNode{VarianceThreshold} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{VarianceThreshold} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{threshold}: \xmlDesc{float}, 
              Features with a training-set variance lower than this threshold                   will
              be removed. The default is to keep all features with non-zero
              variance, i.e. remove the features that have the same value in all
              samples.
  \default{0.0}
          \end{itemize}
      \end{itemize}

    \item \xmlNode{featureSpaceTransformation}:
      Use dimensionality reduction technique to perform a trasformation of the training dataset
      into an uncorrelated one. The dimensionality of the problem will not be reduced but
      the data will be transformed in the transformed space. E.g if the number of features
      are 5, the method projects such features into a new uncorrelated space (still 5-dimensional).
      In case of time-dependent ROMs, all the samples are concatenated in a global 2D matrix
      (n\_samples*n\_timesteps,n\_features) before applying the transformation and then reconstructed
      back into the original shape (before fitting the model).

      The \xmlNode{featureSpaceTransformation} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{transformationMethod}: \xmlDesc{[PCA, KernelLinearPCA, KernelPolyPCA, KernelRbfPCA, KernelSigmoidPCA, KernelCosinePCA, ICA]}, 
          Transformation method to use. Eight options (5 Kernel PCAs) are available:
          \begin{itemize}                     \item \textit{PCA}, Principal Component Analysis;
          \item \textit{KernelLinearPCA}, Kernel (Linear) Principal component analysis;
          \item \textit{KernelPolyPCA}, Kernel (Poly) Principal component analysis;
          \item \textit{KernelRbfPCA}, Kernel(Rbf) Principal component analysis;
          \item \textit{KernelSigmoidPCA}, Kernel (Sigmoid) Principal component analysis;
          \item \textit{KernelCosinePCA}, Kernel (Cosine) Principal component analysis;
          \item \textit{ICA}, Independent component analysis;                    \end{itemize}
  \default{PCA}

        \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
          List of IDs of features/variables to include in the transformation process.
  \default{None}

        \item \xmlNode{whichSpace}: \xmlDesc{string}, 
          Which space to search? Target or Feature?
  \default{Feature}
      \end{itemize}

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{penalty}: \xmlDesc{[l1, l2, elasticnet, none]}, 
      Used to specify the norm used in the penalization. The newton-cg, sag and lbfgs solvers
      support only l2 penalties. elasticnet is only supported by the saga solver. If none (
      not supported by the liblinear solver), no regularization is applied.
  \default{l2}

    \item \xmlNode{dual}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Select the algorithm to either solve the dual or primal optimization problem.
      Prefer dual=False when $n\_samples > n\_features$.
  \default{True}

    \item \xmlNode{C}: \xmlDesc{float}, 
      Regularization parameter. The strength of the regularization is inversely
      proportional to C.Must be strictly positive.
  \default{1.0}

    \item \xmlNode{tol}: \xmlDesc{float}, 
      Tolerance for stopping criterion
  \default{0.0001}

    \item \xmlNode{fit\_intercept}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Whether to calculate the intercept for this model. Specifies if a constant (a.k.a. bias or
      intercept) should be added to the decision function.
  \default{True}

    \item \xmlNode{intercept\_scaling}: \xmlDesc{float}, 
      When fit\_intercept is True, instance vector x becomes $[x, intercept\_scaling]$,
      i.e. a “synthetic” feature with constant value equals to intercept\_scaling is appended
      to the instance vector. The intercept becomes $intercept\_scaling * synthetic\_feature\_weight$
      \nb the synthetic feature weight is subject to $l1/l2$ regularization as all other features.
      To lessen the effect of regularization on synthetic feature weight (and therefore on the
      intercept)                                                  $intercept\_scaling$ has to be
      increased.
  \default{1.0}

    \item \xmlNode{solver}: \xmlDesc{[newton-cg, lbfgs, liblinear, sag, saga]}, 
      Algorithm to use in the optimization problem.
      \begin{itemize}                                                    \item For small datasets,
      ``liblinear'' is a good choice, whereas ``sag'' and ``saga'' are faster for large ones.
      \item For multiclass problems, only ``newton-cg'', ``sag'', ``saga'' and ``lbfgs'' handle
      multinomial loss; `                                                    `liblinear'' is limited
      to one-versus-rest schemes.                                                    \item ``newton-
      cg'', ``lbfgs'', ``sag'' and ``saga'' handle L2 or no penalty
      \item ``liblinear'' and ``saga'' also handle L1 penalty
      \item ``saga'' also supports ``elasticnet'' penalty
      \item ``liblinear'' does not support setting penalty=``none''
      \end{itemize}
  \default{lbfgs}

    \item \xmlNode{max\_iter}: \xmlDesc{integer}, 
      Hard limit on iterations within solver.``-1'' for no limit
  \default{100}

    \item \xmlNode{multi\_class}: \xmlDesc{[auto, ovr, multinomial]}, 
      If the option chosen is ``ovr'', then a binary problem is fit for each label. For
      ``multinomial''                                                  the loss minimised is the
      multinomial loss fit across the entire probability distribution, even when the
      data is binary. ``multinomial' is unavailable when solver=``liblinear''. ``auto'' selects
      ``ovr'' if the data is                                                  binary, or if
      solver=``liblinear'', and otherwise selects ``multinomial''.
  \default{auto}

    \item \xmlNode{l1\_ratio}: \xmlDesc{float}, 
      The Elastic-Net mixing parameter, with $0 <= l1\_ratio <= 1$. Only used if
      penalty=``elasticnet''.                                                  Setting $l1\_ratio=0$
      is equivalent to using penalty=``l2'', while setting $l1\_ratio=1$ is equivalent to using
      $penalty=``l1''$. For $0 < l1\_ratio <1$, the penalty is a combination of L1 and L2.
  \default{0.5}

    \item \xmlNode{class\_weight}: \xmlDesc{[balanced]}, 
      If not given, all classes are supposed to have weight one.
      The “balanced” mode uses the values of y to automatically adjust weights
      inversely proportional to class frequencies in the input data
  \default{None}

    \item \xmlNode{random\_state}: \xmlDesc{integer}, 
      Used when solver == ‘sag’, ‘saga’ or ‘liblinear’ to shuffle the data.
  \default{None}
  \end{itemize}


\subsubsection{MultiTaskElasticNet}
  The \xmlNode{MultiTaskElasticNet} employs                         Linear regression with combined
  L1 and L2 priors as regularizer.                         The optimization objective for
  MultiTaskElasticNet is:                         $(1 / (2 * n\_samples)) * ||Y - XW||^{Fro}\_2
  + alpha * l1\_ratio * ||W||\_{21}                         + 0.5 * alpha * (1 - l1\_ratio) *
  ||W||\_{Fro}^2$                         \\Where:                         $||W||\_{21} = \sum\_i
  \sqrt{\sum\_j w\_{ij}^2}$                         i.e. the sum of norm of each row.
  \zNormalizationNotPerformed{MultiTaskElasticNet}

  The \xmlNode{MultiTaskElasticNet} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{MultiTaskElasticNet} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.
  \default{time}

    \item \xmlNode{featureSelection}:
      Apply feature selection algorithm

      The \xmlNode{featureSelection} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{RFE}:
          The \xmlString{RFE} (Recursive Feature Elimination) is a feature selection algorithm.
          Feature selection refers to techniques that select a subset of the most relevant features
          for a model (ROM).         Fewer features can allow ROMs to run more efficiently (less
          space or time complexity) and be more effective.         Indeed, some ROMs (machine
          learning algorithms) can be misled by irrelevant input features, resulting in worse
          predictive performance.         RFE is a wrapper-type feature selection algorithm. This
          means that a different ROM is given and used in the core of the         method,         is
          wrapped by RFE, and used to help select features.         \\RFE works by searching for a
          subset of features by starting with all features in the training dataset and successfully
          removing         features until the desired number remains.         This is achieved by
          fitting the given ROME used in the core of the model, ranking features by importance,
          discarding the least important features, and re-fitting the model. This process is
          repeated until a specified number of         features remains.         When the full model
          is created, a measure of variable importance is computed that ranks the predictors from
          most         important to least.         At each stage of the search, the least important
          predictors are iteratively eliminated prior to rebuilding the model.         Features are
          scored either using the ROM model (if the model provides a mean to compute feature
          importances) or by         using a statistical method.         \\In RAVEN the
          \xmlString{RFE} class refers to an augmentation of the basic algorithm, since it allows,
          optionally,         to perform the search on multiple groups of targets (separately) and
          then combine the results of the search in a         single set. In addition, when the RFE
          search is concluded, the user can request to identify the set of features         that
          bring to a minimization of the score (i.e. maximimization of the accuracy).         In
          addition, using the ``applyClusteringFiltering'' option, the algorithm can, using an
          hierarchal clustering algorithm,         identify highly correlated features to speed up
          the subsequential search.
          The \xmlNode{RFE} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{RFE} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{nFeaturesToSelect}: \xmlDesc{integer}, 
              Exact Number of features to select. If not inputted, ``nFeaturesToSelect'' will be set
              to $1/2$ of the features in the training dataset.
  \default{None}

            \item \xmlNode{maxNumberFeatures}: \xmlDesc{integer}, 
              Maximum Number of features to select, the algorithm will automatically determine the
              feature list to minimize a total score.
  \default{None}

            \item \xmlNode{onlyOutputScore}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              If maxNumberFeatures is on, only output score should beconsidered? Or, in case of
              particular models (e.g. DMDC), state variable space score should be considered as
              well.
  \default{False}

            \item \xmlNode{applyClusteringFiltering}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              Applying clustering correlation before RFE search? If true, an hierarchal clustering
              is applied on the feature         space aimed to remove features that are correlated
              before the actual RFE search is performed. This approach can stabilize and
              accelerate the process in case of large feature spaces (e.g > 500 features).
  \default{False}

            \item \xmlNode{applyCrossCorrelation}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              In case of subgroupping, should a cross correleation analysis should be performed
              cross sub-groups?         If it is activated, a cross correleation analysis is used to
              additionally filter the features selected for each         sub-groupping search.
  \default{False}

            \item \xmlNode{step}: \xmlDesc{float}, 
              If greater than or equal to 1, then step corresponds to the (integer) number
              of features to remove at each iteration. If within (0.0, 1.0), then step
              corresponds to the percentage (rounded down) of features to remove at         each
              iteration.
  \default{1}

            \item \xmlNode{subGroup}: \xmlDesc{comma-separated strings, integers, and floats}, 
              Subgroup of output variables on which to perform the search. Multiple nodes of this
              type can be inputted. The RFE search will be then performed in each ``subgroup''
              separately and then the the union of the different feature sets are used for the final
              ROM.
          \end{itemize}

        \item \xmlNode{VarianceThreshold}:
          The \xmlString{VarianceThreshold} is a feature selector that removes     all low-variance
          features. This feature selection algorithm looks only at the features and not     the
          desired outputs. The variance threshold can be set by the user.
          The \xmlNode{VarianceThreshold} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{VarianceThreshold} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{threshold}: \xmlDesc{float}, 
              Features with a training-set variance lower than this threshold                   will
              be removed. The default is to keep all features with non-zero
              variance, i.e. remove the features that have the same value in all
              samples.
  \default{0.0}
          \end{itemize}
      \end{itemize}

    \item \xmlNode{featureSpaceTransformation}:
      Use dimensionality reduction technique to perform a trasformation of the training dataset
      into an uncorrelated one. The dimensionality of the problem will not be reduced but
      the data will be transformed in the transformed space. E.g if the number of features
      are 5, the method projects such features into a new uncorrelated space (still 5-dimensional).
      In case of time-dependent ROMs, all the samples are concatenated in a global 2D matrix
      (n\_samples*n\_timesteps,n\_features) before applying the transformation and then reconstructed
      back into the original shape (before fitting the model).

      The \xmlNode{featureSpaceTransformation} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{transformationMethod}: \xmlDesc{[PCA, KernelLinearPCA, KernelPolyPCA, KernelRbfPCA, KernelSigmoidPCA, KernelCosinePCA, ICA]}, 
          Transformation method to use. Eight options (5 Kernel PCAs) are available:
          \begin{itemize}                     \item \textit{PCA}, Principal Component Analysis;
          \item \textit{KernelLinearPCA}, Kernel (Linear) Principal component analysis;
          \item \textit{KernelPolyPCA}, Kernel (Poly) Principal component analysis;
          \item \textit{KernelRbfPCA}, Kernel(Rbf) Principal component analysis;
          \item \textit{KernelSigmoidPCA}, Kernel (Sigmoid) Principal component analysis;
          \item \textit{KernelCosinePCA}, Kernel (Cosine) Principal component analysis;
          \item \textit{ICA}, Independent component analysis;                    \end{itemize}
  \default{PCA}

        \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
          List of IDs of features/variables to include in the transformation process.
  \default{None}

        \item \xmlNode{whichSpace}: \xmlDesc{string}, 
          Which space to search? Target or Feature?
  \default{Feature}
      \end{itemize}

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{tol}: \xmlDesc{float}, 
      Tolerance for stopping criterion
  \default{0.0001}

    \item \xmlNode{alpha}: \xmlDesc{float}, 
      specifies a constant                                                  that multiplies the
      penalty terms.                                                  $alpha = 0$ is equivalent to
      an ordinary least square, solved by the
      \textbf{LinearRegression} object.
  \default{1.0}

    \item \xmlNode{l1\_ratio}: \xmlDesc{float}, 
      specifies the                                                  ElasticNet mixing parameter,
      with $0 <= l1\_ratio <= 1$.                                                  For $l1\_ratio =
      0$ the penalty is an L2 penalty.                                                  For
      $l1\_ratio = 1$ it is an L1 penalty.                                                  For $0 <
      l1\_ratio < 1$, the penalty is a combination of L1 and L2.
  \default{0.5}

    \item \xmlNode{fit\_intercept}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Whether the intercept should be estimated or not. If False,
      the data is assumed to be already centered.
  \default{True}

    \item \xmlNode{max\_iter}: \xmlDesc{integer}, 
      The maximum number of iterations.
  \default{1000}

    \item \xmlNode{selection}: \xmlDesc{[cyclic, random]}, 
      If set to ``random'', a random coefficient is updated every iteration
      rather than looping over features sequentially by default. This (setting to `random'')
      often leads to significantly faster convergence especially when tol is higher than $1e-4$
  \default{cyclic}

    \item \xmlNode{normalize}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      This parameter is ignored when fit\_intercept is set to False. If True,
      the regressors X will be normalized before regression by subtracting the mean and
      dividing by the l2-norm.
  \default{False}

    \item \xmlNode{warm\_start}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      When set to True, reuse the solution of the previous call
      to fit as initialization, otherwise, just erase the previous solution.
  \default{False}
  \end{itemize}


\subsubsection{MultiTaskElasticNetCV}
  The \xmlNode{MultiTaskElasticNetCV} employs                         linear regression with
  combined L1 and L2 priors as regularizer.                         The optimization objective for
  MultiTaskElasticNet is:                         $(1 / (2 * n\_samples)) * ||Y - XW||^{Fro}\_2
  + alpha * l1\_ratio * ||W||\_{21}                         + 0.5 * alpha * (1 - l1\_ratio) *
  ||W||\_{Fro}^2$                         \\Where:                         $||W||\_{21} = \sum\_i
  \sqrt{\sum\_j w\_{ij}^2}$                         In this model, the cross-validation is embedded
  for the automatic selection                         of the best hyper-parameters.
  \zNormalizationNotPerformed{MultiTaskElasticNetCV}

  The \xmlNode{MultiTaskElasticNetCV} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{MultiTaskElasticNetCV} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.
  \default{time}

    \item \xmlNode{featureSelection}:
      Apply feature selection algorithm

      The \xmlNode{featureSelection} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{RFE}:
          The \xmlString{RFE} (Recursive Feature Elimination) is a feature selection algorithm.
          Feature selection refers to techniques that select a subset of the most relevant features
          for a model (ROM).         Fewer features can allow ROMs to run more efficiently (less
          space or time complexity) and be more effective.         Indeed, some ROMs (machine
          learning algorithms) can be misled by irrelevant input features, resulting in worse
          predictive performance.         RFE is a wrapper-type feature selection algorithm. This
          means that a different ROM is given and used in the core of the         method,         is
          wrapped by RFE, and used to help select features.         \\RFE works by searching for a
          subset of features by starting with all features in the training dataset and successfully
          removing         features until the desired number remains.         This is achieved by
          fitting the given ROME used in the core of the model, ranking features by importance,
          discarding the least important features, and re-fitting the model. This process is
          repeated until a specified number of         features remains.         When the full model
          is created, a measure of variable importance is computed that ranks the predictors from
          most         important to least.         At each stage of the search, the least important
          predictors are iteratively eliminated prior to rebuilding the model.         Features are
          scored either using the ROM model (if the model provides a mean to compute feature
          importances) or by         using a statistical method.         \\In RAVEN the
          \xmlString{RFE} class refers to an augmentation of the basic algorithm, since it allows,
          optionally,         to perform the search on multiple groups of targets (separately) and
          then combine the results of the search in a         single set. In addition, when the RFE
          search is concluded, the user can request to identify the set of features         that
          bring to a minimization of the score (i.e. maximimization of the accuracy).         In
          addition, using the ``applyClusteringFiltering'' option, the algorithm can, using an
          hierarchal clustering algorithm,         identify highly correlated features to speed up
          the subsequential search.
          The \xmlNode{RFE} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{RFE} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{nFeaturesToSelect}: \xmlDesc{integer}, 
              Exact Number of features to select. If not inputted, ``nFeaturesToSelect'' will be set
              to $1/2$ of the features in the training dataset.
  \default{None}

            \item \xmlNode{maxNumberFeatures}: \xmlDesc{integer}, 
              Maximum Number of features to select, the algorithm will automatically determine the
              feature list to minimize a total score.
  \default{None}

            \item \xmlNode{onlyOutputScore}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              If maxNumberFeatures is on, only output score should beconsidered? Or, in case of
              particular models (e.g. DMDC), state variable space score should be considered as
              well.
  \default{False}

            \item \xmlNode{applyClusteringFiltering}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              Applying clustering correlation before RFE search? If true, an hierarchal clustering
              is applied on the feature         space aimed to remove features that are correlated
              before the actual RFE search is performed. This approach can stabilize and
              accelerate the process in case of large feature spaces (e.g > 500 features).
  \default{False}

            \item \xmlNode{applyCrossCorrelation}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              In case of subgroupping, should a cross correleation analysis should be performed
              cross sub-groups?         If it is activated, a cross correleation analysis is used to
              additionally filter the features selected for each         sub-groupping search.
  \default{False}

            \item \xmlNode{step}: \xmlDesc{float}, 
              If greater than or equal to 1, then step corresponds to the (integer) number
              of features to remove at each iteration. If within (0.0, 1.0), then step
              corresponds to the percentage (rounded down) of features to remove at         each
              iteration.
  \default{1}

            \item \xmlNode{subGroup}: \xmlDesc{comma-separated strings, integers, and floats}, 
              Subgroup of output variables on which to perform the search. Multiple nodes of this
              type can be inputted. The RFE search will be then performed in each ``subgroup''
              separately and then the the union of the different feature sets are used for the final
              ROM.
          \end{itemize}

        \item \xmlNode{VarianceThreshold}:
          The \xmlString{VarianceThreshold} is a feature selector that removes     all low-variance
          features. This feature selection algorithm looks only at the features and not     the
          desired outputs. The variance threshold can be set by the user.
          The \xmlNode{VarianceThreshold} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{VarianceThreshold} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{threshold}: \xmlDesc{float}, 
              Features with a training-set variance lower than this threshold                   will
              be removed. The default is to keep all features with non-zero
              variance, i.e. remove the features that have the same value in all
              samples.
  \default{0.0}
          \end{itemize}
      \end{itemize}

    \item \xmlNode{featureSpaceTransformation}:
      Use dimensionality reduction technique to perform a trasformation of the training dataset
      into an uncorrelated one. The dimensionality of the problem will not be reduced but
      the data will be transformed in the transformed space. E.g if the number of features
      are 5, the method projects such features into a new uncorrelated space (still 5-dimensional).
      In case of time-dependent ROMs, all the samples are concatenated in a global 2D matrix
      (n\_samples*n\_timesteps,n\_features) before applying the transformation and then reconstructed
      back into the original shape (before fitting the model).

      The \xmlNode{featureSpaceTransformation} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{transformationMethod}: \xmlDesc{[PCA, KernelLinearPCA, KernelPolyPCA, KernelRbfPCA, KernelSigmoidPCA, KernelCosinePCA, ICA]}, 
          Transformation method to use. Eight options (5 Kernel PCAs) are available:
          \begin{itemize}                     \item \textit{PCA}, Principal Component Analysis;
          \item \textit{KernelLinearPCA}, Kernel (Linear) Principal component analysis;
          \item \textit{KernelPolyPCA}, Kernel (Poly) Principal component analysis;
          \item \textit{KernelRbfPCA}, Kernel(Rbf) Principal component analysis;
          \item \textit{KernelSigmoidPCA}, Kernel (Sigmoid) Principal component analysis;
          \item \textit{KernelCosinePCA}, Kernel (Cosine) Principal component analysis;
          \item \textit{ICA}, Independent component analysis;                    \end{itemize}
  \default{PCA}

        \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
          List of IDs of features/variables to include in the transformation process.
  \default{None}

        \item \xmlNode{whichSpace}: \xmlDesc{string}, 
          Which space to search? Target or Feature?
  \default{Feature}
      \end{itemize}

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{eps}: \xmlDesc{float}, 
      Length of the path. $eps=1e-3$ means that $alpha\_min / alpha\_max = 1e-3$.
  \default{0.001}

    \item \xmlNode{tol}: \xmlDesc{float}, 
      Tolerance for stopping criterion
  \default{0.0001}

    \item \xmlNode{n\_alpha}: \xmlDesc{integer}, 
      Number of alphas along the regularization path.
  \default{100}

    \item \xmlNode{l1\_ratio}: \xmlDesc{float}, 
      specifies the                                                  ElasticNet mixing parameter,
      with $0 <= l1\_ratio <= 1$.                                                  For $l1\_ratio =
      0$ the penalty is an L2 penalty.                                                  For
      $l1\_ratio = 1$ it is an L1 penalty.                                                  For $0 <
      l1\_ratio < 1$, the penalty is a combination of L1 and L2.
  \default{0.5}

    \item \xmlNode{fit\_intercept}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Whether the intercept should be estimated or not. If False,
      the data is assumed to be already centered.
  \default{True}

    \item \xmlNode{max\_iter}: \xmlDesc{integer}, 
      The maximum number of iterations.
  \default{1000}

    \item \xmlNode{selection}: \xmlDesc{[cyclic, random]}, 
      If set to ``random'', a random coefficient is updated every iteration
      rather than looping over features sequentially by default. This (setting to `random'')
      often leads to significantly faster convergence especially when tol is higher than $1e-4$
  \default{cyclic}

    \item \xmlNode{normalize}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      This parameter is ignored when fit\_intercept is set to False. If True,
      the regressors X will be normalized before regression by subtracting the mean and
      dividing by the l2-norm.
  \default{False}

    \item \xmlNode{cv}: \xmlDesc{integer}, 
      Determines the cross-validation splitting strategy.
      It specifies the number of folds..
  \default{5}
  \end{itemize}


\subsubsection{MultiTaskLasso}
  The \xmlNode{MultiTaskLasso} (\textit{Multi-task Lasso model trained                         with
  L1/L2 mixed-norm as regularizer}) is an algorithm for regression problem
  where the optimization objective for Lasso is:                         $(1 / (2 * n\_samples)) *
  ||Y - XW||^2\_{Fro} + alpha * ||W||\_{21}$                         \\Where:
  $||W||\_{21} = \sum\_i \sqrt{\sum\_j w\_{ij}^2}$                         i.e. the sum of norm of each
  row.                         \zNormalizationNotPerformed{MultiTaskLasso}

  The \xmlNode{MultiTaskLasso} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{MultiTaskLasso} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.
  \default{time}

    \item \xmlNode{featureSelection}:
      Apply feature selection algorithm

      The \xmlNode{featureSelection} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{RFE}:
          The \xmlString{RFE} (Recursive Feature Elimination) is a feature selection algorithm.
          Feature selection refers to techniques that select a subset of the most relevant features
          for a model (ROM).         Fewer features can allow ROMs to run more efficiently (less
          space or time complexity) and be more effective.         Indeed, some ROMs (machine
          learning algorithms) can be misled by irrelevant input features, resulting in worse
          predictive performance.         RFE is a wrapper-type feature selection algorithm. This
          means that a different ROM is given and used in the core of the         method,         is
          wrapped by RFE, and used to help select features.         \\RFE works by searching for a
          subset of features by starting with all features in the training dataset and successfully
          removing         features until the desired number remains.         This is achieved by
          fitting the given ROME used in the core of the model, ranking features by importance,
          discarding the least important features, and re-fitting the model. This process is
          repeated until a specified number of         features remains.         When the full model
          is created, a measure of variable importance is computed that ranks the predictors from
          most         important to least.         At each stage of the search, the least important
          predictors are iteratively eliminated prior to rebuilding the model.         Features are
          scored either using the ROM model (if the model provides a mean to compute feature
          importances) or by         using a statistical method.         \\In RAVEN the
          \xmlString{RFE} class refers to an augmentation of the basic algorithm, since it allows,
          optionally,         to perform the search on multiple groups of targets (separately) and
          then combine the results of the search in a         single set. In addition, when the RFE
          search is concluded, the user can request to identify the set of features         that
          bring to a minimization of the score (i.e. maximimization of the accuracy).         In
          addition, using the ``applyClusteringFiltering'' option, the algorithm can, using an
          hierarchal clustering algorithm,         identify highly correlated features to speed up
          the subsequential search.
          The \xmlNode{RFE} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{RFE} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{nFeaturesToSelect}: \xmlDesc{integer}, 
              Exact Number of features to select. If not inputted, ``nFeaturesToSelect'' will be set
              to $1/2$ of the features in the training dataset.
  \default{None}

            \item \xmlNode{maxNumberFeatures}: \xmlDesc{integer}, 
              Maximum Number of features to select, the algorithm will automatically determine the
              feature list to minimize a total score.
  \default{None}

            \item \xmlNode{onlyOutputScore}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              If maxNumberFeatures is on, only output score should beconsidered? Or, in case of
              particular models (e.g. DMDC), state variable space score should be considered as
              well.
  \default{False}

            \item \xmlNode{applyClusteringFiltering}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              Applying clustering correlation before RFE search? If true, an hierarchal clustering
              is applied on the feature         space aimed to remove features that are correlated
              before the actual RFE search is performed. This approach can stabilize and
              accelerate the process in case of large feature spaces (e.g > 500 features).
  \default{False}

            \item \xmlNode{applyCrossCorrelation}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              In case of subgroupping, should a cross correleation analysis should be performed
              cross sub-groups?         If it is activated, a cross correleation analysis is used to
              additionally filter the features selected for each         sub-groupping search.
  \default{False}

            \item \xmlNode{step}: \xmlDesc{float}, 
              If greater than or equal to 1, then step corresponds to the (integer) number
              of features to remove at each iteration. If within (0.0, 1.0), then step
              corresponds to the percentage (rounded down) of features to remove at         each
              iteration.
  \default{1}

            \item \xmlNode{subGroup}: \xmlDesc{comma-separated strings, integers, and floats}, 
              Subgroup of output variables on which to perform the search. Multiple nodes of this
              type can be inputted. The RFE search will be then performed in each ``subgroup''
              separately and then the the union of the different feature sets are used for the final
              ROM.
          \end{itemize}

        \item \xmlNode{VarianceThreshold}:
          The \xmlString{VarianceThreshold} is a feature selector that removes     all low-variance
          features. This feature selection algorithm looks only at the features and not     the
          desired outputs. The variance threshold can be set by the user.
          The \xmlNode{VarianceThreshold} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{VarianceThreshold} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{threshold}: \xmlDesc{float}, 
              Features with a training-set variance lower than this threshold                   will
              be removed. The default is to keep all features with non-zero
              variance, i.e. remove the features that have the same value in all
              samples.
  \default{0.0}
          \end{itemize}
      \end{itemize}

    \item \xmlNode{featureSpaceTransformation}:
      Use dimensionality reduction technique to perform a trasformation of the training dataset
      into an uncorrelated one. The dimensionality of the problem will not be reduced but
      the data will be transformed in the transformed space. E.g if the number of features
      are 5, the method projects such features into a new uncorrelated space (still 5-dimensional).
      In case of time-dependent ROMs, all the samples are concatenated in a global 2D matrix
      (n\_samples*n\_timesteps,n\_features) before applying the transformation and then reconstructed
      back into the original shape (before fitting the model).

      The \xmlNode{featureSpaceTransformation} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{transformationMethod}: \xmlDesc{[PCA, KernelLinearPCA, KernelPolyPCA, KernelRbfPCA, KernelSigmoidPCA, KernelCosinePCA, ICA]}, 
          Transformation method to use. Eight options (5 Kernel PCAs) are available:
          \begin{itemize}                     \item \textit{PCA}, Principal Component Analysis;
          \item \textit{KernelLinearPCA}, Kernel (Linear) Principal component analysis;
          \item \textit{KernelPolyPCA}, Kernel (Poly) Principal component analysis;
          \item \textit{KernelRbfPCA}, Kernel(Rbf) Principal component analysis;
          \item \textit{KernelSigmoidPCA}, Kernel (Sigmoid) Principal component analysis;
          \item \textit{KernelCosinePCA}, Kernel (Cosine) Principal component analysis;
          \item \textit{ICA}, Independent component analysis;                    \end{itemize}
  \default{PCA}

        \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
          List of IDs of features/variables to include in the transformation process.
  \default{None}

        \item \xmlNode{whichSpace}: \xmlDesc{string}, 
          Which space to search? Target or Feature?
  \default{Feature}
      \end{itemize}

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{alpha}: \xmlDesc{float}, 
      Constant that multiplies the L1 term. Defaults to 1.0.
      $alpha = 0$ is equivalent to an ordinary least square, solved by
      the LinearRegression object. For numerical reasons, using $alpha = 0$
      with the Lasso object is not advised.
  \default{1.0}

    \item \xmlNode{tol}: \xmlDesc{float}, 
      The tolerance for the optimization: if the updates are smaller
      than tol, the optimization code checks the dual gap for optimality and
      continues until it is smaller than tol..
  \default{0.0001}

    \item \xmlNode{fit\_intercept}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Whether the intercept should be estimated or not. If False,
      the data is assumed to be already centered.
  \default{True}

    \item \xmlNode{normalize}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      This parameter is ignored when fit\_intercept is set to False. If True,
      the regressors X will be normalized before regression by subtracting the mean and
      dividing by the l2-norm.
  \default{False}

    \item \xmlNode{max\_iter}: \xmlDesc{integer}, 
      The maximum number of iterations.
  \default{1000}

    \item \xmlNode{selection}: \xmlDesc{[cyclic, random]}, 
      If set to ``random'', a random coefficient is updated every iteration
      rather than looping over features sequentially by default. This setting
      often leads to significantly faster convergence especially when tol is higher than $1e-4$
  \default{cyclic}

    \item \xmlNode{warm\_start}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      When set to True, reuse the solution of the previous call
      to fit as initialization, otherwise, just erase the previous solution.
  \default{False}
  \end{itemize}


\subsubsection{MultiTaskLassoCV}
  The \xmlNode{MultiTaskLassoCV} (\textit{Multi-task Lasso model trained
  with L1/L2 mixed-norm as regularizer}) is an algorithm for regression problem
  where the optimization objective for Lasso is:                         $(1 / (2 * n\_samples)) *
  ||Y - XW||^2\_{Fro} + alpha * ||W||\_{21}$                         \\Where:
  $||W||\_{21} = \sum\_i \sqrt{\sum\_j w\_{ij}^2}$                         i.e. the sum of norm of each
  row.                         In this model, the cross-validation is embedded for the automatic
  selection                         of the best hyper-parameters.
  \zNormalizationNotPerformed{MultiTaskLassoCV}

  The \xmlNode{MultiTaskLassoCV} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{MultiTaskLassoCV} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.
  \default{time}

    \item \xmlNode{featureSelection}:
      Apply feature selection algorithm

      The \xmlNode{featureSelection} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{RFE}:
          The \xmlString{RFE} (Recursive Feature Elimination) is a feature selection algorithm.
          Feature selection refers to techniques that select a subset of the most relevant features
          for a model (ROM).         Fewer features can allow ROMs to run more efficiently (less
          space or time complexity) and be more effective.         Indeed, some ROMs (machine
          learning algorithms) can be misled by irrelevant input features, resulting in worse
          predictive performance.         RFE is a wrapper-type feature selection algorithm. This
          means that a different ROM is given and used in the core of the         method,         is
          wrapped by RFE, and used to help select features.         \\RFE works by searching for a
          subset of features by starting with all features in the training dataset and successfully
          removing         features until the desired number remains.         This is achieved by
          fitting the given ROME used in the core of the model, ranking features by importance,
          discarding the least important features, and re-fitting the model. This process is
          repeated until a specified number of         features remains.         When the full model
          is created, a measure of variable importance is computed that ranks the predictors from
          most         important to least.         At each stage of the search, the least important
          predictors are iteratively eliminated prior to rebuilding the model.         Features are
          scored either using the ROM model (if the model provides a mean to compute feature
          importances) or by         using a statistical method.         \\In RAVEN the
          \xmlString{RFE} class refers to an augmentation of the basic algorithm, since it allows,
          optionally,         to perform the search on multiple groups of targets (separately) and
          then combine the results of the search in a         single set. In addition, when the RFE
          search is concluded, the user can request to identify the set of features         that
          bring to a minimization of the score (i.e. maximimization of the accuracy).         In
          addition, using the ``applyClusteringFiltering'' option, the algorithm can, using an
          hierarchal clustering algorithm,         identify highly correlated features to speed up
          the subsequential search.
          The \xmlNode{RFE} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{RFE} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{nFeaturesToSelect}: \xmlDesc{integer}, 
              Exact Number of features to select. If not inputted, ``nFeaturesToSelect'' will be set
              to $1/2$ of the features in the training dataset.
  \default{None}

            \item \xmlNode{maxNumberFeatures}: \xmlDesc{integer}, 
              Maximum Number of features to select, the algorithm will automatically determine the
              feature list to minimize a total score.
  \default{None}

            \item \xmlNode{onlyOutputScore}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              If maxNumberFeatures is on, only output score should beconsidered? Or, in case of
              particular models (e.g. DMDC), state variable space score should be considered as
              well.
  \default{False}

            \item \xmlNode{applyClusteringFiltering}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              Applying clustering correlation before RFE search? If true, an hierarchal clustering
              is applied on the feature         space aimed to remove features that are correlated
              before the actual RFE search is performed. This approach can stabilize and
              accelerate the process in case of large feature spaces (e.g > 500 features).
  \default{False}

            \item \xmlNode{applyCrossCorrelation}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              In case of subgroupping, should a cross correleation analysis should be performed
              cross sub-groups?         If it is activated, a cross correleation analysis is used to
              additionally filter the features selected for each         sub-groupping search.
  \default{False}

            \item \xmlNode{step}: \xmlDesc{float}, 
              If greater than or equal to 1, then step corresponds to the (integer) number
              of features to remove at each iteration. If within (0.0, 1.0), then step
              corresponds to the percentage (rounded down) of features to remove at         each
              iteration.
  \default{1}

            \item \xmlNode{subGroup}: \xmlDesc{comma-separated strings, integers, and floats}, 
              Subgroup of output variables on which to perform the search. Multiple nodes of this
              type can be inputted. The RFE search will be then performed in each ``subgroup''
              separately and then the the union of the different feature sets are used for the final
              ROM.
          \end{itemize}

        \item \xmlNode{VarianceThreshold}:
          The \xmlString{VarianceThreshold} is a feature selector that removes     all low-variance
          features. This feature selection algorithm looks only at the features and not     the
          desired outputs. The variance threshold can be set by the user.
          The \xmlNode{VarianceThreshold} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{VarianceThreshold} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{threshold}: \xmlDesc{float}, 
              Features with a training-set variance lower than this threshold                   will
              be removed. The default is to keep all features with non-zero
              variance, i.e. remove the features that have the same value in all
              samples.
  \default{0.0}
          \end{itemize}
      \end{itemize}

    \item \xmlNode{featureSpaceTransformation}:
      Use dimensionality reduction technique to perform a trasformation of the training dataset
      into an uncorrelated one. The dimensionality of the problem will not be reduced but
      the data will be transformed in the transformed space. E.g if the number of features
      are 5, the method projects such features into a new uncorrelated space (still 5-dimensional).
      In case of time-dependent ROMs, all the samples are concatenated in a global 2D matrix
      (n\_samples*n\_timesteps,n\_features) before applying the transformation and then reconstructed
      back into the original shape (before fitting the model).

      The \xmlNode{featureSpaceTransformation} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{transformationMethod}: \xmlDesc{[PCA, KernelLinearPCA, KernelPolyPCA, KernelRbfPCA, KernelSigmoidPCA, KernelCosinePCA, ICA]}, 
          Transformation method to use. Eight options (5 Kernel PCAs) are available:
          \begin{itemize}                     \item \textit{PCA}, Principal Component Analysis;
          \item \textit{KernelLinearPCA}, Kernel (Linear) Principal component analysis;
          \item \textit{KernelPolyPCA}, Kernel (Poly) Principal component analysis;
          \item \textit{KernelRbfPCA}, Kernel(Rbf) Principal component analysis;
          \item \textit{KernelSigmoidPCA}, Kernel (Sigmoid) Principal component analysis;
          \item \textit{KernelCosinePCA}, Kernel (Cosine) Principal component analysis;
          \item \textit{ICA}, Independent component analysis;                    \end{itemize}
  \default{PCA}

        \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
          List of IDs of features/variables to include in the transformation process.
  \default{None}

        \item \xmlNode{whichSpace}: \xmlDesc{string}, 
          Which space to search? Target or Feature?
  \default{Feature}
      \end{itemize}

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{eps}: \xmlDesc{float}, 
      Length of the path. $eps=1e-3$ means that $alpha\_min / alpha\_max = 1e-3$.
  \default{0.001}

    \item \xmlNode{n\_alpha}: \xmlDesc{integer}, 
      Number of alphas along the regularization path.
  \default{100}

    \item \xmlNode{fit\_intercept}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Whether the intercept should be estimated or not. If False,
      the data is assumed to be already centered.
  \default{True}

    \item \xmlNode{normalize}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      This parameter is ignored when fit\_intercept is set to False. If True,
      the regressors X will be normalized before regression by subtracting the mean and
      dividing by the l2-norm.
  \default{False}

    \item \xmlNode{max\_iter}: \xmlDesc{integer}, 
      The maximum number of iterations.
  \default{1000}

    \item \xmlNode{tol}: \xmlDesc{float}, 
      Tolerance for stopping criterion
  \default{0.0001}

    \item \xmlNode{selection}: \xmlDesc{[cyclic, random]}, 
      If set to ``random'', a random coefficient is updated every iteration
      rather than looping over features sequentially by default. This (setting to `random'')
      often leads to significantly faster convergence especially when tol is higher than $1e-4$
  \default{cyclic}

    \item \xmlNode{cv}: \xmlDesc{integer}, 
      Determines the cross-validation splitting strategy.
      It specifies the number of folds..
  \default{5}
  \end{itemize}


\subsubsection{OrthogonalMatchingPursuit}
  The \xmlNode{OrthogonalMatchingPursuit}                         implements the OMP algorithm for
  approximating the fit of a                         linear model with constraints imposed on the
  number of non-zero                         coefficients (ie. the $\ell\_0$ pseudo-norm). OMP is
  based on a greedy                         algorithm that includes at each step the atom most
  highly correlated                         with the current residual. It is similar to the simpler
  matching                         pursuit (MP) method, but better in that at each iteration, the
  residual                         is recomputed using an orthogonal projection on the space of the
  previously chosen dictionary elements.
  \zNormalizationNotPerformed{OrthogonalMatchingPursuit}

  The \xmlNode{OrthogonalMatchingPursuit} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{OrthogonalMatchingPursuit} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.
  \default{time}

    \item \xmlNode{featureSelection}:
      Apply feature selection algorithm

      The \xmlNode{featureSelection} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{RFE}:
          The \xmlString{RFE} (Recursive Feature Elimination) is a feature selection algorithm.
          Feature selection refers to techniques that select a subset of the most relevant features
          for a model (ROM).         Fewer features can allow ROMs to run more efficiently (less
          space or time complexity) and be more effective.         Indeed, some ROMs (machine
          learning algorithms) can be misled by irrelevant input features, resulting in worse
          predictive performance.         RFE is a wrapper-type feature selection algorithm. This
          means that a different ROM is given and used in the core of the         method,         is
          wrapped by RFE, and used to help select features.         \\RFE works by searching for a
          subset of features by starting with all features in the training dataset and successfully
          removing         features until the desired number remains.         This is achieved by
          fitting the given ROME used in the core of the model, ranking features by importance,
          discarding the least important features, and re-fitting the model. This process is
          repeated until a specified number of         features remains.         When the full model
          is created, a measure of variable importance is computed that ranks the predictors from
          most         important to least.         At each stage of the search, the least important
          predictors are iteratively eliminated prior to rebuilding the model.         Features are
          scored either using the ROM model (if the model provides a mean to compute feature
          importances) or by         using a statistical method.         \\In RAVEN the
          \xmlString{RFE} class refers to an augmentation of the basic algorithm, since it allows,
          optionally,         to perform the search on multiple groups of targets (separately) and
          then combine the results of the search in a         single set. In addition, when the RFE
          search is concluded, the user can request to identify the set of features         that
          bring to a minimization of the score (i.e. maximimization of the accuracy).         In
          addition, using the ``applyClusteringFiltering'' option, the algorithm can, using an
          hierarchal clustering algorithm,         identify highly correlated features to speed up
          the subsequential search.
          The \xmlNode{RFE} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{RFE} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{nFeaturesToSelect}: \xmlDesc{integer}, 
              Exact Number of features to select. If not inputted, ``nFeaturesToSelect'' will be set
              to $1/2$ of the features in the training dataset.
  \default{None}

            \item \xmlNode{maxNumberFeatures}: \xmlDesc{integer}, 
              Maximum Number of features to select, the algorithm will automatically determine the
              feature list to minimize a total score.
  \default{None}

            \item \xmlNode{onlyOutputScore}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              If maxNumberFeatures is on, only output score should beconsidered? Or, in case of
              particular models (e.g. DMDC), state variable space score should be considered as
              well.
  \default{False}

            \item \xmlNode{applyClusteringFiltering}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              Applying clustering correlation before RFE search? If true, an hierarchal clustering
              is applied on the feature         space aimed to remove features that are correlated
              before the actual RFE search is performed. This approach can stabilize and
              accelerate the process in case of large feature spaces (e.g > 500 features).
  \default{False}

            \item \xmlNode{applyCrossCorrelation}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              In case of subgroupping, should a cross correleation analysis should be performed
              cross sub-groups?         If it is activated, a cross correleation analysis is used to
              additionally filter the features selected for each         sub-groupping search.
  \default{False}

            \item \xmlNode{step}: \xmlDesc{float}, 
              If greater than or equal to 1, then step corresponds to the (integer) number
              of features to remove at each iteration. If within (0.0, 1.0), then step
              corresponds to the percentage (rounded down) of features to remove at         each
              iteration.
  \default{1}

            \item \xmlNode{subGroup}: \xmlDesc{comma-separated strings, integers, and floats}, 
              Subgroup of output variables on which to perform the search. Multiple nodes of this
              type can be inputted. The RFE search will be then performed in each ``subgroup''
              separately and then the the union of the different feature sets are used for the final
              ROM.
          \end{itemize}

        \item \xmlNode{VarianceThreshold}:
          The \xmlString{VarianceThreshold} is a feature selector that removes     all low-variance
          features. This feature selection algorithm looks only at the features and not     the
          desired outputs. The variance threshold can be set by the user.
          The \xmlNode{VarianceThreshold} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{VarianceThreshold} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{threshold}: \xmlDesc{float}, 
              Features with a training-set variance lower than this threshold                   will
              be removed. The default is to keep all features with non-zero
              variance, i.e. remove the features that have the same value in all
              samples.
  \default{0.0}
          \end{itemize}
      \end{itemize}

    \item \xmlNode{featureSpaceTransformation}:
      Use dimensionality reduction technique to perform a trasformation of the training dataset
      into an uncorrelated one. The dimensionality of the problem will not be reduced but
      the data will be transformed in the transformed space. E.g if the number of features
      are 5, the method projects such features into a new uncorrelated space (still 5-dimensional).
      In case of time-dependent ROMs, all the samples are concatenated in a global 2D matrix
      (n\_samples*n\_timesteps,n\_features) before applying the transformation and then reconstructed
      back into the original shape (before fitting the model).

      The \xmlNode{featureSpaceTransformation} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{transformationMethod}: \xmlDesc{[PCA, KernelLinearPCA, KernelPolyPCA, KernelRbfPCA, KernelSigmoidPCA, KernelCosinePCA, ICA]}, 
          Transformation method to use. Eight options (5 Kernel PCAs) are available:
          \begin{itemize}                     \item \textit{PCA}, Principal Component Analysis;
          \item \textit{KernelLinearPCA}, Kernel (Linear) Principal component analysis;
          \item \textit{KernelPolyPCA}, Kernel (Poly) Principal component analysis;
          \item \textit{KernelRbfPCA}, Kernel(Rbf) Principal component analysis;
          \item \textit{KernelSigmoidPCA}, Kernel (Sigmoid) Principal component analysis;
          \item \textit{KernelCosinePCA}, Kernel (Cosine) Principal component analysis;
          \item \textit{ICA}, Independent component analysis;                    \end{itemize}
  \default{PCA}

        \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
          List of IDs of features/variables to include in the transformation process.
  \default{None}

        \item \xmlNode{whichSpace}: \xmlDesc{string}, 
          Which space to search? Target or Feature?
  \default{Feature}
      \end{itemize}

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{n\_nonzero\_coefs}: \xmlDesc{integer}, 
      Desired number of non-zero entries in the solution. If None (by default)
      this value is set to ten-percent of n\_features.
  \default{None}

    \item \xmlNode{tol}: \xmlDesc{float}, 
      Maximum norm of the residual.
  \default{None}

    \item \xmlNode{fit\_intercept}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Whether the intercept should be estimated or not. If False,
      the data is assumed to be already centered.
  \default{True}

    \item \xmlNode{normalize}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      This parameter is ignored when fit\_intercept is set to False. If True,
      the regressors X will be normalized before regression by subtracting the mean and
      dividing by the l2-norm.
  \default{True}

    \item \xmlNode{precompute}: \xmlDesc{string}, 
      Whether to use a precomputed Gram and Xy matrix to speed up calculations.
      Improves performance when n\_targets or n\_samples is very large.
  \default{auto}
  \end{itemize}


\subsubsection{OrthogonalMatchingPursuitCV}
  The \xmlNode{OrthogonalMatchingPursuitCV}                         implements the OMP algorithm for
  approximating the fit of a                         linear model with constraints imposed on the
  number of non-zero                         coefficients (ie. the $\ell\_0$ pseudo-norm). OMP is
  based on a greedy                         algorithm that includes at each step the atom most
  highly correlated                         with the current residual. It is similar to the simpler
  matching                         pursuit (MP) method, but better in that at each iteration, the
  residual                         is recomputed using an orthogonal projection on the space of the
  previously chosen dictionary elements.                         In this model, the cross-validation
  is embedded for the automatic selection                         of the best hyper-parameters.
  \zNormalizationNotPerformed{OrthogonalMatchingPursuitCV}

  The \xmlNode{OrthogonalMatchingPursuitCV} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{OrthogonalMatchingPursuitCV} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.
  \default{time}

    \item \xmlNode{featureSelection}:
      Apply feature selection algorithm

      The \xmlNode{featureSelection} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{RFE}:
          The \xmlString{RFE} (Recursive Feature Elimination) is a feature selection algorithm.
          Feature selection refers to techniques that select a subset of the most relevant features
          for a model (ROM).         Fewer features can allow ROMs to run more efficiently (less
          space or time complexity) and be more effective.         Indeed, some ROMs (machine
          learning algorithms) can be misled by irrelevant input features, resulting in worse
          predictive performance.         RFE is a wrapper-type feature selection algorithm. This
          means that a different ROM is given and used in the core of the         method,         is
          wrapped by RFE, and used to help select features.         \\RFE works by searching for a
          subset of features by starting with all features in the training dataset and successfully
          removing         features until the desired number remains.         This is achieved by
          fitting the given ROME used in the core of the model, ranking features by importance,
          discarding the least important features, and re-fitting the model. This process is
          repeated until a specified number of         features remains.         When the full model
          is created, a measure of variable importance is computed that ranks the predictors from
          most         important to least.         At each stage of the search, the least important
          predictors are iteratively eliminated prior to rebuilding the model.         Features are
          scored either using the ROM model (if the model provides a mean to compute feature
          importances) or by         using a statistical method.         \\In RAVEN the
          \xmlString{RFE} class refers to an augmentation of the basic algorithm, since it allows,
          optionally,         to perform the search on multiple groups of targets (separately) and
          then combine the results of the search in a         single set. In addition, when the RFE
          search is concluded, the user can request to identify the set of features         that
          bring to a minimization of the score (i.e. maximimization of the accuracy).         In
          addition, using the ``applyClusteringFiltering'' option, the algorithm can, using an
          hierarchal clustering algorithm,         identify highly correlated features to speed up
          the subsequential search.
          The \xmlNode{RFE} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{RFE} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{nFeaturesToSelect}: \xmlDesc{integer}, 
              Exact Number of features to select. If not inputted, ``nFeaturesToSelect'' will be set
              to $1/2$ of the features in the training dataset.
  \default{None}

            \item \xmlNode{maxNumberFeatures}: \xmlDesc{integer}, 
              Maximum Number of features to select, the algorithm will automatically determine the
              feature list to minimize a total score.
  \default{None}

            \item \xmlNode{onlyOutputScore}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              If maxNumberFeatures is on, only output score should beconsidered? Or, in case of
              particular models (e.g. DMDC), state variable space score should be considered as
              well.
  \default{False}

            \item \xmlNode{applyClusteringFiltering}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              Applying clustering correlation before RFE search? If true, an hierarchal clustering
              is applied on the feature         space aimed to remove features that are correlated
              before the actual RFE search is performed. This approach can stabilize and
              accelerate the process in case of large feature spaces (e.g > 500 features).
  \default{False}

            \item \xmlNode{applyCrossCorrelation}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              In case of subgroupping, should a cross correleation analysis should be performed
              cross sub-groups?         If it is activated, a cross correleation analysis is used to
              additionally filter the features selected for each         sub-groupping search.
  \default{False}

            \item \xmlNode{step}: \xmlDesc{float}, 
              If greater than or equal to 1, then step corresponds to the (integer) number
              of features to remove at each iteration. If within (0.0, 1.0), then step
              corresponds to the percentage (rounded down) of features to remove at         each
              iteration.
  \default{1}

            \item \xmlNode{subGroup}: \xmlDesc{comma-separated strings, integers, and floats}, 
              Subgroup of output variables on which to perform the search. Multiple nodes of this
              type can be inputted. The RFE search will be then performed in each ``subgroup''
              separately and then the the union of the different feature sets are used for the final
              ROM.
          \end{itemize}

        \item \xmlNode{VarianceThreshold}:
          The \xmlString{VarianceThreshold} is a feature selector that removes     all low-variance
          features. This feature selection algorithm looks only at the features and not     the
          desired outputs. The variance threshold can be set by the user.
          The \xmlNode{VarianceThreshold} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{VarianceThreshold} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{threshold}: \xmlDesc{float}, 
              Features with a training-set variance lower than this threshold                   will
              be removed. The default is to keep all features with non-zero
              variance, i.e. remove the features that have the same value in all
              samples.
  \default{0.0}
          \end{itemize}
      \end{itemize}

    \item \xmlNode{featureSpaceTransformation}:
      Use dimensionality reduction technique to perform a trasformation of the training dataset
      into an uncorrelated one. The dimensionality of the problem will not be reduced but
      the data will be transformed in the transformed space. E.g if the number of features
      are 5, the method projects such features into a new uncorrelated space (still 5-dimensional).
      In case of time-dependent ROMs, all the samples are concatenated in a global 2D matrix
      (n\_samples*n\_timesteps,n\_features) before applying the transformation and then reconstructed
      back into the original shape (before fitting the model).

      The \xmlNode{featureSpaceTransformation} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{transformationMethod}: \xmlDesc{[PCA, KernelLinearPCA, KernelPolyPCA, KernelRbfPCA, KernelSigmoidPCA, KernelCosinePCA, ICA]}, 
          Transformation method to use. Eight options (5 Kernel PCAs) are available:
          \begin{itemize}                     \item \textit{PCA}, Principal Component Analysis;
          \item \textit{KernelLinearPCA}, Kernel (Linear) Principal component analysis;
          \item \textit{KernelPolyPCA}, Kernel (Poly) Principal component analysis;
          \item \textit{KernelRbfPCA}, Kernel(Rbf) Principal component analysis;
          \item \textit{KernelSigmoidPCA}, Kernel (Sigmoid) Principal component analysis;
          \item \textit{KernelCosinePCA}, Kernel (Cosine) Principal component analysis;
          \item \textit{ICA}, Independent component analysis;                    \end{itemize}
  \default{PCA}

        \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
          List of IDs of features/variables to include in the transformation process.
  \default{None}

        \item \xmlNode{whichSpace}: \xmlDesc{string}, 
          Which space to search? Target or Feature?
  \default{Feature}
      \end{itemize}

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{fit\_intercept}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Whether the intercept should be estimated or not. If False,
      the data is assumed to be already centered.
  \default{True}

    \item \xmlNode{normalize}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      This parameter is ignored when fit\_intercept is set to False. If True,
      the regressors X will be normalized before regression by subtracting the mean and
      dividing by the l2-norm.
  \default{True}

    \item \xmlNode{max\_iter}: \xmlDesc{integer}, 
      Maximum numbers of iterations to perform, therefore maximum
      features to include. Ten-percent of n\_features but at least 5 if available.
  \default{None}

    \item \xmlNode{cv}: \xmlDesc{integer}, 
      Determines the cross-validation splitting strategy.
      It specifies the number of folds..
  \default{None}

    \item \xmlNode{verbose}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Amount of verbosity.
  \default{False}
  \end{itemize}


\subsubsection{PassiveAggressiveClassifier}
  The \xmlNode{PassiveAggressiveClassifier}                         is a principled approach to
  linear                         classification that advocates minimal weight updates i.e., the
  least required                         to correctly classify the current training instance.
  \\The passive-aggressive algorithms are a family of algorithms for                         large-
  scale learning. They are similar to the Perceptron in that they                         do not
  require a learning rate. However, contrary to the Perceptron,                         they include
  a regularization parameter C.
  \zNormalizationPerformed{PassiveAggressiveClassifier}

  The \xmlNode{PassiveAggressiveClassifier} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{PassiveAggressiveClassifier} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.
  \default{time}

    \item \xmlNode{featureSelection}:
      Apply feature selection algorithm

      The \xmlNode{featureSelection} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{RFE}:
          The \xmlString{RFE} (Recursive Feature Elimination) is a feature selection algorithm.
          Feature selection refers to techniques that select a subset of the most relevant features
          for a model (ROM).         Fewer features can allow ROMs to run more efficiently (less
          space or time complexity) and be more effective.         Indeed, some ROMs (machine
          learning algorithms) can be misled by irrelevant input features, resulting in worse
          predictive performance.         RFE is a wrapper-type feature selection algorithm. This
          means that a different ROM is given and used in the core of the         method,         is
          wrapped by RFE, and used to help select features.         \\RFE works by searching for a
          subset of features by starting with all features in the training dataset and successfully
          removing         features until the desired number remains.         This is achieved by
          fitting the given ROME used in the core of the model, ranking features by importance,
          discarding the least important features, and re-fitting the model. This process is
          repeated until a specified number of         features remains.         When the full model
          is created, a measure of variable importance is computed that ranks the predictors from
          most         important to least.         At each stage of the search, the least important
          predictors are iteratively eliminated prior to rebuilding the model.         Features are
          scored either using the ROM model (if the model provides a mean to compute feature
          importances) or by         using a statistical method.         \\In RAVEN the
          \xmlString{RFE} class refers to an augmentation of the basic algorithm, since it allows,
          optionally,         to perform the search on multiple groups of targets (separately) and
          then combine the results of the search in a         single set. In addition, when the RFE
          search is concluded, the user can request to identify the set of features         that
          bring to a minimization of the score (i.e. maximimization of the accuracy).         In
          addition, using the ``applyClusteringFiltering'' option, the algorithm can, using an
          hierarchal clustering algorithm,         identify highly correlated features to speed up
          the subsequential search.
          The \xmlNode{RFE} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{RFE} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{nFeaturesToSelect}: \xmlDesc{integer}, 
              Exact Number of features to select. If not inputted, ``nFeaturesToSelect'' will be set
              to $1/2$ of the features in the training dataset.
  \default{None}

            \item \xmlNode{maxNumberFeatures}: \xmlDesc{integer}, 
              Maximum Number of features to select, the algorithm will automatically determine the
              feature list to minimize a total score.
  \default{None}

            \item \xmlNode{onlyOutputScore}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              If maxNumberFeatures is on, only output score should beconsidered? Or, in case of
              particular models (e.g. DMDC), state variable space score should be considered as
              well.
  \default{False}

            \item \xmlNode{applyClusteringFiltering}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              Applying clustering correlation before RFE search? If true, an hierarchal clustering
              is applied on the feature         space aimed to remove features that are correlated
              before the actual RFE search is performed. This approach can stabilize and
              accelerate the process in case of large feature spaces (e.g > 500 features).
  \default{False}

            \item \xmlNode{applyCrossCorrelation}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              In case of subgroupping, should a cross correleation analysis should be performed
              cross sub-groups?         If it is activated, a cross correleation analysis is used to
              additionally filter the features selected for each         sub-groupping search.
  \default{False}

            \item \xmlNode{step}: \xmlDesc{float}, 
              If greater than or equal to 1, then step corresponds to the (integer) number
              of features to remove at each iteration. If within (0.0, 1.0), then step
              corresponds to the percentage (rounded down) of features to remove at         each
              iteration.
  \default{1}

            \item \xmlNode{subGroup}: \xmlDesc{comma-separated strings, integers, and floats}, 
              Subgroup of output variables on which to perform the search. Multiple nodes of this
              type can be inputted. The RFE search will be then performed in each ``subgroup''
              separately and then the the union of the different feature sets are used for the final
              ROM.
          \end{itemize}

        \item \xmlNode{VarianceThreshold}:
          The \xmlString{VarianceThreshold} is a feature selector that removes     all low-variance
          features. This feature selection algorithm looks only at the features and not     the
          desired outputs. The variance threshold can be set by the user.
          The \xmlNode{VarianceThreshold} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{VarianceThreshold} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{threshold}: \xmlDesc{float}, 
              Features with a training-set variance lower than this threshold                   will
              be removed. The default is to keep all features with non-zero
              variance, i.e. remove the features that have the same value in all
              samples.
  \default{0.0}
          \end{itemize}
      \end{itemize}

    \item \xmlNode{featureSpaceTransformation}:
      Use dimensionality reduction technique to perform a trasformation of the training dataset
      into an uncorrelated one. The dimensionality of the problem will not be reduced but
      the data will be transformed in the transformed space. E.g if the number of features
      are 5, the method projects such features into a new uncorrelated space (still 5-dimensional).
      In case of time-dependent ROMs, all the samples are concatenated in a global 2D matrix
      (n\_samples*n\_timesteps,n\_features) before applying the transformation and then reconstructed
      back into the original shape (before fitting the model).

      The \xmlNode{featureSpaceTransformation} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{transformationMethod}: \xmlDesc{[PCA, KernelLinearPCA, KernelPolyPCA, KernelRbfPCA, KernelSigmoidPCA, KernelCosinePCA, ICA]}, 
          Transformation method to use. Eight options (5 Kernel PCAs) are available:
          \begin{itemize}                     \item \textit{PCA}, Principal Component Analysis;
          \item \textit{KernelLinearPCA}, Kernel (Linear) Principal component analysis;
          \item \textit{KernelPolyPCA}, Kernel (Poly) Principal component analysis;
          \item \textit{KernelRbfPCA}, Kernel(Rbf) Principal component analysis;
          \item \textit{KernelSigmoidPCA}, Kernel (Sigmoid) Principal component analysis;
          \item \textit{KernelCosinePCA}, Kernel (Cosine) Principal component analysis;
          \item \textit{ICA}, Independent component analysis;                    \end{itemize}
  \default{PCA}

        \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
          List of IDs of features/variables to include in the transformation process.
  \default{None}

        \item \xmlNode{whichSpace}: \xmlDesc{string}, 
          Which space to search? Target or Feature?
  \default{Feature}
      \end{itemize}

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{C}: \xmlDesc{float}, 
      Maximum step size (regularization).
  \default{1.0}

    \item \xmlNode{fit\_intercept}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Whether the intercept should be estimated or not. If False,
      the data is assumed to be already centered.
  \default{True}

    \item \xmlNode{max\_iter}: \xmlDesc{integer}, 
      The maximum number of passes over the training data (aka epochs).
  \default{1000}

    \item \xmlNode{tol}: \xmlDesc{float}, 
      The stopping criterion.
  \default{0.001}

    \item \xmlNode{early\_stopping}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      hether to use early stopping to terminate training when validation score is not
      improving. If set to True, it will automatically set aside a stratified fraction of training
      data as validation and terminate training when validation score is not improving by at least
      tol for n\_iter\_no\_change consecutive epochs.
  \default{False}

    \item \xmlNode{validation\_fraction}: \xmlDesc{float}, 
      The proportion of training data to set aside as validation set for early stopping.
      Must be between 0 and 1. Only used if early\_stopping is True.
  \default{0.1}

    \item \xmlNode{n\_iter\_no\_change}: \xmlDesc{integer}, 
      Number of iterations with no improvement to wait before early stopping.
  \default{5}

    \item \xmlNode{shuffle}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Whether or not the training data should be shuffled after each epoch.
  \default{True}

    \item \xmlNode{loss}: \xmlDesc{[hinge,  squared\_hinge]}, 
      The loss function to be used: hinge: equivalent to PA-I.
      squared\_hinge: equivalent to PA-II.
  \default{hinge}

    \item \xmlNode{random\_state}: \xmlDesc{integer}, 
      Used to shuffle the training data, when shuffle is set to
      True. Pass an int for reproducible output across multiple function calls.
  \default{None}

    \item \xmlNode{verbose}: \xmlDesc{integer}, 
      The verbosity level
  \default{0}

    \item \xmlNode{warm\_start}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      When set to True, reuse the solution of the previous call
      to fit as initialization, otherwise, just erase the previous solution.
  \default{False}
  \end{itemize}


\subsubsection{PassiveAggressiveRegressor}
  The \xmlNode{PassiveAggressiveRegressor}                         is a a regression algorithm
  similar to the Perceptron algorithm                         but with a regularization parameter C.
  \\The passive-aggressive algorithms are a family of algorithms for                         large-
  scale learning.                         \zNormalizationPerformed{PassiveAggressiveRegressor}

  The \xmlNode{PassiveAggressiveRegressor} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{PassiveAggressiveRegressor} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.
  \default{time}

    \item \xmlNode{featureSelection}:
      Apply feature selection algorithm

      The \xmlNode{featureSelection} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{RFE}:
          The \xmlString{RFE} (Recursive Feature Elimination) is a feature selection algorithm.
          Feature selection refers to techniques that select a subset of the most relevant features
          for a model (ROM).         Fewer features can allow ROMs to run more efficiently (less
          space or time complexity) and be more effective.         Indeed, some ROMs (machine
          learning algorithms) can be misled by irrelevant input features, resulting in worse
          predictive performance.         RFE is a wrapper-type feature selection algorithm. This
          means that a different ROM is given and used in the core of the         method,         is
          wrapped by RFE, and used to help select features.         \\RFE works by searching for a
          subset of features by starting with all features in the training dataset and successfully
          removing         features until the desired number remains.         This is achieved by
          fitting the given ROME used in the core of the model, ranking features by importance,
          discarding the least important features, and re-fitting the model. This process is
          repeated until a specified number of         features remains.         When the full model
          is created, a measure of variable importance is computed that ranks the predictors from
          most         important to least.         At each stage of the search, the least important
          predictors are iteratively eliminated prior to rebuilding the model.         Features are
          scored either using the ROM model (if the model provides a mean to compute feature
          importances) or by         using a statistical method.         \\In RAVEN the
          \xmlString{RFE} class refers to an augmentation of the basic algorithm, since it allows,
          optionally,         to perform the search on multiple groups of targets (separately) and
          then combine the results of the search in a         single set. In addition, when the RFE
          search is concluded, the user can request to identify the set of features         that
          bring to a minimization of the score (i.e. maximimization of the accuracy).         In
          addition, using the ``applyClusteringFiltering'' option, the algorithm can, using an
          hierarchal clustering algorithm,         identify highly correlated features to speed up
          the subsequential search.
          The \xmlNode{RFE} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{RFE} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{nFeaturesToSelect}: \xmlDesc{integer}, 
              Exact Number of features to select. If not inputted, ``nFeaturesToSelect'' will be set
              to $1/2$ of the features in the training dataset.
  \default{None}

            \item \xmlNode{maxNumberFeatures}: \xmlDesc{integer}, 
              Maximum Number of features to select, the algorithm will automatically determine the
              feature list to minimize a total score.
  \default{None}

            \item \xmlNode{onlyOutputScore}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              If maxNumberFeatures is on, only output score should beconsidered? Or, in case of
              particular models (e.g. DMDC), state variable space score should be considered as
              well.
  \default{False}

            \item \xmlNode{applyClusteringFiltering}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              Applying clustering correlation before RFE search? If true, an hierarchal clustering
              is applied on the feature         space aimed to remove features that are correlated
              before the actual RFE search is performed. This approach can stabilize and
              accelerate the process in case of large feature spaces (e.g > 500 features).
  \default{False}

            \item \xmlNode{applyCrossCorrelation}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              In case of subgroupping, should a cross correleation analysis should be performed
              cross sub-groups?         If it is activated, a cross correleation analysis is used to
              additionally filter the features selected for each         sub-groupping search.
  \default{False}

            \item \xmlNode{step}: \xmlDesc{float}, 
              If greater than or equal to 1, then step corresponds to the (integer) number
              of features to remove at each iteration. If within (0.0, 1.0), then step
              corresponds to the percentage (rounded down) of features to remove at         each
              iteration.
  \default{1}

            \item \xmlNode{subGroup}: \xmlDesc{comma-separated strings, integers, and floats}, 
              Subgroup of output variables on which to perform the search. Multiple nodes of this
              type can be inputted. The RFE search will be then performed in each ``subgroup''
              separately and then the the union of the different feature sets are used for the final
              ROM.
          \end{itemize}

        \item \xmlNode{VarianceThreshold}:
          The \xmlString{VarianceThreshold} is a feature selector that removes     all low-variance
          features. This feature selection algorithm looks only at the features and not     the
          desired outputs. The variance threshold can be set by the user.
          The \xmlNode{VarianceThreshold} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{VarianceThreshold} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{threshold}: \xmlDesc{float}, 
              Features with a training-set variance lower than this threshold                   will
              be removed. The default is to keep all features with non-zero
              variance, i.e. remove the features that have the same value in all
              samples.
  \default{0.0}
          \end{itemize}
      \end{itemize}

    \item \xmlNode{featureSpaceTransformation}:
      Use dimensionality reduction technique to perform a trasformation of the training dataset
      into an uncorrelated one. The dimensionality of the problem will not be reduced but
      the data will be transformed in the transformed space. E.g if the number of features
      are 5, the method projects such features into a new uncorrelated space (still 5-dimensional).
      In case of time-dependent ROMs, all the samples are concatenated in a global 2D matrix
      (n\_samples*n\_timesteps,n\_features) before applying the transformation and then reconstructed
      back into the original shape (before fitting the model).

      The \xmlNode{featureSpaceTransformation} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{transformationMethod}: \xmlDesc{[PCA, KernelLinearPCA, KernelPolyPCA, KernelRbfPCA, KernelSigmoidPCA, KernelCosinePCA, ICA]}, 
          Transformation method to use. Eight options (5 Kernel PCAs) are available:
          \begin{itemize}                     \item \textit{PCA}, Principal Component Analysis;
          \item \textit{KernelLinearPCA}, Kernel (Linear) Principal component analysis;
          \item \textit{KernelPolyPCA}, Kernel (Poly) Principal component analysis;
          \item \textit{KernelRbfPCA}, Kernel(Rbf) Principal component analysis;
          \item \textit{KernelSigmoidPCA}, Kernel (Sigmoid) Principal component analysis;
          \item \textit{KernelCosinePCA}, Kernel (Cosine) Principal component analysis;
          \item \textit{ICA}, Independent component analysis;                    \end{itemize}
  \default{PCA}

        \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
          List of IDs of features/variables to include in the transformation process.
  \default{None}

        \item \xmlNode{whichSpace}: \xmlDesc{string}, 
          Which space to search? Target or Feature?
  \default{Feature}
      \end{itemize}

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{C}: \xmlDesc{float}, 
      Maximum step size (regularization).
  \default{1.0}

    \item \xmlNode{fit\_intercept}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Whether the intercept should be estimated or not. If False,
      the data is assumed to be already centered.
  \default{True}

    \item \xmlNode{max\_iter}: \xmlDesc{integer}, 
      The maximum number of passes over the training data (aka epochs).
  \default{1000}

    \item \xmlNode{tol}: \xmlDesc{float}, 
      The stopping criterion.
  \default{0.001}

    \item \xmlNode{epsilon}: \xmlDesc{float}, 
      If the difference between the current prediction and the
      correct label is below this threshold, the model is not updated.
  \default{0.1}

    \item \xmlNode{early\_stopping}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      hether to use early stopping to terminate training when validation score is not
      improving. If set to True, it will automatically set aside a stratified fraction of training
      data as validation and terminate training when validation score is not improving by at least
      tol for n\_iter\_no\_change consecutive epochs.
  \default{False}

    \item \xmlNode{validation\_fraction}: \xmlDesc{float}, 
      The proportion of training data to set aside as validation set for early stopping.
      Must be between 0 and 1. Only used if early\_stopping is True.
  \default{0.1}

    \item \xmlNode{n\_iter\_no\_change}: \xmlDesc{integer}, 
      Number of iterations with no improvement to wait before early stopping.
  \default{5}

    \item \xmlNode{shuffle}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Whether or not the training data should be shuffled after each epoch.
  \default{True}

    \item \xmlNode{loss}: \xmlDesc{[epsilon\_insensitive,  squared\_epsilon\_insensitive]}, 
      The loss function to be used: epsilon\_insensitive: equivalent to PA-I.
      squared\_epsilon\_insensitive: equivalent to PA-II.
  \default{epsilon\_insensitive}

    \item \xmlNode{random\_state}: \xmlDesc{integer}, 
      Used to shuffle the training data, when shuffle is set to
      True. Pass an int for reproducible output across multiple function calls.
  \default{None}

    \item \xmlNode{verbose}: \xmlDesc{integer}, 
      The verbosity level
  \default{0}

    \item \xmlNode{warm\_start}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      When set to True, reuse the solution of the previous call
      to fit as initialization, otherwise, just erase the previous solution.
  \default{False}

    \item \xmlNode{average}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      When set to True, computes the averaged SGD weights and
      stores the result in the coef\_ attribute.
  \default{False}
  \end{itemize}


\subsubsection{Perceptron}
  The \xmlNode{Perceptron} classifier is based on an                         algorithm for
  supervised classification of                         an input into one of several possible non-
  binary outputs.                         It is a type of linear classifier, i.e. a classification
  algorithm that makes                         its predictions based on a linear predictor function
  combining a set of weights                         with the feature vector.
  The algorithm allows for online learning, in that it processes elements in the
  training set one at a time.                         \zNormalizationPerformed{Perceptron}

  The \xmlNode{Perceptron} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{Perceptron} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.
  \default{time}

    \item \xmlNode{featureSelection}:
      Apply feature selection algorithm

      The \xmlNode{featureSelection} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{RFE}:
          The \xmlString{RFE} (Recursive Feature Elimination) is a feature selection algorithm.
          Feature selection refers to techniques that select a subset of the most relevant features
          for a model (ROM).         Fewer features can allow ROMs to run more efficiently (less
          space or time complexity) and be more effective.         Indeed, some ROMs (machine
          learning algorithms) can be misled by irrelevant input features, resulting in worse
          predictive performance.         RFE is a wrapper-type feature selection algorithm. This
          means that a different ROM is given and used in the core of the         method,         is
          wrapped by RFE, and used to help select features.         \\RFE works by searching for a
          subset of features by starting with all features in the training dataset and successfully
          removing         features until the desired number remains.         This is achieved by
          fitting the given ROME used in the core of the model, ranking features by importance,
          discarding the least important features, and re-fitting the model. This process is
          repeated until a specified number of         features remains.         When the full model
          is created, a measure of variable importance is computed that ranks the predictors from
          most         important to least.         At each stage of the search, the least important
          predictors are iteratively eliminated prior to rebuilding the model.         Features are
          scored either using the ROM model (if the model provides a mean to compute feature
          importances) or by         using a statistical method.         \\In RAVEN the
          \xmlString{RFE} class refers to an augmentation of the basic algorithm, since it allows,
          optionally,         to perform the search on multiple groups of targets (separately) and
          then combine the results of the search in a         single set. In addition, when the RFE
          search is concluded, the user can request to identify the set of features         that
          bring to a minimization of the score (i.e. maximimization of the accuracy).         In
          addition, using the ``applyClusteringFiltering'' option, the algorithm can, using an
          hierarchal clustering algorithm,         identify highly correlated features to speed up
          the subsequential search.
          The \xmlNode{RFE} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{RFE} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{nFeaturesToSelect}: \xmlDesc{integer}, 
              Exact Number of features to select. If not inputted, ``nFeaturesToSelect'' will be set
              to $1/2$ of the features in the training dataset.
  \default{None}

            \item \xmlNode{maxNumberFeatures}: \xmlDesc{integer}, 
              Maximum Number of features to select, the algorithm will automatically determine the
              feature list to minimize a total score.
  \default{None}

            \item \xmlNode{onlyOutputScore}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              If maxNumberFeatures is on, only output score should beconsidered? Or, in case of
              particular models (e.g. DMDC), state variable space score should be considered as
              well.
  \default{False}

            \item \xmlNode{applyClusteringFiltering}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              Applying clustering correlation before RFE search? If true, an hierarchal clustering
              is applied on the feature         space aimed to remove features that are correlated
              before the actual RFE search is performed. This approach can stabilize and
              accelerate the process in case of large feature spaces (e.g > 500 features).
  \default{False}

            \item \xmlNode{applyCrossCorrelation}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              In case of subgroupping, should a cross correleation analysis should be performed
              cross sub-groups?         If it is activated, a cross correleation analysis is used to
              additionally filter the features selected for each         sub-groupping search.
  \default{False}

            \item \xmlNode{step}: \xmlDesc{float}, 
              If greater than or equal to 1, then step corresponds to the (integer) number
              of features to remove at each iteration. If within (0.0, 1.0), then step
              corresponds to the percentage (rounded down) of features to remove at         each
              iteration.
  \default{1}

            \item \xmlNode{subGroup}: \xmlDesc{comma-separated strings, integers, and floats}, 
              Subgroup of output variables on which to perform the search. Multiple nodes of this
              type can be inputted. The RFE search will be then performed in each ``subgroup''
              separately and then the the union of the different feature sets are used for the final
              ROM.
          \end{itemize}

        \item \xmlNode{VarianceThreshold}:
          The \xmlString{VarianceThreshold} is a feature selector that removes     all low-variance
          features. This feature selection algorithm looks only at the features and not     the
          desired outputs. The variance threshold can be set by the user.
          The \xmlNode{VarianceThreshold} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{VarianceThreshold} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{threshold}: \xmlDesc{float}, 
              Features with a training-set variance lower than this threshold                   will
              be removed. The default is to keep all features with non-zero
              variance, i.e. remove the features that have the same value in all
              samples.
  \default{0.0}
          \end{itemize}
      \end{itemize}

    \item \xmlNode{featureSpaceTransformation}:
      Use dimensionality reduction technique to perform a trasformation of the training dataset
      into an uncorrelated one. The dimensionality of the problem will not be reduced but
      the data will be transformed in the transformed space. E.g if the number of features
      are 5, the method projects such features into a new uncorrelated space (still 5-dimensional).
      In case of time-dependent ROMs, all the samples are concatenated in a global 2D matrix
      (n\_samples*n\_timesteps,n\_features) before applying the transformation and then reconstructed
      back into the original shape (before fitting the model).

      The \xmlNode{featureSpaceTransformation} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{transformationMethod}: \xmlDesc{[PCA, KernelLinearPCA, KernelPolyPCA, KernelRbfPCA, KernelSigmoidPCA, KernelCosinePCA, ICA]}, 
          Transformation method to use. Eight options (5 Kernel PCAs) are available:
          \begin{itemize}                     \item \textit{PCA}, Principal Component Analysis;
          \item \textit{KernelLinearPCA}, Kernel (Linear) Principal component analysis;
          \item \textit{KernelPolyPCA}, Kernel (Poly) Principal component analysis;
          \item \textit{KernelRbfPCA}, Kernel(Rbf) Principal component analysis;
          \item \textit{KernelSigmoidPCA}, Kernel (Sigmoid) Principal component analysis;
          \item \textit{KernelCosinePCA}, Kernel (Cosine) Principal component analysis;
          \item \textit{ICA}, Independent component analysis;                    \end{itemize}
  \default{PCA}

        \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
          List of IDs of features/variables to include in the transformation process.
  \default{None}

        \item \xmlNode{whichSpace}: \xmlDesc{string}, 
          Which space to search? Target or Feature?
  \default{Feature}
      \end{itemize}

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{penalty}: \xmlDesc{[l2,  l1, elasticnet]}, 
      The penalty (aka regularization term) to be used.
  \default{None}

    \item \xmlNode{alpha}: \xmlDesc{float}, 
      Constant that multiplies the regularization term if regularization is used.
  \default{0.0001}

    \item \xmlNode{fit\_intercept}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Whether the intercept should be estimated or not. If False,
      the data is assumed to be already centered.
  \default{True}

    \item \xmlNode{max\_iter}: \xmlDesc{integer}, 
      The maximum number of passes over the training data (aka epochs).
  \default{1000}

    \item \xmlNode{tol}: \xmlDesc{float}, 
      The stopping criterion.
  \default{0.001}

    \item \xmlNode{n\_iter\_no\_change}: \xmlDesc{integer}, 
      Number of iterations with no improvement to wait before early stopping.
  \default{5}

    \item \xmlNode{shuffle}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Whether or not the training data should be shuffled after each epoch.
  \default{True}

    \item \xmlNode{eta0}: \xmlDesc{float}, 
      The stopping criterion.
  \default{1}

    \item \xmlNode{early\_stopping}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      hether to use early stopping to terminate training when validation score is not
      improving. If set to True, it will automatically set aside a stratified fraction of training
      data as validation and terminate training when validation score is not improving by at least
      tol for n\_iter\_no\_change consecutive epochs.
  \default{False}

    \item \xmlNode{validation\_fraction}: \xmlDesc{float}, 
      The proportion of training data to set aside as validation set for early stopping.
      Must be between 0 and 1. Only used if early\_stopping is True.
  \default{0.1}

    \item \xmlNode{class\_weight}: \xmlDesc{[balanced]}, 
      If not given, all classes are supposed to have weight one.
      The “balanced” mode uses the values of y to automatically adjust weights
      inversely proportional to class frequencies in the input data
  \default{None}

    \item \xmlNode{random\_state}: \xmlDesc{integer}, 
      Used to shuffle the training data, when shuffle is set to
      True. Pass an int for reproducible output across multiple function calls.
  \default{None}

    \item \xmlNode{verbose}: \xmlDesc{integer}, 
      The verbosity level
  \default{0}

    \item \xmlNode{warm\_start}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      When set to True, reuse the solution of the previous call
      to fit as initialization, otherwise, just erase the previous solution.
  \default{False}
  \end{itemize}


\subsubsection{Ridge}
  The \xmlNode{Ridge} regressor also known as                              \textit{linear least
  squares with l2 regularization} solves a regression                              model where the
  loss function is the linear least squares function and the
  regularization is given by the l2-norm.                              Also known as Ridge
  Regression or Tikhonov regularization.
  \zNormalizationNotPerformed{Ridge}

  The \xmlNode{Ridge} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{Ridge} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.
  \default{time}

    \item \xmlNode{featureSelection}:
      Apply feature selection algorithm

      The \xmlNode{featureSelection} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{RFE}:
          The \xmlString{RFE} (Recursive Feature Elimination) is a feature selection algorithm.
          Feature selection refers to techniques that select a subset of the most relevant features
          for a model (ROM).         Fewer features can allow ROMs to run more efficiently (less
          space or time complexity) and be more effective.         Indeed, some ROMs (machine
          learning algorithms) can be misled by irrelevant input features, resulting in worse
          predictive performance.         RFE is a wrapper-type feature selection algorithm. This
          means that a different ROM is given and used in the core of the         method,         is
          wrapped by RFE, and used to help select features.         \\RFE works by searching for a
          subset of features by starting with all features in the training dataset and successfully
          removing         features until the desired number remains.         This is achieved by
          fitting the given ROME used in the core of the model, ranking features by importance,
          discarding the least important features, and re-fitting the model. This process is
          repeated until a specified number of         features remains.         When the full model
          is created, a measure of variable importance is computed that ranks the predictors from
          most         important to least.         At each stage of the search, the least important
          predictors are iteratively eliminated prior to rebuilding the model.         Features are
          scored either using the ROM model (if the model provides a mean to compute feature
          importances) or by         using a statistical method.         \\In RAVEN the
          \xmlString{RFE} class refers to an augmentation of the basic algorithm, since it allows,
          optionally,         to perform the search on multiple groups of targets (separately) and
          then combine the results of the search in a         single set. In addition, when the RFE
          search is concluded, the user can request to identify the set of features         that
          bring to a minimization of the score (i.e. maximimization of the accuracy).         In
          addition, using the ``applyClusteringFiltering'' option, the algorithm can, using an
          hierarchal clustering algorithm,         identify highly correlated features to speed up
          the subsequential search.
          The \xmlNode{RFE} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{RFE} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{nFeaturesToSelect}: \xmlDesc{integer}, 
              Exact Number of features to select. If not inputted, ``nFeaturesToSelect'' will be set
              to $1/2$ of the features in the training dataset.
  \default{None}

            \item \xmlNode{maxNumberFeatures}: \xmlDesc{integer}, 
              Maximum Number of features to select, the algorithm will automatically determine the
              feature list to minimize a total score.
  \default{None}

            \item \xmlNode{onlyOutputScore}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              If maxNumberFeatures is on, only output score should beconsidered? Or, in case of
              particular models (e.g. DMDC), state variable space score should be considered as
              well.
  \default{False}

            \item \xmlNode{applyClusteringFiltering}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              Applying clustering correlation before RFE search? If true, an hierarchal clustering
              is applied on the feature         space aimed to remove features that are correlated
              before the actual RFE search is performed. This approach can stabilize and
              accelerate the process in case of large feature spaces (e.g > 500 features).
  \default{False}

            \item \xmlNode{applyCrossCorrelation}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              In case of subgroupping, should a cross correleation analysis should be performed
              cross sub-groups?         If it is activated, a cross correleation analysis is used to
              additionally filter the features selected for each         sub-groupping search.
  \default{False}

            \item \xmlNode{step}: \xmlDesc{float}, 
              If greater than or equal to 1, then step corresponds to the (integer) number
              of features to remove at each iteration. If within (0.0, 1.0), then step
              corresponds to the percentage (rounded down) of features to remove at         each
              iteration.
  \default{1}

            \item \xmlNode{subGroup}: \xmlDesc{comma-separated strings, integers, and floats}, 
              Subgroup of output variables on which to perform the search. Multiple nodes of this
              type can be inputted. The RFE search will be then performed in each ``subgroup''
              separately and then the the union of the different feature sets are used for the final
              ROM.
          \end{itemize}

        \item \xmlNode{VarianceThreshold}:
          The \xmlString{VarianceThreshold} is a feature selector that removes     all low-variance
          features. This feature selection algorithm looks only at the features and not     the
          desired outputs. The variance threshold can be set by the user.
          The \xmlNode{VarianceThreshold} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{VarianceThreshold} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{threshold}: \xmlDesc{float}, 
              Features with a training-set variance lower than this threshold                   will
              be removed. The default is to keep all features with non-zero
              variance, i.e. remove the features that have the same value in all
              samples.
  \default{0.0}
          \end{itemize}
      \end{itemize}

    \item \xmlNode{featureSpaceTransformation}:
      Use dimensionality reduction technique to perform a trasformation of the training dataset
      into an uncorrelated one. The dimensionality of the problem will not be reduced but
      the data will be transformed in the transformed space. E.g if the number of features
      are 5, the method projects such features into a new uncorrelated space (still 5-dimensional).
      In case of time-dependent ROMs, all the samples are concatenated in a global 2D matrix
      (n\_samples*n\_timesteps,n\_features) before applying the transformation and then reconstructed
      back into the original shape (before fitting the model).

      The \xmlNode{featureSpaceTransformation} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{transformationMethod}: \xmlDesc{[PCA, KernelLinearPCA, KernelPolyPCA, KernelRbfPCA, KernelSigmoidPCA, KernelCosinePCA, ICA]}, 
          Transformation method to use. Eight options (5 Kernel PCAs) are available:
          \begin{itemize}                     \item \textit{PCA}, Principal Component Analysis;
          \item \textit{KernelLinearPCA}, Kernel (Linear) Principal component analysis;
          \item \textit{KernelPolyPCA}, Kernel (Poly) Principal component analysis;
          \item \textit{KernelRbfPCA}, Kernel(Rbf) Principal component analysis;
          \item \textit{KernelSigmoidPCA}, Kernel (Sigmoid) Principal component analysis;
          \item \textit{KernelCosinePCA}, Kernel (Cosine) Principal component analysis;
          \item \textit{ICA}, Independent component analysis;                    \end{itemize}
  \default{PCA}

        \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
          List of IDs of features/variables to include in the transformation process.
  \default{None}

        \item \xmlNode{whichSpace}: \xmlDesc{string}, 
          Which space to search? Target or Feature?
  \default{Feature}
      \end{itemize}

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{alpha}: \xmlDesc{float}, 
      Regularization strength; must be a positive float. Regularization
      improves the conditioning of the problem and reduces the variance of the estimates.
      Larger values specify stronger regularization. Alpha corresponds to $1 / (2C)$ in other
      linear models such as LogisticRegression or LinearSVC.
  \default{1.0}

    \item \xmlNode{fit\_intercept}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Whether the intercept should be estimated or not. If False,
      the data is assumed to be already centered.
  \default{True}

    \item \xmlNode{normalize}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      This parameter is ignored when fit\_intercept is set to False. If True, the
      regressors X will be normalized before regression by subtracting the mean and dividing
      by the l2-norm.
  \default{False}

    \item \xmlNode{max\_iter}: \xmlDesc{integer}, 
      Maximum number of iterations for conjugate gradient solver.
  \default{None}

    \item \xmlNode{tol}: \xmlDesc{float}, 
      Precision of the solution
  \default{0.001}

    \item \xmlNode{solver}: \xmlDesc{[auto, svd, cholesky, lsqr, sparse\_cg, sag, saga]}, 
      Solver to use in the computational routines:
      \begin{itemize}                                                    \item auto, chooses the
      solver automatically based on the type of data.
      \item svd, uses a Singular Value Decomposition of X to compute the Ridge coefficients. More
      stable for singular                                                                matrices
      than ``cholesky''.                                                    \item cholesky, uses the
      standard scipy.linalg.solve function to obtain a closed-form solution.
      \item sparse\_cg, uses the conjugate gradient solver as found in scipy.sparse.linalg.cg. As an
      iterative algorithm,                                                               this solver
      is more appropriate than ‘cholesky’ for large-scale data (possibility to set tol and
      max\_iter).                                                    \item lsqr, uses the dedicated
      regularized least-squares routine scipy.sparse.linalg.lsqr. It is the fastest and uses
      an iterative procedure.                                                    \item sag, uses a
      Stochastic Average Gradient descent, and ``saga'' uses its improved, unbiased version named
      SAGA.                                                               Both methods also use an
      iterative procedure, and are often faster than other solvers when both
      n\_samples and n\_features are large. Note that ``sag'' and ``saga'' fast convergence is only
      guaranteed on                                                               features with
      approximately the same scale. You can preprocess the data with a scaler from
      sklearn.preprocessing.                                                  \end{itemize}
  \default{auto}
  \end{itemize}


\subsubsection{RidgeCV}
  The \xmlNode{RidgeCV} regressor also known as                              \textit{linear least
  squares with l2 regularization} solves a regression                              model where the
  loss function is the linear least squares function and the
  regularization is given by the l2-norm.                              In addition, a cross-
  validation method is applied to optimize the hyper-parameter.
  \zNormalizationNotPerformed{RidgeCV}

  The \xmlNode{RidgeCV} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{RidgeCV} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.
  \default{time}

    \item \xmlNode{featureSelection}:
      Apply feature selection algorithm

      The \xmlNode{featureSelection} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{RFE}:
          The \xmlString{RFE} (Recursive Feature Elimination) is a feature selection algorithm.
          Feature selection refers to techniques that select a subset of the most relevant features
          for a model (ROM).         Fewer features can allow ROMs to run more efficiently (less
          space or time complexity) and be more effective.         Indeed, some ROMs (machine
          learning algorithms) can be misled by irrelevant input features, resulting in worse
          predictive performance.         RFE is a wrapper-type feature selection algorithm. This
          means that a different ROM is given and used in the core of the         method,         is
          wrapped by RFE, and used to help select features.         \\RFE works by searching for a
          subset of features by starting with all features in the training dataset and successfully
          removing         features until the desired number remains.         This is achieved by
          fitting the given ROME used in the core of the model, ranking features by importance,
          discarding the least important features, and re-fitting the model. This process is
          repeated until a specified number of         features remains.         When the full model
          is created, a measure of variable importance is computed that ranks the predictors from
          most         important to least.         At each stage of the search, the least important
          predictors are iteratively eliminated prior to rebuilding the model.         Features are
          scored either using the ROM model (if the model provides a mean to compute feature
          importances) or by         using a statistical method.         \\In RAVEN the
          \xmlString{RFE} class refers to an augmentation of the basic algorithm, since it allows,
          optionally,         to perform the search on multiple groups of targets (separately) and
          then combine the results of the search in a         single set. In addition, when the RFE
          search is concluded, the user can request to identify the set of features         that
          bring to a minimization of the score (i.e. maximimization of the accuracy).         In
          addition, using the ``applyClusteringFiltering'' option, the algorithm can, using an
          hierarchal clustering algorithm,         identify highly correlated features to speed up
          the subsequential search.
          The \xmlNode{RFE} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{RFE} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{nFeaturesToSelect}: \xmlDesc{integer}, 
              Exact Number of features to select. If not inputted, ``nFeaturesToSelect'' will be set
              to $1/2$ of the features in the training dataset.
  \default{None}

            \item \xmlNode{maxNumberFeatures}: \xmlDesc{integer}, 
              Maximum Number of features to select, the algorithm will automatically determine the
              feature list to minimize a total score.
  \default{None}

            \item \xmlNode{onlyOutputScore}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              If maxNumberFeatures is on, only output score should beconsidered? Or, in case of
              particular models (e.g. DMDC), state variable space score should be considered as
              well.
  \default{False}

            \item \xmlNode{applyClusteringFiltering}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              Applying clustering correlation before RFE search? If true, an hierarchal clustering
              is applied on the feature         space aimed to remove features that are correlated
              before the actual RFE search is performed. This approach can stabilize and
              accelerate the process in case of large feature spaces (e.g > 500 features).
  \default{False}

            \item \xmlNode{applyCrossCorrelation}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              In case of subgroupping, should a cross correleation analysis should be performed
              cross sub-groups?         If it is activated, a cross correleation analysis is used to
              additionally filter the features selected for each         sub-groupping search.
  \default{False}

            \item \xmlNode{step}: \xmlDesc{float}, 
              If greater than or equal to 1, then step corresponds to the (integer) number
              of features to remove at each iteration. If within (0.0, 1.0), then step
              corresponds to the percentage (rounded down) of features to remove at         each
              iteration.
  \default{1}

            \item \xmlNode{subGroup}: \xmlDesc{comma-separated strings, integers, and floats}, 
              Subgroup of output variables on which to perform the search. Multiple nodes of this
              type can be inputted. The RFE search will be then performed in each ``subgroup''
              separately and then the the union of the different feature sets are used for the final
              ROM.
          \end{itemize}

        \item \xmlNode{VarianceThreshold}:
          The \xmlString{VarianceThreshold} is a feature selector that removes     all low-variance
          features. This feature selection algorithm looks only at the features and not     the
          desired outputs. The variance threshold can be set by the user.
          The \xmlNode{VarianceThreshold} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{VarianceThreshold} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{threshold}: \xmlDesc{float}, 
              Features with a training-set variance lower than this threshold                   will
              be removed. The default is to keep all features with non-zero
              variance, i.e. remove the features that have the same value in all
              samples.
  \default{0.0}
          \end{itemize}
      \end{itemize}

    \item \xmlNode{featureSpaceTransformation}:
      Use dimensionality reduction technique to perform a trasformation of the training dataset
      into an uncorrelated one. The dimensionality of the problem will not be reduced but
      the data will be transformed in the transformed space. E.g if the number of features
      are 5, the method projects such features into a new uncorrelated space (still 5-dimensional).
      In case of time-dependent ROMs, all the samples are concatenated in a global 2D matrix
      (n\_samples*n\_timesteps,n\_features) before applying the transformation and then reconstructed
      back into the original shape (before fitting the model).

      The \xmlNode{featureSpaceTransformation} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{transformationMethod}: \xmlDesc{[PCA, KernelLinearPCA, KernelPolyPCA, KernelRbfPCA, KernelSigmoidPCA, KernelCosinePCA, ICA]}, 
          Transformation method to use. Eight options (5 Kernel PCAs) are available:
          \begin{itemize}                     \item \textit{PCA}, Principal Component Analysis;
          \item \textit{KernelLinearPCA}, Kernel (Linear) Principal component analysis;
          \item \textit{KernelPolyPCA}, Kernel (Poly) Principal component analysis;
          \item \textit{KernelRbfPCA}, Kernel(Rbf) Principal component analysis;
          \item \textit{KernelSigmoidPCA}, Kernel (Sigmoid) Principal component analysis;
          \item \textit{KernelCosinePCA}, Kernel (Cosine) Principal component analysis;
          \item \textit{ICA}, Independent component analysis;                    \end{itemize}
  \default{PCA}

        \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
          List of IDs of features/variables to include in the transformation process.
  \default{None}

        \item \xmlNode{whichSpace}: \xmlDesc{string}, 
          Which space to search? Target or Feature?
  \default{Feature}
      \end{itemize}

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{fit\_intercept}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Whether the intercept should be estimated or not. If False,
      the data is assumed to be already centered.
  \default{True}

    \item \xmlNode{normalize}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      This parameter is ignored when fit\_intercept is set to False. If True, the
      regressors X will be normalized before regression by subtracting the mean and dividing
      by the l2-norm.
  \default{False}

    \item \xmlNode{gcv\_mode}: \xmlDesc{[auto, svd, eigen]}, 
      Flag indicating which strategy to use when performing Leave-One-Out Cross-Validation.
      Options are:                                                  \begin{itemize}
      \item \textit{auto}, use ``svd'' if $n\_samples > n\_features$, otherwise use ``eigen''
      \item \textit{svd}, force use of singular value decomposition of X when X is
      dense, eigenvalue decomposition of $X^T.X$ when X is sparse
      \item \textit{eigen}, force computation via eigendecomposition of $X.X^T$
      \end{itemize}
  \default{auto}

    \item \xmlNode{alpha\_per\_target}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Flag indicating whether to optimize the alpha value for each target separately
      (for multi-output settings: multiple prediction targets). When set to True, after fitting,
      the alpha\_ attribute will contain a value for each target. When set to False, a single alpha
      is used for all targets. New in version 0.24. (not used)
  \default{False}

    \item \xmlNode{cv}: \xmlDesc{integer}, 
      Determines the cross-validation splitting strategy.
      It specifies the number of folds..
  \default{None}

    \item \xmlNode{alphas}: \xmlDesc{tuple of comma-separated float}, 
      Array of alpha values to try. Regularization strength; must be a positive float.
      Regularization                                                  improves the conditioning of
      the problem and reduces the variance of the estimates.
      Larger values specify stronger regularization. Alpha corresponds to $1 / (2C)$ in other
      linear models such as LogisticRegression or LinearSVC.
  \default{(0.1, 1.0, 10.0)}

    \item \xmlNode{scoring}: \xmlDesc{string}, 
      A string (see model evaluation documentation) or a scorer
      callable object / function with signature.
  \default{None}

    \item \xmlNode{store\_cv\_values}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Flag indicating if the cross-validation values corresponding
      to each alpha should be stored in the cv\_values\_ attribute (see below).
      This flag is only compatible with cv=None (i.e. using Leave-One-Out
      Cross-Validation).
  \default{False}
  \end{itemize}


\subsubsection{RidgeClassifier}
  The \xmlNode{RidgeClassifier} is a classifier that uses Ridge regression.
  This classifier first converts the target values into {-1, 1} and then treats
  the problem as a regression task (multi-output regression in the multiclass case).
  \zNormalizationNotPerformed{RidgeClassifier}

  The \xmlNode{RidgeClassifier} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{RidgeClassifier} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.
  \default{time}

    \item \xmlNode{featureSelection}:
      Apply feature selection algorithm

      The \xmlNode{featureSelection} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{RFE}:
          The \xmlString{RFE} (Recursive Feature Elimination) is a feature selection algorithm.
          Feature selection refers to techniques that select a subset of the most relevant features
          for a model (ROM).         Fewer features can allow ROMs to run more efficiently (less
          space or time complexity) and be more effective.         Indeed, some ROMs (machine
          learning algorithms) can be misled by irrelevant input features, resulting in worse
          predictive performance.         RFE is a wrapper-type feature selection algorithm. This
          means that a different ROM is given and used in the core of the         method,         is
          wrapped by RFE, and used to help select features.         \\RFE works by searching for a
          subset of features by starting with all features in the training dataset and successfully
          removing         features until the desired number remains.         This is achieved by
          fitting the given ROME used in the core of the model, ranking features by importance,
          discarding the least important features, and re-fitting the model. This process is
          repeated until a specified number of         features remains.         When the full model
          is created, a measure of variable importance is computed that ranks the predictors from
          most         important to least.         At each stage of the search, the least important
          predictors are iteratively eliminated prior to rebuilding the model.         Features are
          scored either using the ROM model (if the model provides a mean to compute feature
          importances) or by         using a statistical method.         \\In RAVEN the
          \xmlString{RFE} class refers to an augmentation of the basic algorithm, since it allows,
          optionally,         to perform the search on multiple groups of targets (separately) and
          then combine the results of the search in a         single set. In addition, when the RFE
          search is concluded, the user can request to identify the set of features         that
          bring to a minimization of the score (i.e. maximimization of the accuracy).         In
          addition, using the ``applyClusteringFiltering'' option, the algorithm can, using an
          hierarchal clustering algorithm,         identify highly correlated features to speed up
          the subsequential search.
          The \xmlNode{RFE} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{RFE} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{nFeaturesToSelect}: \xmlDesc{integer}, 
              Exact Number of features to select. If not inputted, ``nFeaturesToSelect'' will be set
              to $1/2$ of the features in the training dataset.
  \default{None}

            \item \xmlNode{maxNumberFeatures}: \xmlDesc{integer}, 
              Maximum Number of features to select, the algorithm will automatically determine the
              feature list to minimize a total score.
  \default{None}

            \item \xmlNode{onlyOutputScore}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              If maxNumberFeatures is on, only output score should beconsidered? Or, in case of
              particular models (e.g. DMDC), state variable space score should be considered as
              well.
  \default{False}

            \item \xmlNode{applyClusteringFiltering}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              Applying clustering correlation before RFE search? If true, an hierarchal clustering
              is applied on the feature         space aimed to remove features that are correlated
              before the actual RFE search is performed. This approach can stabilize and
              accelerate the process in case of large feature spaces (e.g > 500 features).
  \default{False}

            \item \xmlNode{applyCrossCorrelation}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              In case of subgroupping, should a cross correleation analysis should be performed
              cross sub-groups?         If it is activated, a cross correleation analysis is used to
              additionally filter the features selected for each         sub-groupping search.
  \default{False}

            \item \xmlNode{step}: \xmlDesc{float}, 
              If greater than or equal to 1, then step corresponds to the (integer) number
              of features to remove at each iteration. If within (0.0, 1.0), then step
              corresponds to the percentage (rounded down) of features to remove at         each
              iteration.
  \default{1}

            \item \xmlNode{subGroup}: \xmlDesc{comma-separated strings, integers, and floats}, 
              Subgroup of output variables on which to perform the search. Multiple nodes of this
              type can be inputted. The RFE search will be then performed in each ``subgroup''
              separately and then the the union of the different feature sets are used for the final
              ROM.
          \end{itemize}

        \item \xmlNode{VarianceThreshold}:
          The \xmlString{VarianceThreshold} is a feature selector that removes     all low-variance
          features. This feature selection algorithm looks only at the features and not     the
          desired outputs. The variance threshold can be set by the user.
          The \xmlNode{VarianceThreshold} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{VarianceThreshold} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{threshold}: \xmlDesc{float}, 
              Features with a training-set variance lower than this threshold                   will
              be removed. The default is to keep all features with non-zero
              variance, i.e. remove the features that have the same value in all
              samples.
  \default{0.0}
          \end{itemize}
      \end{itemize}

    \item \xmlNode{featureSpaceTransformation}:
      Use dimensionality reduction technique to perform a trasformation of the training dataset
      into an uncorrelated one. The dimensionality of the problem will not be reduced but
      the data will be transformed in the transformed space. E.g if the number of features
      are 5, the method projects such features into a new uncorrelated space (still 5-dimensional).
      In case of time-dependent ROMs, all the samples are concatenated in a global 2D matrix
      (n\_samples*n\_timesteps,n\_features) before applying the transformation and then reconstructed
      back into the original shape (before fitting the model).

      The \xmlNode{featureSpaceTransformation} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{transformationMethod}: \xmlDesc{[PCA, KernelLinearPCA, KernelPolyPCA, KernelRbfPCA, KernelSigmoidPCA, KernelCosinePCA, ICA]}, 
          Transformation method to use. Eight options (5 Kernel PCAs) are available:
          \begin{itemize}                     \item \textit{PCA}, Principal Component Analysis;
          \item \textit{KernelLinearPCA}, Kernel (Linear) Principal component analysis;
          \item \textit{KernelPolyPCA}, Kernel (Poly) Principal component analysis;
          \item \textit{KernelRbfPCA}, Kernel(Rbf) Principal component analysis;
          \item \textit{KernelSigmoidPCA}, Kernel (Sigmoid) Principal component analysis;
          \item \textit{KernelCosinePCA}, Kernel (Cosine) Principal component analysis;
          \item \textit{ICA}, Independent component analysis;                    \end{itemize}
  \default{PCA}

        \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
          List of IDs of features/variables to include in the transformation process.
  \default{None}

        \item \xmlNode{whichSpace}: \xmlDesc{string}, 
          Which space to search? Target or Feature?
  \default{Feature}
      \end{itemize}

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{alpha}: \xmlDesc{float}, 
      Regularization strength; must be a positive float. Regularization
      improves the conditioning of the problem and reduces the variance of the estimates.
      Larger values specify stronger regularization. Alpha corresponds to $1 / (2C)$ in other
      linear models such as LogisticRegression or LinearSVC.
  \default{1.0}

    \item \xmlNode{fit\_intercept}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Whether the intercept should be estimated or not. If False,
      the data is assumed to be already centered.
  \default{True}

    \item \xmlNode{normalize}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      This parameter is ignored when fit\_intercept is set to False. If True, the
      regressors X will be normalized before regression by subtracting the mean and dividing
      by the l2-norm.
  \default{False}

    \item \xmlNode{max\_iter}: \xmlDesc{integer}, 
      Maximum number of iterations for conjugate gradient solver.
  \default{None}

    \item \xmlNode{tol}: \xmlDesc{float}, 
      Precision of the solution
  \default{0.001}

    \item \xmlNode{solver}: \xmlDesc{[auto, svd, cholesky, lsqr, sparse\_cg, sag, saga]}, 
      Solver to use in the computational routines:
      \begin{itemize}                                                    \item auto, chooses the
      solver automatically based on the type of data.
      \item svd, uses a Singular Value Decomposition of X to compute the Ridge coefficients. More
      stable for singular                                                                matrices
      than ``cholesky''.                                                    \item cholesky, uses the
      standard scipy.linalg.solve function to obtain a closed-form solution.
      \item sparse\_cg, uses the conjugate gradient solver as found in scipy.sparse.linalg.cg. As an
      iterative algorithm,                                                               this solver
      is more appropriate than ‘cholesky’ for large-scale data (possibility to set tol and
      max\_iter).                                                    \item lsqr, uses the dedicated
      regularized least-squares routine scipy.sparse.linalg.lsqr. It is the fastest and uses
      an iterative procedure.                                                    \item sag, uses a
      Stochastic Average Gradient descent, and ``saga'' uses its improved, unbiased version named
      SAGA.                                                               Both methods also use an
      iterative procedure, and are often faster than other solvers when both
      n\_samples and n\_features are large. Note that ``sag'' and ``saga'' fast convergence is only
      guaranteed on                                                               features with
      approximately the same scale. You can preprocess the data with a scaler from
      sklearn.preprocessing.                                                  \end{itemize}
  \default{auto}

    \item \xmlNode{class\_weight}: \xmlDesc{[balanced]}, 
      If not given, all classes are supposed to have weight one.
      The “balanced” mode uses the values of y to automatically adjust weights
      inversely proportional to class frequencies in the input data
  \default{None}

    \item \xmlNode{random\_state}: \xmlDesc{integer}, 
      Used to shuffle the training data, when shuffle is set to
      True. Pass an int for reproducible output across multiple function calls.
  \default{None}
  \end{itemize}


\subsubsection{RidgeClassifierCV}
  The \xmlNode{RidgeClassifierCV} is a classifier that uses Ridge regression.
  This classifier first converts the target values into {-1, 1} and then treats
  the problem as a regression task (multi-output regression in the multiclass case).
  In addition, a cross-validation method is applied to optimize the hyper-parameter.
  By default, it performs Leave-One-Out Cross-Validation.
  \zNormalizationNotPerformed{RidgeClassifierCV}

  The \xmlNode{RidgeClassifierCV} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{RidgeClassifierCV} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.
  \default{time}

    \item \xmlNode{featureSelection}:
      Apply feature selection algorithm

      The \xmlNode{featureSelection} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{RFE}:
          The \xmlString{RFE} (Recursive Feature Elimination) is a feature selection algorithm.
          Feature selection refers to techniques that select a subset of the most relevant features
          for a model (ROM).         Fewer features can allow ROMs to run more efficiently (less
          space or time complexity) and be more effective.         Indeed, some ROMs (machine
          learning algorithms) can be misled by irrelevant input features, resulting in worse
          predictive performance.         RFE is a wrapper-type feature selection algorithm. This
          means that a different ROM is given and used in the core of the         method,         is
          wrapped by RFE, and used to help select features.         \\RFE works by searching for a
          subset of features by starting with all features in the training dataset and successfully
          removing         features until the desired number remains.         This is achieved by
          fitting the given ROME used in the core of the model, ranking features by importance,
          discarding the least important features, and re-fitting the model. This process is
          repeated until a specified number of         features remains.         When the full model
          is created, a measure of variable importance is computed that ranks the predictors from
          most         important to least.         At each stage of the search, the least important
          predictors are iteratively eliminated prior to rebuilding the model.         Features are
          scored either using the ROM model (if the model provides a mean to compute feature
          importances) or by         using a statistical method.         \\In RAVEN the
          \xmlString{RFE} class refers to an augmentation of the basic algorithm, since it allows,
          optionally,         to perform the search on multiple groups of targets (separately) and
          then combine the results of the search in a         single set. In addition, when the RFE
          search is concluded, the user can request to identify the set of features         that
          bring to a minimization of the score (i.e. maximimization of the accuracy).         In
          addition, using the ``applyClusteringFiltering'' option, the algorithm can, using an
          hierarchal clustering algorithm,         identify highly correlated features to speed up
          the subsequential search.
          The \xmlNode{RFE} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{RFE} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{nFeaturesToSelect}: \xmlDesc{integer}, 
              Exact Number of features to select. If not inputted, ``nFeaturesToSelect'' will be set
              to $1/2$ of the features in the training dataset.
  \default{None}

            \item \xmlNode{maxNumberFeatures}: \xmlDesc{integer}, 
              Maximum Number of features to select, the algorithm will automatically determine the
              feature list to minimize a total score.
  \default{None}

            \item \xmlNode{onlyOutputScore}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              If maxNumberFeatures is on, only output score should beconsidered? Or, in case of
              particular models (e.g. DMDC), state variable space score should be considered as
              well.
  \default{False}

            \item \xmlNode{applyClusteringFiltering}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              Applying clustering correlation before RFE search? If true, an hierarchal clustering
              is applied on the feature         space aimed to remove features that are correlated
              before the actual RFE search is performed. This approach can stabilize and
              accelerate the process in case of large feature spaces (e.g > 500 features).
  \default{False}

            \item \xmlNode{applyCrossCorrelation}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              In case of subgroupping, should a cross correleation analysis should be performed
              cross sub-groups?         If it is activated, a cross correleation analysis is used to
              additionally filter the features selected for each         sub-groupping search.
  \default{False}

            \item \xmlNode{step}: \xmlDesc{float}, 
              If greater than or equal to 1, then step corresponds to the (integer) number
              of features to remove at each iteration. If within (0.0, 1.0), then step
              corresponds to the percentage (rounded down) of features to remove at         each
              iteration.
  \default{1}

            \item \xmlNode{subGroup}: \xmlDesc{comma-separated strings, integers, and floats}, 
              Subgroup of output variables on which to perform the search. Multiple nodes of this
              type can be inputted. The RFE search will be then performed in each ``subgroup''
              separately and then the the union of the different feature sets are used for the final
              ROM.
          \end{itemize}

        \item \xmlNode{VarianceThreshold}:
          The \xmlString{VarianceThreshold} is a feature selector that removes     all low-variance
          features. This feature selection algorithm looks only at the features and not     the
          desired outputs. The variance threshold can be set by the user.
          The \xmlNode{VarianceThreshold} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{VarianceThreshold} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{threshold}: \xmlDesc{float}, 
              Features with a training-set variance lower than this threshold                   will
              be removed. The default is to keep all features with non-zero
              variance, i.e. remove the features that have the same value in all
              samples.
  \default{0.0}
          \end{itemize}
      \end{itemize}

    \item \xmlNode{featureSpaceTransformation}:
      Use dimensionality reduction technique to perform a trasformation of the training dataset
      into an uncorrelated one. The dimensionality of the problem will not be reduced but
      the data will be transformed in the transformed space. E.g if the number of features
      are 5, the method projects such features into a new uncorrelated space (still 5-dimensional).
      In case of time-dependent ROMs, all the samples are concatenated in a global 2D matrix
      (n\_samples*n\_timesteps,n\_features) before applying the transformation and then reconstructed
      back into the original shape (before fitting the model).

      The \xmlNode{featureSpaceTransformation} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{transformationMethod}: \xmlDesc{[PCA, KernelLinearPCA, KernelPolyPCA, KernelRbfPCA, KernelSigmoidPCA, KernelCosinePCA, ICA]}, 
          Transformation method to use. Eight options (5 Kernel PCAs) are available:
          \begin{itemize}                     \item \textit{PCA}, Principal Component Analysis;
          \item \textit{KernelLinearPCA}, Kernel (Linear) Principal component analysis;
          \item \textit{KernelPolyPCA}, Kernel (Poly) Principal component analysis;
          \item \textit{KernelRbfPCA}, Kernel(Rbf) Principal component analysis;
          \item \textit{KernelSigmoidPCA}, Kernel (Sigmoid) Principal component analysis;
          \item \textit{KernelCosinePCA}, Kernel (Cosine) Principal component analysis;
          \item \textit{ICA}, Independent component analysis;                    \end{itemize}
  \default{PCA}

        \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
          List of IDs of features/variables to include in the transformation process.
  \default{None}

        \item \xmlNode{whichSpace}: \xmlDesc{string}, 
          Which space to search? Target or Feature?
  \default{Feature}
      \end{itemize}

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{fit\_intercept}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Whether the intercept should be estimated or not. If False,
      the data is assumed to be already centered.
  \default{True}

    \item \xmlNode{normalize}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      This parameter is ignored when fit\_intercept is set to False. If True, the
      regressors X will be normalized before regression by subtracting the mean and dividing
      by the l2-norm.
  \default{False}

    \item \xmlNode{cv}: \xmlDesc{integer}, 
      Determines the cross-validation splitting strategy.
      It specifies the number of folds..
  \default{None}

    \item \xmlNode{alphas}: \xmlDesc{comma-separated floats}, 
      Array of alpha values to try. Regularization strength; must be a positive float.
      Regularization                                                  improves the conditioning of
      the problem and reduces the variance of the estimates.
      Larger values specify stronger regularization. Alpha corresponds to $1 / (2C)$ in other
      linear models such as LogisticRegression or LinearSVC.
  \default{[0.1, 1.0, 10.0]}

    \item \xmlNode{scoring}: \xmlDesc{string}, 
      A string (see model evaluation documentation) or a scorer
      callable object / function with signature.
  \default{None}

    \item \xmlNode{class\_weight}: \xmlDesc{[balanced]}, 
      If not given, all classes are supposed to have weight one.
      The “balanced” mode uses the values of y to automatically adjust weights
      inversely proportional to class frequencies in the input data
  \default{None}

    \item \xmlNode{store\_cv\_values}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Flag indicating if the cross-validation values corresponding
      to each alpha should be stored in the cv\_values\_ attribute (see below).
      This flag is only compatible with cv=None (i.e. using Leave-One-Out
      Cross-Validation).
  \default{False}
  \end{itemize}


\subsubsection{SGDClassifier}
  The \xmlNode{SGDClassifier} implements regularized linear models with stochastic
  gradient descent (SGD) learning for classification: the gradient of the loss is estimated each
  sample at                         a time and the model is updated along the way with a decreasing
  strength schedule                         (aka learning rate). For best results using the default
  learning rate schedule, the                         data should have zero mean and unit variance.
  This implementation works with data represented as dense or sparse arrays of floating
  point values for the features. The model it fits can be controlled with the loss parameter;
  by default, it fits a linear support vector machine (SVM).                         The regularizer
  is a penalty added to the loss function that shrinks model parameters towards
  the zero vector using either the squared euclidean norm L2 or the absolute norm L1 or a
  combination of both (Elastic Net). If the parameter update crosses the 0.0 value because
  of the regularizer, the update is truncated to $0.0$ to allow for learning sparse models and
  achieve online feature selection.                         \zNormalizationPerformed{SGDClassifier}

  The \xmlNode{SGDClassifier} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{SGDClassifier} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.
  \default{time}

    \item \xmlNode{featureSelection}:
      Apply feature selection algorithm

      The \xmlNode{featureSelection} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{RFE}:
          The \xmlString{RFE} (Recursive Feature Elimination) is a feature selection algorithm.
          Feature selection refers to techniques that select a subset of the most relevant features
          for a model (ROM).         Fewer features can allow ROMs to run more efficiently (less
          space or time complexity) and be more effective.         Indeed, some ROMs (machine
          learning algorithms) can be misled by irrelevant input features, resulting in worse
          predictive performance.         RFE is a wrapper-type feature selection algorithm. This
          means that a different ROM is given and used in the core of the         method,         is
          wrapped by RFE, and used to help select features.         \\RFE works by searching for a
          subset of features by starting with all features in the training dataset and successfully
          removing         features until the desired number remains.         This is achieved by
          fitting the given ROME used in the core of the model, ranking features by importance,
          discarding the least important features, and re-fitting the model. This process is
          repeated until a specified number of         features remains.         When the full model
          is created, a measure of variable importance is computed that ranks the predictors from
          most         important to least.         At each stage of the search, the least important
          predictors are iteratively eliminated prior to rebuilding the model.         Features are
          scored either using the ROM model (if the model provides a mean to compute feature
          importances) or by         using a statistical method.         \\In RAVEN the
          \xmlString{RFE} class refers to an augmentation of the basic algorithm, since it allows,
          optionally,         to perform the search on multiple groups of targets (separately) and
          then combine the results of the search in a         single set. In addition, when the RFE
          search is concluded, the user can request to identify the set of features         that
          bring to a minimization of the score (i.e. maximimization of the accuracy).         In
          addition, using the ``applyClusteringFiltering'' option, the algorithm can, using an
          hierarchal clustering algorithm,         identify highly correlated features to speed up
          the subsequential search.
          The \xmlNode{RFE} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{RFE} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{nFeaturesToSelect}: \xmlDesc{integer}, 
              Exact Number of features to select. If not inputted, ``nFeaturesToSelect'' will be set
              to $1/2$ of the features in the training dataset.
  \default{None}

            \item \xmlNode{maxNumberFeatures}: \xmlDesc{integer}, 
              Maximum Number of features to select, the algorithm will automatically determine the
              feature list to minimize a total score.
  \default{None}

            \item \xmlNode{onlyOutputScore}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              If maxNumberFeatures is on, only output score should beconsidered? Or, in case of
              particular models (e.g. DMDC), state variable space score should be considered as
              well.
  \default{False}

            \item \xmlNode{applyClusteringFiltering}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              Applying clustering correlation before RFE search? If true, an hierarchal clustering
              is applied on the feature         space aimed to remove features that are correlated
              before the actual RFE search is performed. This approach can stabilize and
              accelerate the process in case of large feature spaces (e.g > 500 features).
  \default{False}

            \item \xmlNode{applyCrossCorrelation}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              In case of subgroupping, should a cross correleation analysis should be performed
              cross sub-groups?         If it is activated, a cross correleation analysis is used to
              additionally filter the features selected for each         sub-groupping search.
  \default{False}

            \item \xmlNode{step}: \xmlDesc{float}, 
              If greater than or equal to 1, then step corresponds to the (integer) number
              of features to remove at each iteration. If within (0.0, 1.0), then step
              corresponds to the percentage (rounded down) of features to remove at         each
              iteration.
  \default{1}

            \item \xmlNode{subGroup}: \xmlDesc{comma-separated strings, integers, and floats}, 
              Subgroup of output variables on which to perform the search. Multiple nodes of this
              type can be inputted. The RFE search will be then performed in each ``subgroup''
              separately and then the the union of the different feature sets are used for the final
              ROM.
          \end{itemize}

        \item \xmlNode{VarianceThreshold}:
          The \xmlString{VarianceThreshold} is a feature selector that removes     all low-variance
          features. This feature selection algorithm looks only at the features and not     the
          desired outputs. The variance threshold can be set by the user.
          The \xmlNode{VarianceThreshold} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{VarianceThreshold} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{threshold}: \xmlDesc{float}, 
              Features with a training-set variance lower than this threshold                   will
              be removed. The default is to keep all features with non-zero
              variance, i.e. remove the features that have the same value in all
              samples.
  \default{0.0}
          \end{itemize}
      \end{itemize}

    \item \xmlNode{featureSpaceTransformation}:
      Use dimensionality reduction technique to perform a trasformation of the training dataset
      into an uncorrelated one. The dimensionality of the problem will not be reduced but
      the data will be transformed in the transformed space. E.g if the number of features
      are 5, the method projects such features into a new uncorrelated space (still 5-dimensional).
      In case of time-dependent ROMs, all the samples are concatenated in a global 2D matrix
      (n\_samples*n\_timesteps,n\_features) before applying the transformation and then reconstructed
      back into the original shape (before fitting the model).

      The \xmlNode{featureSpaceTransformation} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{transformationMethod}: \xmlDesc{[PCA, KernelLinearPCA, KernelPolyPCA, KernelRbfPCA, KernelSigmoidPCA, KernelCosinePCA, ICA]}, 
          Transformation method to use. Eight options (5 Kernel PCAs) are available:
          \begin{itemize}                     \item \textit{PCA}, Principal Component Analysis;
          \item \textit{KernelLinearPCA}, Kernel (Linear) Principal component analysis;
          \item \textit{KernelPolyPCA}, Kernel (Poly) Principal component analysis;
          \item \textit{KernelRbfPCA}, Kernel(Rbf) Principal component analysis;
          \item \textit{KernelSigmoidPCA}, Kernel (Sigmoid) Principal component analysis;
          \item \textit{KernelCosinePCA}, Kernel (Cosine) Principal component analysis;
          \item \textit{ICA}, Independent component analysis;                    \end{itemize}
  \default{PCA}

        \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
          List of IDs of features/variables to include in the transformation process.
  \default{None}

        \item \xmlNode{whichSpace}: \xmlDesc{string}, 
          Which space to search? Target or Feature?
  \default{Feature}
      \end{itemize}

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{loss}: \xmlDesc{[hinge, log, modified\_huber, squared\_hinge, perceptron, squared\_loss, huber, epsilon\_insensitive, squared\_epsilon\_insensitive]}, 
      The loss function to be used. Defaults to ``hinge'', which gives a linear SVM.The ``log'' loss
      gives logistic regression, a                                                  probabilistic
      classifier. ``modified\_huber'' is another smooth loss that brings tolerance to outliers as
      well as probability estimates.
      ``squared\_hinge'' is like hinge but is quadratically penalized. ``perceptron'' is the linear
      loss used by the perceptron algorithm.                                                  The
      other losses are designed for regression but can be useful in classification as well; see
      SGDRegressor for a description.
  \default{hinge}

    \item \xmlNode{penalty}: \xmlDesc{[l2, l1, elasticnet]}, 
      The penalty (aka regularization term) to be used. Defaults to ``l2'' which is the standard
      regularizer for linear SVM models.                                                  ``l1'' and
      ``elasticnet'' might bring sparsity to the model (feature selection) not achievable with
      ``l2''.
  \default{l2}

    \item \xmlNode{alpha}: \xmlDesc{float}, 
      Constant that multiplies the regularization term. The higher the value, the stronger the
      regularization. Also used to compute                                                  the
      learning rate when set to learning\_rate is set to ``optimal''.
  \default{0.0001}

    \item \xmlNode{l1\_ratio}: \xmlDesc{float}, 
      The Elastic Net mixing parameter, with $0 <= l1\_ratio <= 1$. $l1\_ratio=0$ corresponds to L2
      penalty, $l1\_ratio=1$ to L1.                                                  Only used if
      penalty is ``elasticnet''.
  \default{0.15}

    \item \xmlNode{fit\_intercept}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Whether the intercept should be estimated or not. If False,
      the data is assumed to be already centered.
  \default{True}

    \item \xmlNode{max\_iter}: \xmlDesc{integer}, 
      The maximum number of passes over the training data (aka epochs).
  \default{1000}

    \item \xmlNode{tol}: \xmlDesc{float}, 
      The stopping criterion. If it is not None, training will stop when $(loss > best\_loss - tol)$
      for $n\_iter\_no\_change$                                                  consecutive epochs.
  \default{0.001}

    \item \xmlNode{shuffle}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      TWhether or not the training data should be shuffled after each epoch
  \default{True}

    \item \xmlNode{epsilon}: \xmlDesc{float}, 
      Epsilon in the epsilon-insensitive loss functions; only if loss is ``huber'',
      ``epsilon\_insensitive'', or
      ``squared\_epsilon\_insensitive''. For ``huber'', determines the threshold at which it becomes
      less important to get the                                                  prediction exactly
      right. For epsilon-insensitive, any differences between the current prediction and the correct
      label                                                  are ignored if they are less than this
      threshold.
  \default{0.1}

    \item \xmlNode{learning\_rate}: \xmlDesc{[constant, optimal, invscaling, adaptive]}, 
      The learning rate schedule:                                                  \begin{itemize}
      \item constant: $eta = eta0$                                                   \item optimal:
      $eta = 1.0 / (alpha * (t + t0))$ where t0 is chosen by a heuristic proposed by Leon Bottou.
      \item invscaling: $eta = eta0 / pow(t, power\_t)$
      \item adaptive: $eta = eta0$, as long as the training keeps decreasing. Each time
      n\_iter\_no\_change consecutive epochs fail
      to decrease the training loss by tol or fail to increase validation score by tol if
      early\_stopping is True, the current
      learning rate is divided by 5.                                                  \end{itemize}
  \default{optimal}

    \item \xmlNode{eta0}: \xmlDesc{float}, 
      The initial learning rate for the ``constant'', ``invscaling'' or ``adaptive'' schedules. The
      default value is 0.0                                                  as eta0 is not used by
      the default schedule ``optimal''.
  \default{0.0}

    \item \xmlNode{power\_t}: \xmlDesc{float}, 
      The exponent for inverse scaling learning rate.
  \default{0.5}

    \item \xmlNode{early\_stopping}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      hether to use early stopping to terminate training when validation score is not
      improving. If set to True, it will automatically set aside a stratified fraction of training
      data as validation and terminate training when validation score is not improving by at least
      tol for n\_iter\_no\_change consecutive epochs.
  \default{False}

    \item \xmlNode{validation\_fraction}: \xmlDesc{float}, 
      The proportion of training data to set aside as validation set for early stopping.
      Must be between 0 and 1. Only used if early\_stopping is True.
  \default{0.1}

    \item \xmlNode{n\_iter\_no\_change}: \xmlDesc{integer}, 
      Number of iterations with no improvement to wait before early stopping.
  \default{5}

    \item \xmlNode{random\_state}: \xmlDesc{integer}, 
      Used to shuffle the training data, when shuffle is set to
      True. Pass an int for reproducible output across multiple function calls.
  \default{None}

    \item \xmlNode{verbose}: \xmlDesc{integer}, 
      The verbosity level
  \default{0}

    \item \xmlNode{class\_weight}: \xmlDesc{[balanced]}, 
      If not given, all classes are supposed to have weight one.
      The “balanced” mode uses the values of y to automatically adjust weights
      inversely proportional to class frequencies in the input data
  \default{None}

    \item \xmlNode{warm\_start}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      When set to True, reuse the solution of the previous call
      to fit as initialization, otherwise, just erase the previous solution.
  \default{False}

    \item \xmlNode{average}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      When set to True, computes the averaged SGD weights accross
      all updates and stores the result in the coef\_ attribute.
  \default{False}
  \end{itemize}


\subsubsection{SGDRegressor}
  The \xmlNode{SGDRegressor} implements regularized linear models with stochastic
  gradient descent (SGD) learning for regression: the gradient of the loss is estimated each sample
  at                         a time and the model is updated along the way with a decreasing
  strength schedule                         (aka learning rate). For best results using the default
  learning rate schedule, the                         data should have zero mean and unit variance.
  This implementation works with data represented as dense or sparse arrays of floating
  point values for the features. The model it fits can be controlled with the loss parameter;
  by default, it fits a linear support vector machine (SVM).                         The regularizer
  is a penalty added to the loss function that shrinks model parameters towards
  the zero vector using either the squared euclidean norm L2 or the absolute norm L1 or a
  combination of both (Elastic Net). If the parameter update crosses the 0.0 value because
  of the regularizer, the update is truncated to $0.0$ to allow for learning sparse models and
  achieve online feature selection.                         This implementation works with data
  represented as dense arrays of floating point values for the features.
  \zNormalizationPerformed{SGDRegressor}

  The \xmlNode{SGDRegressor} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{SGDRegressor} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.
  \default{time}

    \item \xmlNode{featureSelection}:
      Apply feature selection algorithm

      The \xmlNode{featureSelection} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{RFE}:
          The \xmlString{RFE} (Recursive Feature Elimination) is a feature selection algorithm.
          Feature selection refers to techniques that select a subset of the most relevant features
          for a model (ROM).         Fewer features can allow ROMs to run more efficiently (less
          space or time complexity) and be more effective.         Indeed, some ROMs (machine
          learning algorithms) can be misled by irrelevant input features, resulting in worse
          predictive performance.         RFE is a wrapper-type feature selection algorithm. This
          means that a different ROM is given and used in the core of the         method,         is
          wrapped by RFE, and used to help select features.         \\RFE works by searching for a
          subset of features by starting with all features in the training dataset and successfully
          removing         features until the desired number remains.         This is achieved by
          fitting the given ROME used in the core of the model, ranking features by importance,
          discarding the least important features, and re-fitting the model. This process is
          repeated until a specified number of         features remains.         When the full model
          is created, a measure of variable importance is computed that ranks the predictors from
          most         important to least.         At each stage of the search, the least important
          predictors are iteratively eliminated prior to rebuilding the model.         Features are
          scored either using the ROM model (if the model provides a mean to compute feature
          importances) or by         using a statistical method.         \\In RAVEN the
          \xmlString{RFE} class refers to an augmentation of the basic algorithm, since it allows,
          optionally,         to perform the search on multiple groups of targets (separately) and
          then combine the results of the search in a         single set. In addition, when the RFE
          search is concluded, the user can request to identify the set of features         that
          bring to a minimization of the score (i.e. maximimization of the accuracy).         In
          addition, using the ``applyClusteringFiltering'' option, the algorithm can, using an
          hierarchal clustering algorithm,         identify highly correlated features to speed up
          the subsequential search.
          The \xmlNode{RFE} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{RFE} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{nFeaturesToSelect}: \xmlDesc{integer}, 
              Exact Number of features to select. If not inputted, ``nFeaturesToSelect'' will be set
              to $1/2$ of the features in the training dataset.
  \default{None}

            \item \xmlNode{maxNumberFeatures}: \xmlDesc{integer}, 
              Maximum Number of features to select, the algorithm will automatically determine the
              feature list to minimize a total score.
  \default{None}

            \item \xmlNode{onlyOutputScore}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              If maxNumberFeatures is on, only output score should beconsidered? Or, in case of
              particular models (e.g. DMDC), state variable space score should be considered as
              well.
  \default{False}

            \item \xmlNode{applyClusteringFiltering}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              Applying clustering correlation before RFE search? If true, an hierarchal clustering
              is applied on the feature         space aimed to remove features that are correlated
              before the actual RFE search is performed. This approach can stabilize and
              accelerate the process in case of large feature spaces (e.g > 500 features).
  \default{False}

            \item \xmlNode{applyCrossCorrelation}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              In case of subgroupping, should a cross correleation analysis should be performed
              cross sub-groups?         If it is activated, a cross correleation analysis is used to
              additionally filter the features selected for each         sub-groupping search.
  \default{False}

            \item \xmlNode{step}: \xmlDesc{float}, 
              If greater than or equal to 1, then step corresponds to the (integer) number
              of features to remove at each iteration. If within (0.0, 1.0), then step
              corresponds to the percentage (rounded down) of features to remove at         each
              iteration.
  \default{1}

            \item \xmlNode{subGroup}: \xmlDesc{comma-separated strings, integers, and floats}, 
              Subgroup of output variables on which to perform the search. Multiple nodes of this
              type can be inputted. The RFE search will be then performed in each ``subgroup''
              separately and then the the union of the different feature sets are used for the final
              ROM.
          \end{itemize}

        \item \xmlNode{VarianceThreshold}:
          The \xmlString{VarianceThreshold} is a feature selector that removes     all low-variance
          features. This feature selection algorithm looks only at the features and not     the
          desired outputs. The variance threshold can be set by the user.
          The \xmlNode{VarianceThreshold} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{VarianceThreshold} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{threshold}: \xmlDesc{float}, 
              Features with a training-set variance lower than this threshold                   will
              be removed. The default is to keep all features with non-zero
              variance, i.e. remove the features that have the same value in all
              samples.
  \default{0.0}
          \end{itemize}
      \end{itemize}

    \item \xmlNode{featureSpaceTransformation}:
      Use dimensionality reduction technique to perform a trasformation of the training dataset
      into an uncorrelated one. The dimensionality of the problem will not be reduced but
      the data will be transformed in the transformed space. E.g if the number of features
      are 5, the method projects such features into a new uncorrelated space (still 5-dimensional).
      In case of time-dependent ROMs, all the samples are concatenated in a global 2D matrix
      (n\_samples*n\_timesteps,n\_features) before applying the transformation and then reconstructed
      back into the original shape (before fitting the model).

      The \xmlNode{featureSpaceTransformation} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{transformationMethod}: \xmlDesc{[PCA, KernelLinearPCA, KernelPolyPCA, KernelRbfPCA, KernelSigmoidPCA, KernelCosinePCA, ICA]}, 
          Transformation method to use. Eight options (5 Kernel PCAs) are available:
          \begin{itemize}                     \item \textit{PCA}, Principal Component Analysis;
          \item \textit{KernelLinearPCA}, Kernel (Linear) Principal component analysis;
          \item \textit{KernelPolyPCA}, Kernel (Poly) Principal component analysis;
          \item \textit{KernelRbfPCA}, Kernel(Rbf) Principal component analysis;
          \item \textit{KernelSigmoidPCA}, Kernel (Sigmoid) Principal component analysis;
          \item \textit{KernelCosinePCA}, Kernel (Cosine) Principal component analysis;
          \item \textit{ICA}, Independent component analysis;                    \end{itemize}
  \default{PCA}

        \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
          List of IDs of features/variables to include in the transformation process.
  \default{None}

        \item \xmlNode{whichSpace}: \xmlDesc{string}, 
          Which space to search? Target or Feature?
  \default{Feature}
      \end{itemize}

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{loss}: \xmlDesc{[squared\_loss, huber, epsilon\_insensitive, squared\_epsilon\_insensitive]}, 
      The loss function to be used.                                                  The
      ``squared\_loss'' refers to the ordinary least squares fit. ``huber'' modifies
      ``squared\_loss'' to focus less on getting outliers correct by
      switching from squared to linear loss past a distance of epsilon. ``epsilon\_insensitive''
      ignores errors less than epsilon and is linear past
      that; this is the loss function used in SVR. ``squared\_epsilon\_insensitive'' is the same but
      becomes squared loss past a tolerance of epsilon.
  \default{squared\_loss}

    \item \xmlNode{penalty}: \xmlDesc{[l2, l1, elasticnet]}, 
      The penalty (aka regularization term) to be used. Defaults to ``l2'' which is the standard
      regularizer for linear SVM models.                                                  ``l1'' and
      ``elasticnet'' might bring sparsity to the model (feature selection) not achievable with
      ``l2''.
  \default{l2}

    \item \xmlNode{alpha}: \xmlDesc{float}, 
      Constant that multiplies the regularization term. The higher the value, the stronger the
      regularization. Also used to compute                                                  the
      learning rate when set to learning\_rate is set to ``optimal''.
  \default{0.0001}

    \item \xmlNode{l1\_ratio}: \xmlDesc{float}, 
      The Elastic Net mixing parameter, with $0 <= l1\_ratio <= 1$. $l1\_ratio=0$ corresponds to L2
      penalty, $l1\_ratio=1$ to L1.                                                  Only used if
      penalty is ``elasticnet''.
  \default{0.15}

    \item \xmlNode{fit\_intercept}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Whether the intercept should be estimated or not. If False,
      the data is assumed to be already centered.
  \default{True}

    \item \xmlNode{max\_iter}: \xmlDesc{integer}, 
      The maximum number of passes over the training data (aka epochs).
  \default{1000}

    \item \xmlNode{tol}: \xmlDesc{float}, 
      The stopping criterion. If it is not None, training will stop when $(loss > best\_loss - tol)$
      for $n\_iter\_no\_change$                                                  consecutive epochs.
  \default{0.001}

    \item \xmlNode{shuffle}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      TWhether or not the training data should be shuffled after each epoch
  \default{True}

    \item \xmlNode{epsilon}: \xmlDesc{float}, 
      Epsilon in the epsilon-insensitive loss functions; only if loss is ``huber'',
      ``epsilon\_insensitive'', or
      ``squared\_epsilon\_insensitive''. For ``huber'', determines the threshold at which it becomes
      less important to get the                                                  prediction exactly
      right. For epsilon-insensitive, any differences between the current prediction and the correct
      label                                                  are ignored if they are less than this
      threshold.
  \default{0.1}

    \item \xmlNode{learning\_rate}: \xmlDesc{[constant, optimal, invscaling, adaptive]}, 
      The learning rate schedule:                                                  \begin{itemize}
      \item constant: $eta = eta0$                                                   \item optimal:
      $eta = 1.0 / (alpha * (t + t0))$ where t0 is chosen by a heuristic proposed by Leon Bottou.
      \item invscaling: $eta = eta0 / pow(t, power\_t)$
      \item adaptive: $eta = eta0$, as long as the training keeps decreasing. Each time
      n\_iter\_no\_change consecutive epochs fail
      to decrease the training loss by tol or fail to increase validation score by tol if
      early\_stopping is True, the current
      learning rate is divided by 5.                                                  \end{itemize}
  \default{optimal}

    \item \xmlNode{eta0}: \xmlDesc{float}, 
      The initial learning rate for the ``constant'', ``invscaling'' or ``adaptive'' schedules. The
      default value is 0.0                                                  as eta0 is not used by
      the default schedule ``optimal''.
  \default{0.0}

    \item \xmlNode{power\_t}: \xmlDesc{float}, 
      The exponent for inverse scaling learning rate.
  \default{0.5}

    \item \xmlNode{early\_stopping}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      hether to use early stopping to terminate training when validation score is not
      improving. If set to True, it will automatically set aside a stratified fraction of training
      data as validation and terminate training when validation score is not improving by at least
      tol for n\_iter\_no\_change consecutive epochs.
  \default{False}

    \item \xmlNode{validation\_fraction}: \xmlDesc{float}, 
      The proportion of training data to set aside as validation set for early stopping.
      Must be between 0 and 1. Only used if early\_stopping is True.
  \default{0.1}

    \item \xmlNode{n\_iter\_no\_change}: \xmlDesc{integer}, 
      Number of iterations with no improvement to wait before early stopping.
  \default{5}

    \item \xmlNode{random\_state}: \xmlDesc{integer}, 
      Used to shuffle the training data, when shuffle is set to
      True. Pass an int for reproducible output across multiple function calls.
  \default{None}

    \item \xmlNode{verbose}: \xmlDesc{integer}, 
      The verbosity level
  \default{0}

    \item \xmlNode{warm\_start}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      When set to True, reuse the solution of the previous call
      to fit as initialization, otherwise, just erase the previous solution.
  \default{False}

    \item \xmlNode{average}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      When set to True, computes the averaged SGD weights accross
      all updates and stores the result in the coef\_ attribute.
  \default{False}
  \end{itemize}


\subsubsection{ComplementNB}
  The \\textit{ComplementNB} classifier (Complement Naive Bayes classifier) was designed to correct
  the ``severe assumptions'' made by the standard Multinomial Naive Bayes classifier.
  It is particularly suited for imbalanced data sets (see Rennie et al. (2003))
  \zNormalizationPerformed{ComplementNB}

  The \xmlNode{ComplementNB} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{ComplementNB} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.
  \default{time}

    \item \xmlNode{featureSelection}:
      Apply feature selection algorithm

      The \xmlNode{featureSelection} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{RFE}:
          The \xmlString{RFE} (Recursive Feature Elimination) is a feature selection algorithm.
          Feature selection refers to techniques that select a subset of the most relevant features
          for a model (ROM).         Fewer features can allow ROMs to run more efficiently (less
          space or time complexity) and be more effective.         Indeed, some ROMs (machine
          learning algorithms) can be misled by irrelevant input features, resulting in worse
          predictive performance.         RFE is a wrapper-type feature selection algorithm. This
          means that a different ROM is given and used in the core of the         method,         is
          wrapped by RFE, and used to help select features.         \\RFE works by searching for a
          subset of features by starting with all features in the training dataset and successfully
          removing         features until the desired number remains.         This is achieved by
          fitting the given ROME used in the core of the model, ranking features by importance,
          discarding the least important features, and re-fitting the model. This process is
          repeated until a specified number of         features remains.         When the full model
          is created, a measure of variable importance is computed that ranks the predictors from
          most         important to least.         At each stage of the search, the least important
          predictors are iteratively eliminated prior to rebuilding the model.         Features are
          scored either using the ROM model (if the model provides a mean to compute feature
          importances) or by         using a statistical method.         \\In RAVEN the
          \xmlString{RFE} class refers to an augmentation of the basic algorithm, since it allows,
          optionally,         to perform the search on multiple groups of targets (separately) and
          then combine the results of the search in a         single set. In addition, when the RFE
          search is concluded, the user can request to identify the set of features         that
          bring to a minimization of the score (i.e. maximimization of the accuracy).         In
          addition, using the ``applyClusteringFiltering'' option, the algorithm can, using an
          hierarchal clustering algorithm,         identify highly correlated features to speed up
          the subsequential search.
          The \xmlNode{RFE} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{RFE} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{nFeaturesToSelect}: \xmlDesc{integer}, 
              Exact Number of features to select. If not inputted, ``nFeaturesToSelect'' will be set
              to $1/2$ of the features in the training dataset.
  \default{None}

            \item \xmlNode{maxNumberFeatures}: \xmlDesc{integer}, 
              Maximum Number of features to select, the algorithm will automatically determine the
              feature list to minimize a total score.
  \default{None}

            \item \xmlNode{onlyOutputScore}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              If maxNumberFeatures is on, only output score should beconsidered? Or, in case of
              particular models (e.g. DMDC), state variable space score should be considered as
              well.
  \default{False}

            \item \xmlNode{applyClusteringFiltering}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              Applying clustering correlation before RFE search? If true, an hierarchal clustering
              is applied on the feature         space aimed to remove features that are correlated
              before the actual RFE search is performed. This approach can stabilize and
              accelerate the process in case of large feature spaces (e.g > 500 features).
  \default{False}

            \item \xmlNode{applyCrossCorrelation}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              In case of subgroupping, should a cross correleation analysis should be performed
              cross sub-groups?         If it is activated, a cross correleation analysis is used to
              additionally filter the features selected for each         sub-groupping search.
  \default{False}

            \item \xmlNode{step}: \xmlDesc{float}, 
              If greater than or equal to 1, then step corresponds to the (integer) number
              of features to remove at each iteration. If within (0.0, 1.0), then step
              corresponds to the percentage (rounded down) of features to remove at         each
              iteration.
  \default{1}

            \item \xmlNode{subGroup}: \xmlDesc{comma-separated strings, integers, and floats}, 
              Subgroup of output variables on which to perform the search. Multiple nodes of this
              type can be inputted. The RFE search will be then performed in each ``subgroup''
              separately and then the the union of the different feature sets are used for the final
              ROM.
          \end{itemize}

        \item \xmlNode{VarianceThreshold}:
          The \xmlString{VarianceThreshold} is a feature selector that removes     all low-variance
          features. This feature selection algorithm looks only at the features and not     the
          desired outputs. The variance threshold can be set by the user.
          The \xmlNode{VarianceThreshold} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{VarianceThreshold} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{threshold}: \xmlDesc{float}, 
              Features with a training-set variance lower than this threshold                   will
              be removed. The default is to keep all features with non-zero
              variance, i.e. remove the features that have the same value in all
              samples.
  \default{0.0}
          \end{itemize}
      \end{itemize}

    \item \xmlNode{featureSpaceTransformation}:
      Use dimensionality reduction technique to perform a trasformation of the training dataset
      into an uncorrelated one. The dimensionality of the problem will not be reduced but
      the data will be transformed in the transformed space. E.g if the number of features
      are 5, the method projects such features into a new uncorrelated space (still 5-dimensional).
      In case of time-dependent ROMs, all the samples are concatenated in a global 2D matrix
      (n\_samples*n\_timesteps,n\_features) before applying the transformation and then reconstructed
      back into the original shape (before fitting the model).

      The \xmlNode{featureSpaceTransformation} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{transformationMethod}: \xmlDesc{[PCA, KernelLinearPCA, KernelPolyPCA, KernelRbfPCA, KernelSigmoidPCA, KernelCosinePCA, ICA]}, 
          Transformation method to use. Eight options (5 Kernel PCAs) are available:
          \begin{itemize}                     \item \textit{PCA}, Principal Component Analysis;
          \item \textit{KernelLinearPCA}, Kernel (Linear) Principal component analysis;
          \item \textit{KernelPolyPCA}, Kernel (Poly) Principal component analysis;
          \item \textit{KernelRbfPCA}, Kernel(Rbf) Principal component analysis;
          \item \textit{KernelSigmoidPCA}, Kernel (Sigmoid) Principal component analysis;
          \item \textit{KernelCosinePCA}, Kernel (Cosine) Principal component analysis;
          \item \textit{ICA}, Independent component analysis;                    \end{itemize}
  \default{PCA}

        \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
          List of IDs of features/variables to include in the transformation process.
  \default{None}

        \item \xmlNode{whichSpace}: \xmlDesc{string}, 
          Which space to search? Target or Feature?
  \default{Feature}
      \end{itemize}

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{alpha}: \xmlDesc{float}, 
      Additive (Laplace and Lidstone) smoothing parameter (0 for no smoothing).
  \default{1.0}

    \item \xmlNode{norm}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Whether or not a second normalization of the weights is performed.
  \default{False}

    \item \xmlNode{class\_prior}: \xmlDesc{comma-separated floats}, 
      Prior probabilities of the classes. If specified the priors are
      not adjusted according to the data. \nb the number of elements inputted here must
      match the number of classes in the data set used in the training stage.
  \default{None}

    \item \xmlNode{fit\_prior}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Whether to learn class prior probabilities or not. If false, a uniform
      prior will be used.
  \default{True}
  \end{itemize}


\subsubsection{CategoricalNB}
  The \\textit{CategoricalNB} classifier (Naive Bayes classifier for categorical features)
  is suitable for classification with discrete features that are categorically distributed.
  The categories of each feature are drawn from a categorical distribution.
  \zNormalizationPerformed{CategoricalNB}

  The \xmlNode{CategoricalNB} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{CategoricalNB} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.
  \default{time}

    \item \xmlNode{featureSelection}:
      Apply feature selection algorithm

      The \xmlNode{featureSelection} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{RFE}:
          The \xmlString{RFE} (Recursive Feature Elimination) is a feature selection algorithm.
          Feature selection refers to techniques that select a subset of the most relevant features
          for a model (ROM).         Fewer features can allow ROMs to run more efficiently (less
          space or time complexity) and be more effective.         Indeed, some ROMs (machine
          learning algorithms) can be misled by irrelevant input features, resulting in worse
          predictive performance.         RFE is a wrapper-type feature selection algorithm. This
          means that a different ROM is given and used in the core of the         method,         is
          wrapped by RFE, and used to help select features.         \\RFE works by searching for a
          subset of features by starting with all features in the training dataset and successfully
          removing         features until the desired number remains.         This is achieved by
          fitting the given ROME used in the core of the model, ranking features by importance,
          discarding the least important features, and re-fitting the model. This process is
          repeated until a specified number of         features remains.         When the full model
          is created, a measure of variable importance is computed that ranks the predictors from
          most         important to least.         At each stage of the search, the least important
          predictors are iteratively eliminated prior to rebuilding the model.         Features are
          scored either using the ROM model (if the model provides a mean to compute feature
          importances) or by         using a statistical method.         \\In RAVEN the
          \xmlString{RFE} class refers to an augmentation of the basic algorithm, since it allows,
          optionally,         to perform the search on multiple groups of targets (separately) and
          then combine the results of the search in a         single set. In addition, when the RFE
          search is concluded, the user can request to identify the set of features         that
          bring to a minimization of the score (i.e. maximimization of the accuracy).         In
          addition, using the ``applyClusteringFiltering'' option, the algorithm can, using an
          hierarchal clustering algorithm,         identify highly correlated features to speed up
          the subsequential search.
          The \xmlNode{RFE} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{RFE} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{nFeaturesToSelect}: \xmlDesc{integer}, 
              Exact Number of features to select. If not inputted, ``nFeaturesToSelect'' will be set
              to $1/2$ of the features in the training dataset.
  \default{None}

            \item \xmlNode{maxNumberFeatures}: \xmlDesc{integer}, 
              Maximum Number of features to select, the algorithm will automatically determine the
              feature list to minimize a total score.
  \default{None}

            \item \xmlNode{onlyOutputScore}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              If maxNumberFeatures is on, only output score should beconsidered? Or, in case of
              particular models (e.g. DMDC), state variable space score should be considered as
              well.
  \default{False}

            \item \xmlNode{applyClusteringFiltering}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              Applying clustering correlation before RFE search? If true, an hierarchal clustering
              is applied on the feature         space aimed to remove features that are correlated
              before the actual RFE search is performed. This approach can stabilize and
              accelerate the process in case of large feature spaces (e.g > 500 features).
  \default{False}

            \item \xmlNode{applyCrossCorrelation}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              In case of subgroupping, should a cross correleation analysis should be performed
              cross sub-groups?         If it is activated, a cross correleation analysis is used to
              additionally filter the features selected for each         sub-groupping search.
  \default{False}

            \item \xmlNode{step}: \xmlDesc{float}, 
              If greater than or equal to 1, then step corresponds to the (integer) number
              of features to remove at each iteration. If within (0.0, 1.0), then step
              corresponds to the percentage (rounded down) of features to remove at         each
              iteration.
  \default{1}

            \item \xmlNode{subGroup}: \xmlDesc{comma-separated strings, integers, and floats}, 
              Subgroup of output variables on which to perform the search. Multiple nodes of this
              type can be inputted. The RFE search will be then performed in each ``subgroup''
              separately and then the the union of the different feature sets are used for the final
              ROM.
          \end{itemize}

        \item \xmlNode{VarianceThreshold}:
          The \xmlString{VarianceThreshold} is a feature selector that removes     all low-variance
          features. This feature selection algorithm looks only at the features and not     the
          desired outputs. The variance threshold can be set by the user.
          The \xmlNode{VarianceThreshold} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{VarianceThreshold} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{threshold}: \xmlDesc{float}, 
              Features with a training-set variance lower than this threshold                   will
              be removed. The default is to keep all features with non-zero
              variance, i.e. remove the features that have the same value in all
              samples.
  \default{0.0}
          \end{itemize}
      \end{itemize}

    \item \xmlNode{featureSpaceTransformation}:
      Use dimensionality reduction technique to perform a trasformation of the training dataset
      into an uncorrelated one. The dimensionality of the problem will not be reduced but
      the data will be transformed in the transformed space. E.g if the number of features
      are 5, the method projects such features into a new uncorrelated space (still 5-dimensional).
      In case of time-dependent ROMs, all the samples are concatenated in a global 2D matrix
      (n\_samples*n\_timesteps,n\_features) before applying the transformation and then reconstructed
      back into the original shape (before fitting the model).

      The \xmlNode{featureSpaceTransformation} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{transformationMethod}: \xmlDesc{[PCA, KernelLinearPCA, KernelPolyPCA, KernelRbfPCA, KernelSigmoidPCA, KernelCosinePCA, ICA]}, 
          Transformation method to use. Eight options (5 Kernel PCAs) are available:
          \begin{itemize}                     \item \textit{PCA}, Principal Component Analysis;
          \item \textit{KernelLinearPCA}, Kernel (Linear) Principal component analysis;
          \item \textit{KernelPolyPCA}, Kernel (Poly) Principal component analysis;
          \item \textit{KernelRbfPCA}, Kernel(Rbf) Principal component analysis;
          \item \textit{KernelSigmoidPCA}, Kernel (Sigmoid) Principal component analysis;
          \item \textit{KernelCosinePCA}, Kernel (Cosine) Principal component analysis;
          \item \textit{ICA}, Independent component analysis;                    \end{itemize}
  \default{PCA}

        \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
          List of IDs of features/variables to include in the transformation process.
  \default{None}

        \item \xmlNode{whichSpace}: \xmlDesc{string}, 
          Which space to search? Target or Feature?
  \default{Feature}
      \end{itemize}

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{alpha}: \xmlDesc{float}, 
      Additive (Laplace and Lidstone) smoothing parameter (0 for no smoothing).
  \default{1.0}

    \item \xmlNode{class\_prior}: \xmlDesc{comma-separated floats}, 
      Prior probabilities of the classes. If specified the priors are
      not adjusted according to the data. \nb the number of elements inputted here must
      match the number of classes in the data set used in the training stage.
  \default{None}

    \item \xmlNode{fit\_prior}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Whether to learn class prior probabilities or not. If false, a uniform
      prior will be used.
  \default{True}
  \end{itemize}


\subsubsection{BernoulliNB}
  The \textit{BernoulliNB} classifier implements the naive Bayes training and
  classification algorithms for data that is distributed according to multivariate
  Bernoulli distributions; i.e., there may be multiple features but each one is
  assumed to be a binary-valued (Bernoulli, boolean) variable.                          Therefore,
  this class requires samples to be represented as binary-valued                          feature
  vectors; if handed any other kind of data, a \textit{Bernoulli Naive
  Bayes} instance may binarize its input (depending on the binarize parameter).
  The decision rule for Bernoulli naive Bayes is based on                          \begin{equation}
  P(x\_i \mid y) = P(i \mid y) x\_i + (1 - P(i \mid y)) (1 - x\_i)
  \end{equation}                          which differs from multinomial NB's rule in that it
  explicitly penalizes the                          non-occurrence of a feature $i$ that is an
  indicator for class $y$, where the                          multinomial variant would simply
  ignore a non-occurring feature.                          In the case of text classification, word
  occurrence vectors (rather than word                          count vectors) may be used to train
  and use this classifier.                          \textit{Bernoulli Naive Bayes} might perform
  better on some datasets, especially                          those with shorter documents.
  \zNormalizationPerformed{BernoulliNB}

  The \xmlNode{BernoulliNB} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{BernoulliNB} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.
  \default{time}

    \item \xmlNode{featureSelection}:
      Apply feature selection algorithm

      The \xmlNode{featureSelection} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{RFE}:
          The \xmlString{RFE} (Recursive Feature Elimination) is a feature selection algorithm.
          Feature selection refers to techniques that select a subset of the most relevant features
          for a model (ROM).         Fewer features can allow ROMs to run more efficiently (less
          space or time complexity) and be more effective.         Indeed, some ROMs (machine
          learning algorithms) can be misled by irrelevant input features, resulting in worse
          predictive performance.         RFE is a wrapper-type feature selection algorithm. This
          means that a different ROM is given and used in the core of the         method,         is
          wrapped by RFE, and used to help select features.         \\RFE works by searching for a
          subset of features by starting with all features in the training dataset and successfully
          removing         features until the desired number remains.         This is achieved by
          fitting the given ROME used in the core of the model, ranking features by importance,
          discarding the least important features, and re-fitting the model. This process is
          repeated until a specified number of         features remains.         When the full model
          is created, a measure of variable importance is computed that ranks the predictors from
          most         important to least.         At each stage of the search, the least important
          predictors are iteratively eliminated prior to rebuilding the model.         Features are
          scored either using the ROM model (if the model provides a mean to compute feature
          importances) or by         using a statistical method.         \\In RAVEN the
          \xmlString{RFE} class refers to an augmentation of the basic algorithm, since it allows,
          optionally,         to perform the search on multiple groups of targets (separately) and
          then combine the results of the search in a         single set. In addition, when the RFE
          search is concluded, the user can request to identify the set of features         that
          bring to a minimization of the score (i.e. maximimization of the accuracy).         In
          addition, using the ``applyClusteringFiltering'' option, the algorithm can, using an
          hierarchal clustering algorithm,         identify highly correlated features to speed up
          the subsequential search.
          The \xmlNode{RFE} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{RFE} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{nFeaturesToSelect}: \xmlDesc{integer}, 
              Exact Number of features to select. If not inputted, ``nFeaturesToSelect'' will be set
              to $1/2$ of the features in the training dataset.
  \default{None}

            \item \xmlNode{maxNumberFeatures}: \xmlDesc{integer}, 
              Maximum Number of features to select, the algorithm will automatically determine the
              feature list to minimize a total score.
  \default{None}

            \item \xmlNode{onlyOutputScore}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              If maxNumberFeatures is on, only output score should beconsidered? Or, in case of
              particular models (e.g. DMDC), state variable space score should be considered as
              well.
  \default{False}

            \item \xmlNode{applyClusteringFiltering}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              Applying clustering correlation before RFE search? If true, an hierarchal clustering
              is applied on the feature         space aimed to remove features that are correlated
              before the actual RFE search is performed. This approach can stabilize and
              accelerate the process in case of large feature spaces (e.g > 500 features).
  \default{False}

            \item \xmlNode{applyCrossCorrelation}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              In case of subgroupping, should a cross correleation analysis should be performed
              cross sub-groups?         If it is activated, a cross correleation analysis is used to
              additionally filter the features selected for each         sub-groupping search.
  \default{False}

            \item \xmlNode{step}: \xmlDesc{float}, 
              If greater than or equal to 1, then step corresponds to the (integer) number
              of features to remove at each iteration. If within (0.0, 1.0), then step
              corresponds to the percentage (rounded down) of features to remove at         each
              iteration.
  \default{1}

            \item \xmlNode{subGroup}: \xmlDesc{comma-separated strings, integers, and floats}, 
              Subgroup of output variables on which to perform the search. Multiple nodes of this
              type can be inputted. The RFE search will be then performed in each ``subgroup''
              separately and then the the union of the different feature sets are used for the final
              ROM.
          \end{itemize}

        \item \xmlNode{VarianceThreshold}:
          The \xmlString{VarianceThreshold} is a feature selector that removes     all low-variance
          features. This feature selection algorithm looks only at the features and not     the
          desired outputs. The variance threshold can be set by the user.
          The \xmlNode{VarianceThreshold} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{VarianceThreshold} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{threshold}: \xmlDesc{float}, 
              Features with a training-set variance lower than this threshold                   will
              be removed. The default is to keep all features with non-zero
              variance, i.e. remove the features that have the same value in all
              samples.
  \default{0.0}
          \end{itemize}
      \end{itemize}

    \item \xmlNode{featureSpaceTransformation}:
      Use dimensionality reduction technique to perform a trasformation of the training dataset
      into an uncorrelated one. The dimensionality of the problem will not be reduced but
      the data will be transformed in the transformed space. E.g if the number of features
      are 5, the method projects such features into a new uncorrelated space (still 5-dimensional).
      In case of time-dependent ROMs, all the samples are concatenated in a global 2D matrix
      (n\_samples*n\_timesteps,n\_features) before applying the transformation and then reconstructed
      back into the original shape (before fitting the model).

      The \xmlNode{featureSpaceTransformation} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{transformationMethod}: \xmlDesc{[PCA, KernelLinearPCA, KernelPolyPCA, KernelRbfPCA, KernelSigmoidPCA, KernelCosinePCA, ICA]}, 
          Transformation method to use. Eight options (5 Kernel PCAs) are available:
          \begin{itemize}                     \item \textit{PCA}, Principal Component Analysis;
          \item \textit{KernelLinearPCA}, Kernel (Linear) Principal component analysis;
          \item \textit{KernelPolyPCA}, Kernel (Poly) Principal component analysis;
          \item \textit{KernelRbfPCA}, Kernel(Rbf) Principal component analysis;
          \item \textit{KernelSigmoidPCA}, Kernel (Sigmoid) Principal component analysis;
          \item \textit{KernelCosinePCA}, Kernel (Cosine) Principal component analysis;
          \item \textit{ICA}, Independent component analysis;                    \end{itemize}
  \default{PCA}

        \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
          List of IDs of features/variables to include in the transformation process.
  \default{None}

        \item \xmlNode{whichSpace}: \xmlDesc{string}, 
          Which space to search? Target or Feature?
  \default{Feature}
      \end{itemize}

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{alpha}: \xmlDesc{float}, 
      Additive (Laplace and Lidstone) smoothing parameter (0 for no smoothing).
  \default{1.0}

    \item \xmlNode{binarize}: \xmlDesc{float}, 
      Threshold for binarizing (mapping to booleans) of sample features. If None,
      input is presumed to already consist of binary vectors.
  \default{None}

    \item \xmlNode{class\_prior}: \xmlDesc{comma-separated floats}, 
      Prior probabilities of the classes. If specified the priors are
      not adjusted according to the data. \nb the number of elements inputted here must
      match the number of classes in the data set used in the training stage.
  \default{None}

    \item \xmlNode{fit\_prior}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Whether to learn class prior probabilities or not. If false, a uniform
      prior will be used.
  \default{True}
  \end{itemize}


\subsubsection{MultinomialNB}
  The \\textit{MultinomialNB} classifier implements the naive Bayes algorithm for
  multinomially distributed data, and is one of the two classic naive Bayes
  variants used in text classification (where the data is typically represented
  as word vector counts, although tf-idf vectors are also known to work well in
  practice).                         The distribution is parametrized by vectors $\theta\_y =
  (\theta\_{y1},\ldots,\theta\_{yn})$ for each class $y$, where $n$ is the number of
  features (in text classification, the size of the vocabulary) and $\theta\_{yi}$
  is the probability $P(x\_i \mid y)$ of feature $i$ appearing in a sample
  belonging to class $y$.                         The parameters $\theta\_y$ are estimated by a
  smoothed version of maximum                         likelihood, i.e. relative frequency counting:
  \begin{equation}                         \hat{\theta}\_{yi} = \frac{ N\_{yi} + \alpha}{N\_y + \alpha
  n}                         \end{equation}                         where $N\_{yi} = \sum\_{x \in T}
  x\_i$ is the number of times feature $i$ appears                         in a sample of class y in
  the training set T, and                         $N\_{y} = \sum\_{i=1}^{|T|} N\_{yi}$ is the total
  count of all features for class                         $y$.                         The smoothing
  priors $\alpha \ge 0$ account for features not present in the                         learning
  samples and prevents zero probabilities in further computations.                         Setting
  $\alpha = 1$ is called Laplace smoothing, while $\alpha < 1$ is called
  Lidstone smoothing.                         \zNormalizationPerformed{MultinomialNB}

  The \xmlNode{MultinomialNB} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{MultinomialNB} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.
  \default{time}

    \item \xmlNode{featureSelection}:
      Apply feature selection algorithm

      The \xmlNode{featureSelection} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{RFE}:
          The \xmlString{RFE} (Recursive Feature Elimination) is a feature selection algorithm.
          Feature selection refers to techniques that select a subset of the most relevant features
          for a model (ROM).         Fewer features can allow ROMs to run more efficiently (less
          space or time complexity) and be more effective.         Indeed, some ROMs (machine
          learning algorithms) can be misled by irrelevant input features, resulting in worse
          predictive performance.         RFE is a wrapper-type feature selection algorithm. This
          means that a different ROM is given and used in the core of the         method,         is
          wrapped by RFE, and used to help select features.         \\RFE works by searching for a
          subset of features by starting with all features in the training dataset and successfully
          removing         features until the desired number remains.         This is achieved by
          fitting the given ROME used in the core of the model, ranking features by importance,
          discarding the least important features, and re-fitting the model. This process is
          repeated until a specified number of         features remains.         When the full model
          is created, a measure of variable importance is computed that ranks the predictors from
          most         important to least.         At each stage of the search, the least important
          predictors are iteratively eliminated prior to rebuilding the model.         Features are
          scored either using the ROM model (if the model provides a mean to compute feature
          importances) or by         using a statistical method.         \\In RAVEN the
          \xmlString{RFE} class refers to an augmentation of the basic algorithm, since it allows,
          optionally,         to perform the search on multiple groups of targets (separately) and
          then combine the results of the search in a         single set. In addition, when the RFE
          search is concluded, the user can request to identify the set of features         that
          bring to a minimization of the score (i.e. maximimization of the accuracy).         In
          addition, using the ``applyClusteringFiltering'' option, the algorithm can, using an
          hierarchal clustering algorithm,         identify highly correlated features to speed up
          the subsequential search.
          The \xmlNode{RFE} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{RFE} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{nFeaturesToSelect}: \xmlDesc{integer}, 
              Exact Number of features to select. If not inputted, ``nFeaturesToSelect'' will be set
              to $1/2$ of the features in the training dataset.
  \default{None}

            \item \xmlNode{maxNumberFeatures}: \xmlDesc{integer}, 
              Maximum Number of features to select, the algorithm will automatically determine the
              feature list to minimize a total score.
  \default{None}

            \item \xmlNode{onlyOutputScore}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              If maxNumberFeatures is on, only output score should beconsidered? Or, in case of
              particular models (e.g. DMDC), state variable space score should be considered as
              well.
  \default{False}

            \item \xmlNode{applyClusteringFiltering}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              Applying clustering correlation before RFE search? If true, an hierarchal clustering
              is applied on the feature         space aimed to remove features that are correlated
              before the actual RFE search is performed. This approach can stabilize and
              accelerate the process in case of large feature spaces (e.g > 500 features).
  \default{False}

            \item \xmlNode{applyCrossCorrelation}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              In case of subgroupping, should a cross correleation analysis should be performed
              cross sub-groups?         If it is activated, a cross correleation analysis is used to
              additionally filter the features selected for each         sub-groupping search.
  \default{False}

            \item \xmlNode{step}: \xmlDesc{float}, 
              If greater than or equal to 1, then step corresponds to the (integer) number
              of features to remove at each iteration. If within (0.0, 1.0), then step
              corresponds to the percentage (rounded down) of features to remove at         each
              iteration.
  \default{1}

            \item \xmlNode{subGroup}: \xmlDesc{comma-separated strings, integers, and floats}, 
              Subgroup of output variables on which to perform the search. Multiple nodes of this
              type can be inputted. The RFE search will be then performed in each ``subgroup''
              separately and then the the union of the different feature sets are used for the final
              ROM.
          \end{itemize}

        \item \xmlNode{VarianceThreshold}:
          The \xmlString{VarianceThreshold} is a feature selector that removes     all low-variance
          features. This feature selection algorithm looks only at the features and not     the
          desired outputs. The variance threshold can be set by the user.
          The \xmlNode{VarianceThreshold} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{VarianceThreshold} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{threshold}: \xmlDesc{float}, 
              Features with a training-set variance lower than this threshold                   will
              be removed. The default is to keep all features with non-zero
              variance, i.e. remove the features that have the same value in all
              samples.
  \default{0.0}
          \end{itemize}
      \end{itemize}

    \item \xmlNode{featureSpaceTransformation}:
      Use dimensionality reduction technique to perform a trasformation of the training dataset
      into an uncorrelated one. The dimensionality of the problem will not be reduced but
      the data will be transformed in the transformed space. E.g if the number of features
      are 5, the method projects such features into a new uncorrelated space (still 5-dimensional).
      In case of time-dependent ROMs, all the samples are concatenated in a global 2D matrix
      (n\_samples*n\_timesteps,n\_features) before applying the transformation and then reconstructed
      back into the original shape (before fitting the model).

      The \xmlNode{featureSpaceTransformation} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{transformationMethod}: \xmlDesc{[PCA, KernelLinearPCA, KernelPolyPCA, KernelRbfPCA, KernelSigmoidPCA, KernelCosinePCA, ICA]}, 
          Transformation method to use. Eight options (5 Kernel PCAs) are available:
          \begin{itemize}                     \item \textit{PCA}, Principal Component Analysis;
          \item \textit{KernelLinearPCA}, Kernel (Linear) Principal component analysis;
          \item \textit{KernelPolyPCA}, Kernel (Poly) Principal component analysis;
          \item \textit{KernelRbfPCA}, Kernel(Rbf) Principal component analysis;
          \item \textit{KernelSigmoidPCA}, Kernel (Sigmoid) Principal component analysis;
          \item \textit{KernelCosinePCA}, Kernel (Cosine) Principal component analysis;
          \item \textit{ICA}, Independent component analysis;                    \end{itemize}
  \default{PCA}

        \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
          List of IDs of features/variables to include in the transformation process.
  \default{None}

        \item \xmlNode{whichSpace}: \xmlDesc{string}, 
          Which space to search? Target or Feature?
  \default{Feature}
      \end{itemize}

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{class\_prior}: \xmlDesc{comma-separated floats}, 
      Prior probabilities of the classes. If specified the priors are
      not adjusted according to the data. \nb the number of elements inputted here must
      match the number of classes in the data set used in the training stage.
  \default{None}

    \item \xmlNode{alpha}: \xmlDesc{float}, 
      Additive (Laplace and Lidstone) smoothing parameter (0 for no smoothing).
  \default{1.0}

    \item \xmlNode{fit\_prior}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Whether to learn class prior probabilities or not. If false, a uniform
      prior will be used.
  \default{True}
  \end{itemize}


\subsubsection{GaussianNB}
  The \\textit{GaussianNB} classifier implements the Gaussian Naive Bayes
  algorithm for classification.                          The likelihood of the features is assumed
  to be Gaussian:                          \begin{equation}                              P(x\_i \mid
  y) = \frac{1}{\sqrt{2\pi\sigma^2\_y}} \exp\left(-\frac{(x\_i -
  \mu\_y)^2}{2\sigma^2\_y}\right)                          \end{equation}                          The
  parameters $\sigma\_y$ and $\mu\_y$ are estimated using maximum likelihood.
  \zNormalizationPerformed{GaussianNB}

  The \xmlNode{GaussianNB} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{GaussianNB} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.
  \default{time}

    \item \xmlNode{featureSelection}:
      Apply feature selection algorithm

      The \xmlNode{featureSelection} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{RFE}:
          The \xmlString{RFE} (Recursive Feature Elimination) is a feature selection algorithm.
          Feature selection refers to techniques that select a subset of the most relevant features
          for a model (ROM).         Fewer features can allow ROMs to run more efficiently (less
          space or time complexity) and be more effective.         Indeed, some ROMs (machine
          learning algorithms) can be misled by irrelevant input features, resulting in worse
          predictive performance.         RFE is a wrapper-type feature selection algorithm. This
          means that a different ROM is given and used in the core of the         method,         is
          wrapped by RFE, and used to help select features.         \\RFE works by searching for a
          subset of features by starting with all features in the training dataset and successfully
          removing         features until the desired number remains.         This is achieved by
          fitting the given ROME used in the core of the model, ranking features by importance,
          discarding the least important features, and re-fitting the model. This process is
          repeated until a specified number of         features remains.         When the full model
          is created, a measure of variable importance is computed that ranks the predictors from
          most         important to least.         At each stage of the search, the least important
          predictors are iteratively eliminated prior to rebuilding the model.         Features are
          scored either using the ROM model (if the model provides a mean to compute feature
          importances) or by         using a statistical method.         \\In RAVEN the
          \xmlString{RFE} class refers to an augmentation of the basic algorithm, since it allows,
          optionally,         to perform the search on multiple groups of targets (separately) and
          then combine the results of the search in a         single set. In addition, when the RFE
          search is concluded, the user can request to identify the set of features         that
          bring to a minimization of the score (i.e. maximimization of the accuracy).         In
          addition, using the ``applyClusteringFiltering'' option, the algorithm can, using an
          hierarchal clustering algorithm,         identify highly correlated features to speed up
          the subsequential search.
          The \xmlNode{RFE} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{RFE} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{nFeaturesToSelect}: \xmlDesc{integer}, 
              Exact Number of features to select. If not inputted, ``nFeaturesToSelect'' will be set
              to $1/2$ of the features in the training dataset.
  \default{None}

            \item \xmlNode{maxNumberFeatures}: \xmlDesc{integer}, 
              Maximum Number of features to select, the algorithm will automatically determine the
              feature list to minimize a total score.
  \default{None}

            \item \xmlNode{onlyOutputScore}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              If maxNumberFeatures is on, only output score should beconsidered? Or, in case of
              particular models (e.g. DMDC), state variable space score should be considered as
              well.
  \default{False}

            \item \xmlNode{applyClusteringFiltering}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              Applying clustering correlation before RFE search? If true, an hierarchal clustering
              is applied on the feature         space aimed to remove features that are correlated
              before the actual RFE search is performed. This approach can stabilize and
              accelerate the process in case of large feature spaces (e.g > 500 features).
  \default{False}

            \item \xmlNode{applyCrossCorrelation}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              In case of subgroupping, should a cross correleation analysis should be performed
              cross sub-groups?         If it is activated, a cross correleation analysis is used to
              additionally filter the features selected for each         sub-groupping search.
  \default{False}

            \item \xmlNode{step}: \xmlDesc{float}, 
              If greater than or equal to 1, then step corresponds to the (integer) number
              of features to remove at each iteration. If within (0.0, 1.0), then step
              corresponds to the percentage (rounded down) of features to remove at         each
              iteration.
  \default{1}

            \item \xmlNode{subGroup}: \xmlDesc{comma-separated strings, integers, and floats}, 
              Subgroup of output variables on which to perform the search. Multiple nodes of this
              type can be inputted. The RFE search will be then performed in each ``subgroup''
              separately and then the the union of the different feature sets are used for the final
              ROM.
          \end{itemize}

        \item \xmlNode{VarianceThreshold}:
          The \xmlString{VarianceThreshold} is a feature selector that removes     all low-variance
          features. This feature selection algorithm looks only at the features and not     the
          desired outputs. The variance threshold can be set by the user.
          The \xmlNode{VarianceThreshold} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{VarianceThreshold} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{threshold}: \xmlDesc{float}, 
              Features with a training-set variance lower than this threshold                   will
              be removed. The default is to keep all features with non-zero
              variance, i.e. remove the features that have the same value in all
              samples.
  \default{0.0}
          \end{itemize}
      \end{itemize}

    \item \xmlNode{featureSpaceTransformation}:
      Use dimensionality reduction technique to perform a trasformation of the training dataset
      into an uncorrelated one. The dimensionality of the problem will not be reduced but
      the data will be transformed in the transformed space. E.g if the number of features
      are 5, the method projects such features into a new uncorrelated space (still 5-dimensional).
      In case of time-dependent ROMs, all the samples are concatenated in a global 2D matrix
      (n\_samples*n\_timesteps,n\_features) before applying the transformation and then reconstructed
      back into the original shape (before fitting the model).

      The \xmlNode{featureSpaceTransformation} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{transformationMethod}: \xmlDesc{[PCA, KernelLinearPCA, KernelPolyPCA, KernelRbfPCA, KernelSigmoidPCA, KernelCosinePCA, ICA]}, 
          Transformation method to use. Eight options (5 Kernel PCAs) are available:
          \begin{itemize}                     \item \textit{PCA}, Principal Component Analysis;
          \item \textit{KernelLinearPCA}, Kernel (Linear) Principal component analysis;
          \item \textit{KernelPolyPCA}, Kernel (Poly) Principal component analysis;
          \item \textit{KernelRbfPCA}, Kernel(Rbf) Principal component analysis;
          \item \textit{KernelSigmoidPCA}, Kernel (Sigmoid) Principal component analysis;
          \item \textit{KernelCosinePCA}, Kernel (Cosine) Principal component analysis;
          \item \textit{ICA}, Independent component analysis;                    \end{itemize}
  \default{PCA}

        \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
          List of IDs of features/variables to include in the transformation process.
  \default{None}

        \item \xmlNode{whichSpace}: \xmlDesc{string}, 
          Which space to search? Target or Feature?
  \default{Feature}
      \end{itemize}

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{priors}: \xmlDesc{comma-separated floats}, 
      Prior probabilities of the classes. If specified the priors are
      not adjusted according to the data. \nb the number of elements inputted here must
      match the number of classes in the data set used in the training stage.
  \default{None}

    \item \xmlNode{var\_smoothing}: \xmlDesc{float}, 
      Portion of the largest variance of all features that is added to variances for
      calculation stability.
  \default{1e-09}
  \end{itemize}


\subsubsection{MLPClassifier}
  The \xmlNode{MLPClassifier} implements a multi-layer perceptron algorithm that trains using
  \textbf{Backpropagation}                             More precisely, it trains using some form of
  gradient descent and the gradients are calculated using Backpropagation.
  For classification, it minimizes the Cross-Entropy loss function, and it supports multi-class
  classification.                             \zNormalizationPerformed{MLPClassifier}

  The \xmlNode{MLPClassifier} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{MLPClassifier} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.
  \default{time}

    \item \xmlNode{featureSelection}:
      Apply feature selection algorithm

      The \xmlNode{featureSelection} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{RFE}:
          The \xmlString{RFE} (Recursive Feature Elimination) is a feature selection algorithm.
          Feature selection refers to techniques that select a subset of the most relevant features
          for a model (ROM).         Fewer features can allow ROMs to run more efficiently (less
          space or time complexity) and be more effective.         Indeed, some ROMs (machine
          learning algorithms) can be misled by irrelevant input features, resulting in worse
          predictive performance.         RFE is a wrapper-type feature selection algorithm. This
          means that a different ROM is given and used in the core of the         method,         is
          wrapped by RFE, and used to help select features.         \\RFE works by searching for a
          subset of features by starting with all features in the training dataset and successfully
          removing         features until the desired number remains.         This is achieved by
          fitting the given ROME used in the core of the model, ranking features by importance,
          discarding the least important features, and re-fitting the model. This process is
          repeated until a specified number of         features remains.         When the full model
          is created, a measure of variable importance is computed that ranks the predictors from
          most         important to least.         At each stage of the search, the least important
          predictors are iteratively eliminated prior to rebuilding the model.         Features are
          scored either using the ROM model (if the model provides a mean to compute feature
          importances) or by         using a statistical method.         \\In RAVEN the
          \xmlString{RFE} class refers to an augmentation of the basic algorithm, since it allows,
          optionally,         to perform the search on multiple groups of targets (separately) and
          then combine the results of the search in a         single set. In addition, when the RFE
          search is concluded, the user can request to identify the set of features         that
          bring to a minimization of the score (i.e. maximimization of the accuracy).         In
          addition, using the ``applyClusteringFiltering'' option, the algorithm can, using an
          hierarchal clustering algorithm,         identify highly correlated features to speed up
          the subsequential search.
          The \xmlNode{RFE} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{RFE} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{nFeaturesToSelect}: \xmlDesc{integer}, 
              Exact Number of features to select. If not inputted, ``nFeaturesToSelect'' will be set
              to $1/2$ of the features in the training dataset.
  \default{None}

            \item \xmlNode{maxNumberFeatures}: \xmlDesc{integer}, 
              Maximum Number of features to select, the algorithm will automatically determine the
              feature list to minimize a total score.
  \default{None}

            \item \xmlNode{onlyOutputScore}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              If maxNumberFeatures is on, only output score should beconsidered? Or, in case of
              particular models (e.g. DMDC), state variable space score should be considered as
              well.
  \default{False}

            \item \xmlNode{applyClusteringFiltering}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              Applying clustering correlation before RFE search? If true, an hierarchal clustering
              is applied on the feature         space aimed to remove features that are correlated
              before the actual RFE search is performed. This approach can stabilize and
              accelerate the process in case of large feature spaces (e.g > 500 features).
  \default{False}

            \item \xmlNode{applyCrossCorrelation}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              In case of subgroupping, should a cross correleation analysis should be performed
              cross sub-groups?         If it is activated, a cross correleation analysis is used to
              additionally filter the features selected for each         sub-groupping search.
  \default{False}

            \item \xmlNode{step}: \xmlDesc{float}, 
              If greater than or equal to 1, then step corresponds to the (integer) number
              of features to remove at each iteration. If within (0.0, 1.0), then step
              corresponds to the percentage (rounded down) of features to remove at         each
              iteration.
  \default{1}

            \item \xmlNode{subGroup}: \xmlDesc{comma-separated strings, integers, and floats}, 
              Subgroup of output variables on which to perform the search. Multiple nodes of this
              type can be inputted. The RFE search will be then performed in each ``subgroup''
              separately and then the the union of the different feature sets are used for the final
              ROM.
          \end{itemize}

        \item \xmlNode{VarianceThreshold}:
          The \xmlString{VarianceThreshold} is a feature selector that removes     all low-variance
          features. This feature selection algorithm looks only at the features and not     the
          desired outputs. The variance threshold can be set by the user.
          The \xmlNode{VarianceThreshold} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{VarianceThreshold} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{threshold}: \xmlDesc{float}, 
              Features with a training-set variance lower than this threshold                   will
              be removed. The default is to keep all features with non-zero
              variance, i.e. remove the features that have the same value in all
              samples.
  \default{0.0}
          \end{itemize}
      \end{itemize}

    \item \xmlNode{featureSpaceTransformation}:
      Use dimensionality reduction technique to perform a trasformation of the training dataset
      into an uncorrelated one. The dimensionality of the problem will not be reduced but
      the data will be transformed in the transformed space. E.g if the number of features
      are 5, the method projects such features into a new uncorrelated space (still 5-dimensional).
      In case of time-dependent ROMs, all the samples are concatenated in a global 2D matrix
      (n\_samples*n\_timesteps,n\_features) before applying the transformation and then reconstructed
      back into the original shape (before fitting the model).

      The \xmlNode{featureSpaceTransformation} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{transformationMethod}: \xmlDesc{[PCA, KernelLinearPCA, KernelPolyPCA, KernelRbfPCA, KernelSigmoidPCA, KernelCosinePCA, ICA]}, 
          Transformation method to use. Eight options (5 Kernel PCAs) are available:
          \begin{itemize}                     \item \textit{PCA}, Principal Component Analysis;
          \item \textit{KernelLinearPCA}, Kernel (Linear) Principal component analysis;
          \item \textit{KernelPolyPCA}, Kernel (Poly) Principal component analysis;
          \item \textit{KernelRbfPCA}, Kernel(Rbf) Principal component analysis;
          \item \textit{KernelSigmoidPCA}, Kernel (Sigmoid) Principal component analysis;
          \item \textit{KernelCosinePCA}, Kernel (Cosine) Principal component analysis;
          \item \textit{ICA}, Independent component analysis;                    \end{itemize}
  \default{PCA}

        \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
          List of IDs of features/variables to include in the transformation process.
  \default{None}

        \item \xmlNode{whichSpace}: \xmlDesc{string}, 
          Which space to search? Target or Feature?
  \default{Feature}
      \end{itemize}

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{hidden\_layer\_sizes}: \xmlDesc{comma-separated integers}, 
      The ith element represents the number of neurons in the ith hidden layer.
      lenght = n\_layers - 2
  \default{(100,)}

    \item \xmlNode{activation}: \xmlDesc{[identity, logistic, tanh, tanh]}, 
      Activation function for the hidden layer:
      \begin{itemize}                                                   \item identity:  no-op
      activation, useful to implement linear bottleneck, returns $f(x) = x$
      \item logistic: the logistic sigmoid function, returns $f(x) = 1 / (1 + exp(-x))$.
      \item tanh: the hyperbolic tan function, returns $f(x) = tanh(x)$.
      \item relu:  the rectified linear unit function, returns $f(x) = max(0, x)$
      \end{itemize}
  \default{relu}

    \item \xmlNode{solver}: \xmlDesc{[lbfgs, sgd, adam]}, 
      The solver for weight optimization:
      \begin{itemize}                                                   \item lbfgs: is an optimizer
      in the family of quasi-Newton methods.                                                   \item
      sgd: refers to stochastic gradient descent.
      \item adam: refers to a stochastic gradient-based optimizer proposed by Kingma, Diederik, and
      Jimmy Ba                                                  \end{itemize}
  \default{adam}

    \item \xmlNode{alpha}: \xmlDesc{float}, 
      L2 penalty (regularization term) parameter.
  \default{0.0001}

    \item \xmlNode{batch\_size}: \xmlDesc{integer or string}, 
      Size of minibatches for stochastic optimizers. If the solver is `lbfgs',
      the classifier will not use minibatch. When set to ``auto", batch\_size=min(200, n\_samples)
  \default{auto}

    \item \xmlNode{learning\_rate}: \xmlDesc{[constant, invscaling, adaptive]}, 
      Learning rate schedule for weight updates.:
      \begin{itemize}                                                   \item constant: is a
      constant learning rate given by `learning\_rate\_init'.
      \item invscaling: gradually decreases the learning rate at each time step `t' using
      an inverse scaling exponent of `power\_t'. effective\_learning\_rate = learning\_rate\_init /
      pow(t, power\_t)                                                   \item adaptive: keeps the
      learning rate constant to `learning\_rate\_init' as long as training
      loss keeps decreasing. Each time two consecutive epochs fail to decrease training loss by at
      least tol, or fail to increase validation score by at least tol if `early\_stopping' is on,
      the current learning rate is divided by 5. Only used when solver=`sgd'.
      \end{itemize}
  \default{constant}

    \item \xmlNode{learning\_rate\_init}: \xmlDesc{float}, 
      The initial learning rate used. It controls the step-size in updating the weights.
      Only used when solver=`sgd' or `adam'.
  \default{0.001}

    \item \xmlNode{power\_t}: \xmlDesc{float}, 
      The exponent for inverse scaling learning rate. It is used in updating effective
      learning rate when the learning\_rate is set to `invscaling'. Only used when solver=`sgd'.
  \default{0.5}

    \item \xmlNode{max\_iter}: \xmlDesc{integer}, 
      Maximum number of iterations. The solver iterates until convergence
      (determined by `tol') or this number of iterations. For stochastic solvers (`sgd', `adam'),
      note that this determines the number of epochs (how many times each data point will be used),
      not the number of gradient steps.
  \default{200}

    \item \xmlNode{shuffle}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Whether to shuffle samples in each iteration. Only used when solver=`sgd' or `adam'.
  \default{True}

    \item \xmlNode{random\_state}: \xmlDesc{integer}, 
      Determines random number generation for weights and bias initialization,
      train-test split if early stopping is used, and batch sampling when solver=`sgd' or `adam'.
  \default{None}

    \item \xmlNode{tol}: \xmlDesc{float}, 
      Tolerance for the optimization.
  \default{0.0001}

    \item \xmlNode{verbose}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Whether to print progress messages to stdout.
  \default{False}

    \item \xmlNode{warm\_start}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      When set to True, reuse the solution of the previous call to fit as initialization, otherwise,
      just erase the previous solution.
  \default{False}

    \item \xmlNode{momentum}: \xmlDesc{float}, 
      Momentum for gradient descent update. Should be between 0 and 1. Only used when solver=`sgd'.
  \default{0.9}

    \item \xmlNode{nesterovs\_momentum}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Whether to use Nesterov's momentum. Only used when solver=`sgd' and momentum > 0.
  \default{True}

    \item \xmlNode{early\_stopping}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Whether to use early stopping to terminate training when validation score is not improving.
      If set to true, it will automatically set aside ten-percent of training data as validation and
      terminate                                                  training when validation score is
      not improving by at least tol for n\_iter\_no\_change consecutive
      epochs. The split is stratified, except in a multilabel setting. If early stopping is False,
      then                                                  the training stops when the training
      loss does not improve by more than tol for n\_iter\_no\_change
      consecutive passes over the training set. Only effective when solver=`sgd' or `adam'.
  \default{False}

    \item \xmlNode{validation\_fraction}: \xmlDesc{float}, 
      The proportion of training data to set aside as validation set for early stopping. Must be
      between 0 and 1.                                                  Only used if early\_stopping
      is True
  \default{0.1}

    \item \xmlNode{beta\_1}: \xmlDesc{float}, 
      Exponential decay rate for estimates of first moment vector in adam, should be in $[0, 1)$.
      Only used when solver=`adam'.
  \default{0.9}

    \item \xmlNode{beta\_2}: \xmlDesc{float}, 
      Exponential decay rate for estimates of second moment vector in adam, should be in $[0, 1)$.
      Only used when solver=`adam'.
  \default{0.999}

    \item \xmlNode{epsilon}: \xmlDesc{float}, 
      Value for numerical stability in adam. Only used when solver=`adam'.
  \default{1e-08}

    \item \xmlNode{n\_iter\_no\_change}: \xmlDesc{integer}, 
      Maximum number of epochs to not meet tol improvement. Only effective when
      solver=`sgd' or `adam'
  \default{10}
  \end{itemize}


\subsubsection{MLPRegressor}
  The \xmlNode{MLPRegressor} implements a multi-layer perceptron algorithm that trains using
  \textbf{Backpropagation}                             More precisely, it trains using some form of
  gradient descent and the gradients are calculated using Backpropagation.
  \zNormalizationPerformed{MLPRegressor}

  The \xmlNode{MLPRegressor} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{MLPRegressor} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.
  \default{time}

    \item \xmlNode{featureSelection}:
      Apply feature selection algorithm

      The \xmlNode{featureSelection} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{RFE}:
          The \xmlString{RFE} (Recursive Feature Elimination) is a feature selection algorithm.
          Feature selection refers to techniques that select a subset of the most relevant features
          for a model (ROM).         Fewer features can allow ROMs to run more efficiently (less
          space or time complexity) and be more effective.         Indeed, some ROMs (machine
          learning algorithms) can be misled by irrelevant input features, resulting in worse
          predictive performance.         RFE is a wrapper-type feature selection algorithm. This
          means that a different ROM is given and used in the core of the         method,         is
          wrapped by RFE, and used to help select features.         \\RFE works by searching for a
          subset of features by starting with all features in the training dataset and successfully
          removing         features until the desired number remains.         This is achieved by
          fitting the given ROME used in the core of the model, ranking features by importance,
          discarding the least important features, and re-fitting the model. This process is
          repeated until a specified number of         features remains.         When the full model
          is created, a measure of variable importance is computed that ranks the predictors from
          most         important to least.         At each stage of the search, the least important
          predictors are iteratively eliminated prior to rebuilding the model.         Features are
          scored either using the ROM model (if the model provides a mean to compute feature
          importances) or by         using a statistical method.         \\In RAVEN the
          \xmlString{RFE} class refers to an augmentation of the basic algorithm, since it allows,
          optionally,         to perform the search on multiple groups of targets (separately) and
          then combine the results of the search in a         single set. In addition, when the RFE
          search is concluded, the user can request to identify the set of features         that
          bring to a minimization of the score (i.e. maximimization of the accuracy).         In
          addition, using the ``applyClusteringFiltering'' option, the algorithm can, using an
          hierarchal clustering algorithm,         identify highly correlated features to speed up
          the subsequential search.
          The \xmlNode{RFE} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{RFE} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{nFeaturesToSelect}: \xmlDesc{integer}, 
              Exact Number of features to select. If not inputted, ``nFeaturesToSelect'' will be set
              to $1/2$ of the features in the training dataset.
  \default{None}

            \item \xmlNode{maxNumberFeatures}: \xmlDesc{integer}, 
              Maximum Number of features to select, the algorithm will automatically determine the
              feature list to minimize a total score.
  \default{None}

            \item \xmlNode{onlyOutputScore}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              If maxNumberFeatures is on, only output score should beconsidered? Or, in case of
              particular models (e.g. DMDC), state variable space score should be considered as
              well.
  \default{False}

            \item \xmlNode{applyClusteringFiltering}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              Applying clustering correlation before RFE search? If true, an hierarchal clustering
              is applied on the feature         space aimed to remove features that are correlated
              before the actual RFE search is performed. This approach can stabilize and
              accelerate the process in case of large feature spaces (e.g > 500 features).
  \default{False}

            \item \xmlNode{applyCrossCorrelation}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              In case of subgroupping, should a cross correleation analysis should be performed
              cross sub-groups?         If it is activated, a cross correleation analysis is used to
              additionally filter the features selected for each         sub-groupping search.
  \default{False}

            \item \xmlNode{step}: \xmlDesc{float}, 
              If greater than or equal to 1, then step corresponds to the (integer) number
              of features to remove at each iteration. If within (0.0, 1.0), then step
              corresponds to the percentage (rounded down) of features to remove at         each
              iteration.
  \default{1}

            \item \xmlNode{subGroup}: \xmlDesc{comma-separated strings, integers, and floats}, 
              Subgroup of output variables on which to perform the search. Multiple nodes of this
              type can be inputted. The RFE search will be then performed in each ``subgroup''
              separately and then the the union of the different feature sets are used for the final
              ROM.
          \end{itemize}

        \item \xmlNode{VarianceThreshold}:
          The \xmlString{VarianceThreshold} is a feature selector that removes     all low-variance
          features. This feature selection algorithm looks only at the features and not     the
          desired outputs. The variance threshold can be set by the user.
          The \xmlNode{VarianceThreshold} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{VarianceThreshold} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{threshold}: \xmlDesc{float}, 
              Features with a training-set variance lower than this threshold                   will
              be removed. The default is to keep all features with non-zero
              variance, i.e. remove the features that have the same value in all
              samples.
  \default{0.0}
          \end{itemize}
      \end{itemize}

    \item \xmlNode{featureSpaceTransformation}:
      Use dimensionality reduction technique to perform a trasformation of the training dataset
      into an uncorrelated one. The dimensionality of the problem will not be reduced but
      the data will be transformed in the transformed space. E.g if the number of features
      are 5, the method projects such features into a new uncorrelated space (still 5-dimensional).
      In case of time-dependent ROMs, all the samples are concatenated in a global 2D matrix
      (n\_samples*n\_timesteps,n\_features) before applying the transformation and then reconstructed
      back into the original shape (before fitting the model).

      The \xmlNode{featureSpaceTransformation} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{transformationMethod}: \xmlDesc{[PCA, KernelLinearPCA, KernelPolyPCA, KernelRbfPCA, KernelSigmoidPCA, KernelCosinePCA, ICA]}, 
          Transformation method to use. Eight options (5 Kernel PCAs) are available:
          \begin{itemize}                     \item \textit{PCA}, Principal Component Analysis;
          \item \textit{KernelLinearPCA}, Kernel (Linear) Principal component analysis;
          \item \textit{KernelPolyPCA}, Kernel (Poly) Principal component analysis;
          \item \textit{KernelRbfPCA}, Kernel(Rbf) Principal component analysis;
          \item \textit{KernelSigmoidPCA}, Kernel (Sigmoid) Principal component analysis;
          \item \textit{KernelCosinePCA}, Kernel (Cosine) Principal component analysis;
          \item \textit{ICA}, Independent component analysis;                    \end{itemize}
  \default{PCA}

        \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
          List of IDs of features/variables to include in the transformation process.
  \default{None}

        \item \xmlNode{whichSpace}: \xmlDesc{string}, 
          Which space to search? Target or Feature?
  \default{Feature}
      \end{itemize}

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{hidden\_layer\_sizes}: \xmlDesc{comma-separated integers}, 
      The ith element represents the number of neurons in the ith hidden layer.
      lenght = n\_layers - 2
  \default{(100,)}

    \item \xmlNode{activation}: \xmlDesc{[identity, logistic, tanh, relu]}, 
      Activation function for the hidden layer:
      \begin{itemize}                                                    \item identity:  no-op
      activation, useful to implement linear bottleneck, returns $f(x) = x$
      \item logistic: the logistic sigmoid function, returns $f(x) = 1 / (1 + exp(-x))$.
      \item tanh: the hyperbolic tan function, returns $f(x) = tanh(x)$.
      \item relu:  the rectified linear unit function, returns $f(x) = max(0, x)$
      \end{itemize}
  \default{relu}

    \item \xmlNode{solver}: \xmlDesc{[lbfgs, sgd, adam]}, 
      The solver for weight optimization:
      \begin{itemize}                                                    \item lbfgs: is an
      optimizer in the family of quasi-Newton methods.
      \item sgd: refers to stochastic gradient descent.
      \item adam: refers to a stochastic gradient-based optimizer proposed by Kingma, Diederik, and
      Jimmy Ba                                                  \end{itemize}
  \default{adam}

    \item \xmlNode{alpha}: \xmlDesc{float}, 
      L2 penalty (regularization term) parameter.
  \default{0.0001}

    \item \xmlNode{batch\_size}: \xmlDesc{integer or string}, 
      Size of minibatches for stochastic optimizers. If the solver is `lbfgs',
      the classifier will not use minibatch. When set to ``auto", batch\_size=min(200, n\_samples)
  \default{auto}

    \item \xmlNode{learning\_rate}: \xmlDesc{[constant, invscaling, adaptive]}, 
      Learning rate schedule for weight updates.:
      \begin{itemize}                                                   \item constant: is a
      constant learning rate given by `learning\_rate\_init'.
      \item invscaling: gradually decreases the learning rate at each time step `t' using
      an inverse scaling exponent of `power\_t'. effective\_learning\_rate = learning\_rate\_init /
      pow(t, power\_t)                                                   \item adaptive: keeps the
      learning rate constant to `learning\_rate\_init' as long as training
      loss keeps decreasing. Each time two consecutive epochs fail to decrease training loss by at
      least tol, or fail to increase validation score by at least tol if `early\_stopping' is on,
      the current learning rate is divided by 5. Only used when solver=`sgd'.
      \end{itemize}
  \default{constant}

    \item \xmlNode{learning\_rate\_init}: \xmlDesc{float}, 
      The initial learning rate used. It controls the step-size in updating the weights.
      Only used when solver=`sgd' or `adam'.
  \default{0.001}

    \item \xmlNode{power\_t}: \xmlDesc{float}, 
      The exponent for inverse scaling learning rate. It is used in updating effective
      learning rate when the learning\_rate is set to `invscaling'. Only used when solver=`sgd'.
  \default{0.5}

    \item \xmlNode{max\_iter}: \xmlDesc{integer}, 
      Maximum number of iterations. The solver iterates until convergence
      (determined by `tol') or this number of iterations. For stochastic solvers (`sgd', `adam'),
      note that this determines the number of epochs (how many times each data point will be used),
      not the number of gradient steps.
  \default{200}

    \item \xmlNode{shuffle}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Whether to shuffle samples in each iteration. Only used when solver=`sgd' or `adam'.
  \default{True}

    \item \xmlNode{random\_state}: \xmlDesc{integer}, 
      Determines random number generation for weights and bias initialization,
      train-test split if early stopping is used, and batch sampling when solver=`sgd' or `adam'.
  \default{None}

    \item \xmlNode{tol}: \xmlDesc{float}, 
      Tolerance for the optimization.
  \default{0.0001}

    \item \xmlNode{verbose}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Whether to print progress messages to stdout.
  \default{False}

    \item \xmlNode{warm\_start}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      When set to True, reuse the solution of the previous call to fit as initialization, otherwise,
      just erase the previous solution.
  \default{False}

    \item \xmlNode{momentum}: \xmlDesc{float}, 
      Momentum for gradient descent update. Should be between 0 and 1. Only used when solver=`sgd'.
  \default{0.9}

    \item \xmlNode{nesterovs\_momentum}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Whether to use Nesterov's momentum. Only used when solver=`sgd' and momentum > 0.
  \default{True}

    \item \xmlNode{early\_stopping}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Whether to use early stopping to terminate training when validation score is not improving.
      If set to true, it will automatically set aside ten-percent of training data as validation and
      terminate                                                  training when validation score is
      not improving by at least tol for n\_iter\_no\_change consecutive
      epochs. The split is stratified, except in a multilabel setting. If early stopping is False,
      then                                                  the training stops when the training
      loss does not improve by more than tol for n\_iter\_no\_change
      consecutive passes over the training set. Only effective when solver=`sgd' or `adam'.
  \default{False}

    \item \xmlNode{validation\_fraction}: \xmlDesc{float}, 
      The proportion of training data to set aside as validation set for early stopping. Must be
      between 0 and 1.                                                  Only used if early\_stopping
      is True
  \default{0.1}

    \item \xmlNode{beta\_1}: \xmlDesc{float}, 
      Exponential decay rate for estimates of first moment vector in adam, should be in $[0, 1)$.
      Only used when solver=`adam'.
  \default{0.9}

    \item \xmlNode{beta\_2}: \xmlDesc{float}, 
      Exponential decay rate for estimates of second moment vector in adam, should be in $[0, 1)$.
      Only used when solver=`adam'.
  \default{0.999}

    \item \xmlNode{epsilon}: \xmlDesc{float}, 
      Value for numerical stability in adam. Only used when solver=`adam'.
  \default{1e-08}

    \item \xmlNode{n\_iter\_no\_change}: \xmlDesc{integer}, 
      Maximum number of epochs to not meet tol improvement. Only effective when
      solver=`sgd' or `adam'
  \default{10}
  \end{itemize}


\subsubsection{GaussianProcessClassifier}
  The \xmlNode{GaussianProcessClassifier} is based on Laplace approximation. The implementation
  is based on Algorithm 3.1, 3.2, and 5.1 of Gaussian Processes for Machine Learning (GPML) by
  Rasmussen and Williams.Internally, the Laplace approximation is used for approximating the
  non-Gaussian posterior by a Gaussian. Currently, the implementation is using the
  logistic link function.The method is a generic supervised learning                          method
  primarily designed to solve classification problems.                          The advantages of
  Gaussian Processes for Machine Learning are:                          \begin{itemize}
  \item The prediction interpolates the observations (at least for regular
  correlation models).                            \item The prediction is probabilistic (Gaussian)
  so that one can compute                            empirical confidence intervals and exceedance
  probabilities that might be used                            to refit (online fitting, adaptive
  fitting) the prediction in some region of                            interest.
  \item Versatile: different linear regression models and correlation models can
  be specified.                            Common models are provided, but it is also possible to
  specify custom models                            provided they are stationary.
  \end{itemize}                          The disadvantages of Gaussian Processes for Machine
  Learning include:                          \begin{itemize}                            \item It is
  not sparse.                            It uses the whole samples/features information to perform
  the prediction.                            \item It loses efficiency in high dimensional spaces –
  namely when the                            number of features exceeds a few dozens.
  It might indeed give poor performance and it loses computational efficiency.
  \item Classification is only a post-processing, meaning that one first needs
  to solve a regression problem by providing the complete scalar float precision
  output $y$ of the experiment one is attempting to model.                          \end{itemize}
  \zNormalizationNotPerformed{GaussianProcessClassifier}

  The \xmlNode{GaussianProcessClassifier} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{GaussianProcessClassifier} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.
  \default{time}

    \item \xmlNode{featureSelection}:
      Apply feature selection algorithm

      The \xmlNode{featureSelection} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{RFE}:
          The \xmlString{RFE} (Recursive Feature Elimination) is a feature selection algorithm.
          Feature selection refers to techniques that select a subset of the most relevant features
          for a model (ROM).         Fewer features can allow ROMs to run more efficiently (less
          space or time complexity) and be more effective.         Indeed, some ROMs (machine
          learning algorithms) can be misled by irrelevant input features, resulting in worse
          predictive performance.         RFE is a wrapper-type feature selection algorithm. This
          means that a different ROM is given and used in the core of the         method,         is
          wrapped by RFE, and used to help select features.         \\RFE works by searching for a
          subset of features by starting with all features in the training dataset and successfully
          removing         features until the desired number remains.         This is achieved by
          fitting the given ROME used in the core of the model, ranking features by importance,
          discarding the least important features, and re-fitting the model. This process is
          repeated until a specified number of         features remains.         When the full model
          is created, a measure of variable importance is computed that ranks the predictors from
          most         important to least.         At each stage of the search, the least important
          predictors are iteratively eliminated prior to rebuilding the model.         Features are
          scored either using the ROM model (if the model provides a mean to compute feature
          importances) or by         using a statistical method.         \\In RAVEN the
          \xmlString{RFE} class refers to an augmentation of the basic algorithm, since it allows,
          optionally,         to perform the search on multiple groups of targets (separately) and
          then combine the results of the search in a         single set. In addition, when the RFE
          search is concluded, the user can request to identify the set of features         that
          bring to a minimization of the score (i.e. maximimization of the accuracy).         In
          addition, using the ``applyClusteringFiltering'' option, the algorithm can, using an
          hierarchal clustering algorithm,         identify highly correlated features to speed up
          the subsequential search.
          The \xmlNode{RFE} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{RFE} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{nFeaturesToSelect}: \xmlDesc{integer}, 
              Exact Number of features to select. If not inputted, ``nFeaturesToSelect'' will be set
              to $1/2$ of the features in the training dataset.
  \default{None}

            \item \xmlNode{maxNumberFeatures}: \xmlDesc{integer}, 
              Maximum Number of features to select, the algorithm will automatically determine the
              feature list to minimize a total score.
  \default{None}

            \item \xmlNode{onlyOutputScore}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              If maxNumberFeatures is on, only output score should beconsidered? Or, in case of
              particular models (e.g. DMDC), state variable space score should be considered as
              well.
  \default{False}

            \item \xmlNode{applyClusteringFiltering}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              Applying clustering correlation before RFE search? If true, an hierarchal clustering
              is applied on the feature         space aimed to remove features that are correlated
              before the actual RFE search is performed. This approach can stabilize and
              accelerate the process in case of large feature spaces (e.g > 500 features).
  \default{False}

            \item \xmlNode{applyCrossCorrelation}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              In case of subgroupping, should a cross correleation analysis should be performed
              cross sub-groups?         If it is activated, a cross correleation analysis is used to
              additionally filter the features selected for each         sub-groupping search.
  \default{False}

            \item \xmlNode{step}: \xmlDesc{float}, 
              If greater than or equal to 1, then step corresponds to the (integer) number
              of features to remove at each iteration. If within (0.0, 1.0), then step
              corresponds to the percentage (rounded down) of features to remove at         each
              iteration.
  \default{1}

            \item \xmlNode{subGroup}: \xmlDesc{comma-separated strings, integers, and floats}, 
              Subgroup of output variables on which to perform the search. Multiple nodes of this
              type can be inputted. The RFE search will be then performed in each ``subgroup''
              separately and then the the union of the different feature sets are used for the final
              ROM.
          \end{itemize}

        \item \xmlNode{VarianceThreshold}:
          The \xmlString{VarianceThreshold} is a feature selector that removes     all low-variance
          features. This feature selection algorithm looks only at the features and not     the
          desired outputs. The variance threshold can be set by the user.
          The \xmlNode{VarianceThreshold} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{VarianceThreshold} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{threshold}: \xmlDesc{float}, 
              Features with a training-set variance lower than this threshold                   will
              be removed. The default is to keep all features with non-zero
              variance, i.e. remove the features that have the same value in all
              samples.
  \default{0.0}
          \end{itemize}
      \end{itemize}

    \item \xmlNode{featureSpaceTransformation}:
      Use dimensionality reduction technique to perform a trasformation of the training dataset
      into an uncorrelated one. The dimensionality of the problem will not be reduced but
      the data will be transformed in the transformed space. E.g if the number of features
      are 5, the method projects such features into a new uncorrelated space (still 5-dimensional).
      In case of time-dependent ROMs, all the samples are concatenated in a global 2D matrix
      (n\_samples*n\_timesteps,n\_features) before applying the transformation and then reconstructed
      back into the original shape (before fitting the model).

      The \xmlNode{featureSpaceTransformation} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{transformationMethod}: \xmlDesc{[PCA, KernelLinearPCA, KernelPolyPCA, KernelRbfPCA, KernelSigmoidPCA, KernelCosinePCA, ICA]}, 
          Transformation method to use. Eight options (5 Kernel PCAs) are available:
          \begin{itemize}                     \item \textit{PCA}, Principal Component Analysis;
          \item \textit{KernelLinearPCA}, Kernel (Linear) Principal component analysis;
          \item \textit{KernelPolyPCA}, Kernel (Poly) Principal component analysis;
          \item \textit{KernelRbfPCA}, Kernel(Rbf) Principal component analysis;
          \item \textit{KernelSigmoidPCA}, Kernel (Sigmoid) Principal component analysis;
          \item \textit{KernelCosinePCA}, Kernel (Cosine) Principal component analysis;
          \item \textit{ICA}, Independent component analysis;                    \end{itemize}
  \default{PCA}

        \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
          List of IDs of features/variables to include in the transformation process.
  \default{None}

        \item \xmlNode{whichSpace}: \xmlDesc{string}, 
          Which space to search? Target or Feature?
  \default{Feature}
      \end{itemize}

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{kernel}: \xmlDesc{[Constant, DotProduct, ExpSineSquared, Exponentiation, Matern, Pairwise, RBF, RationalQuadratic]}, 
      The kernel specifying the covariance function of the GP. If None is passed,
      the kernel $RBF$ is used as default. The kernel hyperparameters are optimized during fitting
      and consequentially the hyperparameters are
      not inputable. The following kernels are avaialable:
      \begin{itemize}                                                    \item Constant, Constant
      kernel: $k(x\_1, x\_2) = constant\_value \;\forall\; x\_1, x\_2$.
      \item DotProduct, it is non-stationary and can be obtained from linear regression by putting
      $N(0, 1)$ priors on the coefficients of $x\_d (d = 1, . . . , D)$
      and a prior of $N(0, \sigma\_0^2)$ on the bias. The DotProduct kernel is invariant to a
      rotation of the coordinates about the origin, but not translations.
      It is parameterized by a parameter sigma\_0 $\sigma$ which controls the inhomogenity of the
      kernel.                                                    \item ExpSineSquared, it allows one
      to model functions which repeat themselves exactly. It is parameterized by a length scale
      parameter $l>0$ and a periodicity parameter $p>0$.
      The kernel is given by $k(x\_i, x\_j) = \text{exp}\left(-\frac{ 2\sin^2(\pi d(x\_i, x\_j)/p) }{ l^
      2} \right)$ where $d(\\cdot,\\cdot)$ is the Euclidean distance.
      \item Exponentiation, it takes one base kernel and a scalar parameter $p$ and combines them
      via $k\_{exp}(X, Y) = k(X, Y) ^p$.                                                    \item
      Matern, is a generalization of the RBF. It has an additional parameter $\nu$ which controls
      the smoothness of the resulting function. The smaller $\nu$,
      the less smooth the approximated function is. As $\nu\rightarrow\infty$, the kernel becomes
      equivalent to the RBF kernel. When $\nu = 1/2$, the Matérn kernel becomes
      identical to the absolute exponential kernel. Important intermediate values are $\nu = 1.5$
      (once differentiable functions) and $\nu = 2.5$ (twice differentiable functions).
      The kernel is given by $k(x\_i, x\_j) =  \frac{1}{\Gamma(\nu)2^{\nu-1}}\Bigg(
      \frac{\sqrt{2\nu}}{l} d(x\_i , x\_j ) \Bigg)^\nu K\_\nu\Bigg( \frac{\sqrt{2\nu}}{l} d(x\_i , x\_j
      )\Bigg)$                                                                  where
      $d(\cdot,\cdot)$ is the Euclidean distance, $K\_{\nu}(\cdot)$ is a modified Bessel function and
      $\Gamma(\cdot)$ is the gamma function.
      \item PairwiseLinear, it is a thin wrapper around the functionality of the pairwise kernels.
      It uses the a linear metric to calculate kernel between instances
      in a feature array. Evaluation of the gradient is not analytic but numeric and all kernels
      support only isotropic distances.                                                    \item
      PairwiseAdditiveChi2, it is a thin wrapper around the functionality of the pairwise metrics.
      It uses the an additive chi squared metric to calculate kernel between instances
      in a feature array. Evaluation of the gradient is not analytic but numeric and all kernels
      support only isotropic distances.                                                    \item
      PairwiseChi2, it is a thin wrapper around the functionality of the pairwise metrics. It uses
      the a chi squared metric to calculate kernel between instances
      in a feature array. Evaluation of the gradient is not analytic but numeric and all kernels
      support only isotropic distances.                                                    \item
      PairwisePoly, it is a thin wrapper around the functionality of the pairwise metrics. It uses
      the a poly metric to calculate kernel between instances
      in a feature array. Evaluation of the gradient is not analytic but numeric and all kernels
      support only isotropic distances.                                                    \item
      PairwisePolynomial, it is a thin wrapper around the functionality of the pairwise metrics. It
      uses the a polynomial metric to calculate kernel between instances
      in a feature array. Evaluation of the gradient is not analytic but numeric and all kernels
      support only isotropic distances.                                                    \item
      PairwiseRbf, it is a thin wrapper around the functionality of the pairwise metrics. It uses
      the a rbf metric to calculate kernel between instances
      in a feature array. Evaluation of the gradient is not analytic but numeric and all kernels
      support only isotropic distances.                                                    \item
      PairwiseLaplacian, it is a thin wrapper around the functionality of the pairwise metrics. It
      uses the a laplacian metric to calculate kernel between instances
      in a feature array. Evaluation of the gradient is not analytic but numeric and all kernels
      support only isotropic distances.                                                    \item
      PairwiseSigmoid, it is a thin wrapper around the functionality of the pairwise metrics. It
      uses the a sigmoid metric to calculate kernel between instances
      in a feature array. Evaluation of the gradient is not analytic but numeric and all kernels
      support only isotropic distances.                                                    \item
      PairwiseCosine, it is a thin wrapper around the functionality of the pairwise metrics. It uses
      the a cosine metric to calculate kernel between instances
      in a feature array. Evaluation of the gradient is not analytic but numeric and all kernels
      support only isotropic distances.                                                    \item
      RBF, it is a stationary kernel. It is also known as the ``squared exponential'' kernel. It is
      parameterized by a length scale parameter $l>0$,
      which can either be a scalar (isotropic variant of the kernel) or a vector with the same
      number of dimensions as the inputs $X$ (anisotropic variant of the kernel).
      The kernel is given by $k(x\_i, x\_j) = \exp\left(- \frac{d(x\_i, x\_j)^2}{2l^2} \right)$ where
      $l$ is the length scale of the kernel and $d(\cdot,\cdot)$ is the Euclidean distance.
      \item RationalQuadratic, it can be seen as a scale mixture (an infinite sum) of RBF kernels
      with different characteristic length scales. It is parameterized by a length scale parameter
      $l>0$ and a scale mixture parameter $\alpha>0$ . The kernel is given by $k(x\_i, x\_j) = \left(1
      + \frac{d(x\_i, x\_j)^2 }{ 2\alpha  l^2}\right)^{-\alpha}$ where
      $d(\cdot,\cdot)$ is the Euclidean distance.
      \end{itemize}
  \default{RBF}

    \item \xmlNode{n\_restarts\_optimizer}: \xmlDesc{integer}, 
      The number of restarts of the optimizer for finding the kernel's parameters which maximize the
      log-marginal likelihood. The first run of the optimizer is performed
      from the kernel's initial parameters, the remaining ones (if any) from thetas sampled log-
      uniform randomly from the space of allowed theta-values. If greater than
      0, all bounds must be finite.
  \default{0}

    \item \xmlNode{max\_iter\_predict}: \xmlDesc{integer}, 
      The maximum number of iterations in Newton’s method for approximating the posterior during
      predict. Smaller values will reduce computation time at
      the cost of worse results.
  \default{100}

    \item \xmlNode{multi\_class}: \xmlDesc{[one\_vs\_rest, one\_vs\_one]}, 
      Specifies how multi-class classification problems are handled. Supported are ``one\_vs\_rest''
      and ``one\_vs\_one''.                                                         In
      ``one\_vs\_rest', one binary Gaussian process classifier is fitted for each class, which is
      trained to separate this class                                                         from
      the rest. In ``one\_vs\_one'', one binary Gaussian process classifier is fitted for each pair
      of classes, which is trained to
      separate these two classes. The predictions of these binary predictors are combined into
      multi-class predictions.
  \default{one\_vs\_rest}

    \item \xmlNode{random\_state}: \xmlDesc{integer}, 
      Seed for the internal random number generator
  \default{None}

    \item \xmlNode{optimizer}: \xmlDesc{[fmin\_l\_bfgs\_b]}, 
      Per default, the 'L-BGFS-B' algorithm from
      scipy.optimize.minimize is used. If None is passed, the kernel’s
      parameters are kept fixed.
  \default{L-BGFS-B}
  \end{itemize}


\subsubsection{GaussianProcessRegressor}
  The \xmlNode{GaussianProcessRegressor} is based on Algorithm 2.1 of Gaussian Processes
  for Machine Learning (GPML) by Rasmussen and Williams. The method is a generic supervised learning
  method primarily designed to solve regression problems.                          The advantages of
  Gaussian Processes for Machine Learning are:                          \begin{itemize}
  \item The prediction interpolates the observations (at least for regular
  correlation models).                            \item The prediction is probabilistic (Gaussian)
  so that one can compute                            empirical confidence intervals and exceedance
  probabilities that might be used                            to refit (online fitting, adaptive
  fitting) the prediction in some region of                            interest.
  \item Versatile: different linear regression models and correlation models can
  be specified.                            Common models are provided, but it is also possible to
  specify custom models                            provided they are stationary.
  \end{itemize}                          The disadvantages of Gaussian Processes for Machine
  Learning include:                          \begin{itemize}                            \item It is
  not sparse.                            It uses the whole samples/features information to perform
  the prediction.                            \item It loses efficiency in high dimensional spaces –
  namely when the                            number of features exceeds a few dozens.
  It might indeed give poor performance and it loses computational efficiency.
  \item Classification is only a post-processing, meaning that one first needs
  to solve a regression problem by providing the complete scalar float precision
  output $y$ of the experiment one is attempting to model.                          \end{itemize}
  \zNormalizationNotPerformed{GaussianProcessRegressor}

  The \xmlNode{GaussianProcessRegressor} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{GaussianProcessRegressor} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.
  \default{time}

    \item \xmlNode{featureSelection}:
      Apply feature selection algorithm

      The \xmlNode{featureSelection} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{RFE}:
          The \xmlString{RFE} (Recursive Feature Elimination) is a feature selection algorithm.
          Feature selection refers to techniques that select a subset of the most relevant features
          for a model (ROM).         Fewer features can allow ROMs to run more efficiently (less
          space or time complexity) and be more effective.         Indeed, some ROMs (machine
          learning algorithms) can be misled by irrelevant input features, resulting in worse
          predictive performance.         RFE is a wrapper-type feature selection algorithm. This
          means that a different ROM is given and used in the core of the         method,         is
          wrapped by RFE, and used to help select features.         \\RFE works by searching for a
          subset of features by starting with all features in the training dataset and successfully
          removing         features until the desired number remains.         This is achieved by
          fitting the given ROME used in the core of the model, ranking features by importance,
          discarding the least important features, and re-fitting the model. This process is
          repeated until a specified number of         features remains.         When the full model
          is created, a measure of variable importance is computed that ranks the predictors from
          most         important to least.         At each stage of the search, the least important
          predictors are iteratively eliminated prior to rebuilding the model.         Features are
          scored either using the ROM model (if the model provides a mean to compute feature
          importances) or by         using a statistical method.         \\In RAVEN the
          \xmlString{RFE} class refers to an augmentation of the basic algorithm, since it allows,
          optionally,         to perform the search on multiple groups of targets (separately) and
          then combine the results of the search in a         single set. In addition, when the RFE
          search is concluded, the user can request to identify the set of features         that
          bring to a minimization of the score (i.e. maximimization of the accuracy).         In
          addition, using the ``applyClusteringFiltering'' option, the algorithm can, using an
          hierarchal clustering algorithm,         identify highly correlated features to speed up
          the subsequential search.
          The \xmlNode{RFE} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{RFE} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{nFeaturesToSelect}: \xmlDesc{integer}, 
              Exact Number of features to select. If not inputted, ``nFeaturesToSelect'' will be set
              to $1/2$ of the features in the training dataset.
  \default{None}

            \item \xmlNode{maxNumberFeatures}: \xmlDesc{integer}, 
              Maximum Number of features to select, the algorithm will automatically determine the
              feature list to minimize a total score.
  \default{None}

            \item \xmlNode{onlyOutputScore}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              If maxNumberFeatures is on, only output score should beconsidered? Or, in case of
              particular models (e.g. DMDC), state variable space score should be considered as
              well.
  \default{False}

            \item \xmlNode{applyClusteringFiltering}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              Applying clustering correlation before RFE search? If true, an hierarchal clustering
              is applied on the feature         space aimed to remove features that are correlated
              before the actual RFE search is performed. This approach can stabilize and
              accelerate the process in case of large feature spaces (e.g > 500 features).
  \default{False}

            \item \xmlNode{applyCrossCorrelation}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              In case of subgroupping, should a cross correleation analysis should be performed
              cross sub-groups?         If it is activated, a cross correleation analysis is used to
              additionally filter the features selected for each         sub-groupping search.
  \default{False}

            \item \xmlNode{step}: \xmlDesc{float}, 
              If greater than or equal to 1, then step corresponds to the (integer) number
              of features to remove at each iteration. If within (0.0, 1.0), then step
              corresponds to the percentage (rounded down) of features to remove at         each
              iteration.
  \default{1}

            \item \xmlNode{subGroup}: \xmlDesc{comma-separated strings, integers, and floats}, 
              Subgroup of output variables on which to perform the search. Multiple nodes of this
              type can be inputted. The RFE search will be then performed in each ``subgroup''
              separately and then the the union of the different feature sets are used for the final
              ROM.
          \end{itemize}

        \item \xmlNode{VarianceThreshold}:
          The \xmlString{VarianceThreshold} is a feature selector that removes     all low-variance
          features. This feature selection algorithm looks only at the features and not     the
          desired outputs. The variance threshold can be set by the user.
          The \xmlNode{VarianceThreshold} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{VarianceThreshold} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{threshold}: \xmlDesc{float}, 
              Features with a training-set variance lower than this threshold                   will
              be removed. The default is to keep all features with non-zero
              variance, i.e. remove the features that have the same value in all
              samples.
  \default{0.0}
          \end{itemize}
      \end{itemize}

    \item \xmlNode{featureSpaceTransformation}:
      Use dimensionality reduction technique to perform a trasformation of the training dataset
      into an uncorrelated one. The dimensionality of the problem will not be reduced but
      the data will be transformed in the transformed space. E.g if the number of features
      are 5, the method projects such features into a new uncorrelated space (still 5-dimensional).
      In case of time-dependent ROMs, all the samples are concatenated in a global 2D matrix
      (n\_samples*n\_timesteps,n\_features) before applying the transformation and then reconstructed
      back into the original shape (before fitting the model).

      The \xmlNode{featureSpaceTransformation} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{transformationMethod}: \xmlDesc{[PCA, KernelLinearPCA, KernelPolyPCA, KernelRbfPCA, KernelSigmoidPCA, KernelCosinePCA, ICA]}, 
          Transformation method to use. Eight options (5 Kernel PCAs) are available:
          \begin{itemize}                     \item \textit{PCA}, Principal Component Analysis;
          \item \textit{KernelLinearPCA}, Kernel (Linear) Principal component analysis;
          \item \textit{KernelPolyPCA}, Kernel (Poly) Principal component analysis;
          \item \textit{KernelRbfPCA}, Kernel(Rbf) Principal component analysis;
          \item \textit{KernelSigmoidPCA}, Kernel (Sigmoid) Principal component analysis;
          \item \textit{KernelCosinePCA}, Kernel (Cosine) Principal component analysis;
          \item \textit{ICA}, Independent component analysis;                    \end{itemize}
  \default{PCA}

        \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
          List of IDs of features/variables to include in the transformation process.
  \default{None}

        \item \xmlNode{whichSpace}: \xmlDesc{string}, 
          Which space to search? Target or Feature?
  \default{Feature}
      \end{itemize}

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{kernel}: \xmlDesc{[Constant, DotProduct, ExpSineSquared, Exponentiation, Matern, PairwiseLinear, PairwiseAdditiveChi2, PairwiseChi2, PairwisePoly, PairwisePolynomial, PairwiseRBF, PairwiseLaplassian, PairwiseSigmoid, PairwiseCosine, RBF, RationalQuadratic]}, 
      The kernel specifying the covariance function of the GP. If None is passed,
      the kernel $Constant$ is used as default. The kernel hyperparameters are optimized during
      fitting and consequentially the hyperparameters are
      not inputable. The following kernels are avaialable:
      \begin{itemize}                                                    \item Constant, Constant
      kernel: $k(x\_1, x\_2) = constant\_value \;\forall\; x\_1, x\_2$.
      \item DotProduct, it is non-stationary and can be obtained from linear regression by putting
      $N(0, 1)$ priors on the coefficients of $x\_d (d = 1, . . . , D)$
      and a prior of $N(0, \sigma\_0^2)$ on the bias. The DotProduct kernel is invariant to a
      rotation of the coordinates about the origin, but not translations.
      It is parameterized by a parameter sigma\_0 $\sigma$ which controls the inhomogenity of the
      kernel.                                                    \item ExpSineSquared, it allows one
      to model functions which repeat themselves exactly. It is parameterized by a length scale
      parameter $l>0$ and a periodicity parameter $p>0$.
      The kernel is given by $k(x\_i, x\_j) = \text{exp}\left(-\frac{ 2\sin^2(\pi d(x\_i, x\_j)/p) }{ l^
      2} \right)$ where $d(\\cdot,\\cdot)$ is the Euclidean distance.
      \item Exponentiation, it takes one base kernel and a scalar parameter $p$ and combines them
      via $k\_{exp}(X, Y) = k(X, Y) ^p$.                                                    \item
      Matern, is a generalization of the RBF. It has an additional parameter $\nu$ which controls
      the smoothness of the resulting function. The smaller $\nu$,
      the less smooth the approximated function is. As $\nu\rightarrow\infty$, the kernel becomes
      equivalent to the RBF kernel. When $\nu = 1/2$, the Matérn kernel becomes
      identical to the absolute exponential kernel. Important intermediate values are $\nu = 1.5$
      (once differentiable functions) and $\nu = 2.5$ (twice differentiable functions).
      The kernel is given by $k(x\_i, x\_j) =  \frac{1}{\Gamma(\nu)2^{\nu-1}}\Bigg(
      \frac{\sqrt{2\nu}}{l} d(x\_i , x\_j ) \Bigg)^\nu K\_\nu\Bigg( \frac{\sqrt{2\nu}}{l} d(x\_i , x\_j
      )\Bigg)$                                                                  where
      $d(\cdot,\cdot)$ is the Euclidean distance, $K\_{\nu}(\cdot)$ is a modified Bessel function and
      $\Gamma(\cdot)$ is the gamma function.
      \item PairwiseLinear, it is a thin wrapper around the functionality of the pairwise kernels.
      It uses the a linear metric to calculate kernel between instances
      in a feature array. Evaluation of the gradient is not analytic but numeric and all kernels
      support only isotropic distances.                                                    \item
      PairwiseAdditiveChi2, it is a thin wrapper around the functionality of the pairwise metrics.
      It uses the an additive chi squared metric to calculate kernel between instances
      in a feature array. Evaluation of the gradient is not analytic but numeric and all kernels
      support only isotropic distances.                                                    \item
      PairwiseChi2, it is a thin wrapper around the functionality of the pairwise metrics. It uses
      the a chi squared metric to calculate kernel between instances
      in a feature array. Evaluation of the gradient is not analytic but numeric and all kernels
      support only isotropic distances.                                                    \item
      PairwisePoly, it is a thin wrapper around the functionality of the pairwise metrics. It uses
      the a poly metric to calculate kernel between instances
      in a feature array. Evaluation of the gradient is not analytic but numeric and all kernels
      support only isotropic distances.                                                    \item
      PairwisePolynomial, it is a thin wrapper around the functionality of the pairwise metrics. It
      uses the a polynomial metric to calculate kernel between instances
      in a feature array. Evaluation of the gradient is not analytic but numeric and all kernels
      support only isotropic distances.                                                    \item
      PairwiseRbf, it is a thin wrapper around the functionality of the pairwise metrics. It uses
      the a rbf metric to calculate kernel between instances
      in a feature array. Evaluation of the gradient is not analytic but numeric and all kernels
      support only isotropic distances.                                                    \item
      PairwiseLaplacian, it is a thin wrapper around the functionality of the pairwise metrics. It
      uses the a laplacian metric to calculate kernel between instances
      in a feature array. Evaluation of the gradient is not analytic but numeric and all kernels
      support only isotropic distances.                                                    \item
      PairwiseSigmoid, it is a thin wrapper around the functionality of the pairwise metrics. It
      uses the a sigmoid metric to calculate kernel between instances
      in a feature array. Evaluation of the gradient is not analytic but numeric and all kernels
      support only isotropic distances.                                                    \item
      PairwiseCosine, it is a thin wrapper around the functionality of the pairwise metrics. It uses
      the a cosine metric to calculate kernel between instances
      in a feature array. Evaluation of the gradient is not analytic but numeric and all kernels
      support only isotropic distances.                                                    \item
      RBF, it is a stationary kernel. It is also known as the ``squared exponential'' kernel. It is
      parameterized by a length scale parameter $l>0$,
      which can either be a scalar (isotropic variant of the kernel) or a vector with the same
      number of dimensions as the inputs $X$ (anisotropic variant of the kernel).
      The kernel is given by $k(x\_i, x\_j) = \exp\left(- \frac{d(x\_i, x\_j)^2}{2l^2} \right)$ where
      $l$ is the length scale of the kernel and $d(\cdot,\cdot)$ is the Euclidean distance.
      \item RationalQuadratic, it can be seen as a scale mixture (an infinite sum) of RBF kernels
      with different characteristic length scales. It is parameterized by a length scale parameter
      $l>0$ and a scale mixture parameter $\alpha>0$ . The kernel is given by $k(x\_i, x\_j) = \left(1
      + \frac{d(x\_i, x\_j)^2 }{ 2\alpha  l^2}\right)^{-\alpha}$ where
      $d(\cdot,\cdot)$ is the Euclidean distance.
      \end{itemize}.
  \default{None}

    \item \xmlNode{alpha}: \xmlDesc{float}, 
      Value added to the diagonal of the kernel matrix during fitting. This can prevent a potential
      numerical issue during fitting, by ensuring that the calculated
      values form a positive definite matrix. It can also be interpreted as the variance of
      additional Gaussian measurement noise on the training observations.
  \default{1e-10}

    \item \xmlNode{n\_restarts\_optimizer}: \xmlDesc{integer}, 
      The number of restarts of the optimizer for finding the kernel's parameters which maximize the
      log-marginal likelihood. The first run of the optimizer is performed
      from the kernel's initial parameters, the remaining ones (if any) from thetas sampled log-
      uniform randomly from the space of allowed theta-values. If greater than
      0, all bounds must be finite.
  \default{0}

    \item \xmlNode{normalize\_y}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Whether the target values y are normalized, the mean and variance of the target values are set
      equal to 0 and 1 respectively. This is recommended for cases where zero-mean,
      unit-variance priors are used.
  \default{False}

    \item \xmlNode{random\_state}: \xmlDesc{integer}, 
      Seed for the internal random number generator.
  \default{None}

    \item \xmlNode{optimizer}: \xmlDesc{[fmin\_l\_bfgs\_b]}, 
      Per default, the 'L-BFGS-B' algorithm from
      scipy.optimize.minimize is used. If None is passed, the kernel’s
      parameters are kept fixed.
  \default{fmin\_l\_bfgs\_b}
  \end{itemize}


\subsubsection{OneVsOneClassifier}
  The \xmlNode{OneVsOneClassifier} (\textit{One-vs-one multiclass strategy})
  This strategy consists in fitting one classifier per class pair. At prediction time, the class
  which received the most votes is selected.
  \zNormalizationNotPerformed{OneVsOneClassifier}

  The \xmlNode{OneVsOneClassifier} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{OneVsOneClassifier} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.
  \default{time}

    \item \xmlNode{featureSelection}:
      Apply feature selection algorithm

      The \xmlNode{featureSelection} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{RFE}:
          The \xmlString{RFE} (Recursive Feature Elimination) is a feature selection algorithm.
          Feature selection refers to techniques that select a subset of the most relevant features
          for a model (ROM).         Fewer features can allow ROMs to run more efficiently (less
          space or time complexity) and be more effective.         Indeed, some ROMs (machine
          learning algorithms) can be misled by irrelevant input features, resulting in worse
          predictive performance.         RFE is a wrapper-type feature selection algorithm. This
          means that a different ROM is given and used in the core of the         method,         is
          wrapped by RFE, and used to help select features.         \\RFE works by searching for a
          subset of features by starting with all features in the training dataset and successfully
          removing         features until the desired number remains.         This is achieved by
          fitting the given ROME used in the core of the model, ranking features by importance,
          discarding the least important features, and re-fitting the model. This process is
          repeated until a specified number of         features remains.         When the full model
          is created, a measure of variable importance is computed that ranks the predictors from
          most         important to least.         At each stage of the search, the least important
          predictors are iteratively eliminated prior to rebuilding the model.         Features are
          scored either using the ROM model (if the model provides a mean to compute feature
          importances) or by         using a statistical method.         \\In RAVEN the
          \xmlString{RFE} class refers to an augmentation of the basic algorithm, since it allows,
          optionally,         to perform the search on multiple groups of targets (separately) and
          then combine the results of the search in a         single set. In addition, when the RFE
          search is concluded, the user can request to identify the set of features         that
          bring to a minimization of the score (i.e. maximimization of the accuracy).         In
          addition, using the ``applyClusteringFiltering'' option, the algorithm can, using an
          hierarchal clustering algorithm,         identify highly correlated features to speed up
          the subsequential search.
          The \xmlNode{RFE} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{RFE} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{nFeaturesToSelect}: \xmlDesc{integer}, 
              Exact Number of features to select. If not inputted, ``nFeaturesToSelect'' will be set
              to $1/2$ of the features in the training dataset.
  \default{None}

            \item \xmlNode{maxNumberFeatures}: \xmlDesc{integer}, 
              Maximum Number of features to select, the algorithm will automatically determine the
              feature list to minimize a total score.
  \default{None}

            \item \xmlNode{onlyOutputScore}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              If maxNumberFeatures is on, only output score should beconsidered? Or, in case of
              particular models (e.g. DMDC), state variable space score should be considered as
              well.
  \default{False}

            \item \xmlNode{applyClusteringFiltering}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              Applying clustering correlation before RFE search? If true, an hierarchal clustering
              is applied on the feature         space aimed to remove features that are correlated
              before the actual RFE search is performed. This approach can stabilize and
              accelerate the process in case of large feature spaces (e.g > 500 features).
  \default{False}

            \item \xmlNode{applyCrossCorrelation}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              In case of subgroupping, should a cross correleation analysis should be performed
              cross sub-groups?         If it is activated, a cross correleation analysis is used to
              additionally filter the features selected for each         sub-groupping search.
  \default{False}

            \item \xmlNode{step}: \xmlDesc{float}, 
              If greater than or equal to 1, then step corresponds to the (integer) number
              of features to remove at each iteration. If within (0.0, 1.0), then step
              corresponds to the percentage (rounded down) of features to remove at         each
              iteration.
  \default{1}

            \item \xmlNode{subGroup}: \xmlDesc{comma-separated strings, integers, and floats}, 
              Subgroup of output variables on which to perform the search. Multiple nodes of this
              type can be inputted. The RFE search will be then performed in each ``subgroup''
              separately and then the the union of the different feature sets are used for the final
              ROM.
          \end{itemize}

        \item \xmlNode{VarianceThreshold}:
          The \xmlString{VarianceThreshold} is a feature selector that removes     all low-variance
          features. This feature selection algorithm looks only at the features and not     the
          desired outputs. The variance threshold can be set by the user.
          The \xmlNode{VarianceThreshold} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{VarianceThreshold} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{threshold}: \xmlDesc{float}, 
              Features with a training-set variance lower than this threshold                   will
              be removed. The default is to keep all features with non-zero
              variance, i.e. remove the features that have the same value in all
              samples.
  \default{0.0}
          \end{itemize}
      \end{itemize}

    \item \xmlNode{featureSpaceTransformation}:
      Use dimensionality reduction technique to perform a trasformation of the training dataset
      into an uncorrelated one. The dimensionality of the problem will not be reduced but
      the data will be transformed in the transformed space. E.g if the number of features
      are 5, the method projects such features into a new uncorrelated space (still 5-dimensional).
      In case of time-dependent ROMs, all the samples are concatenated in a global 2D matrix
      (n\_samples*n\_timesteps,n\_features) before applying the transformation and then reconstructed
      back into the original shape (before fitting the model).

      The \xmlNode{featureSpaceTransformation} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{transformationMethod}: \xmlDesc{[PCA, KernelLinearPCA, KernelPolyPCA, KernelRbfPCA, KernelSigmoidPCA, KernelCosinePCA, ICA]}, 
          Transformation method to use. Eight options (5 Kernel PCAs) are available:
          \begin{itemize}                     \item \textit{PCA}, Principal Component Analysis;
          \item \textit{KernelLinearPCA}, Kernel (Linear) Principal component analysis;
          \item \textit{KernelPolyPCA}, Kernel (Poly) Principal component analysis;
          \item \textit{KernelRbfPCA}, Kernel(Rbf) Principal component analysis;
          \item \textit{KernelSigmoidPCA}, Kernel (Sigmoid) Principal component analysis;
          \item \textit{KernelCosinePCA}, Kernel (Cosine) Principal component analysis;
          \item \textit{ICA}, Independent component analysis;                    \end{itemize}
  \default{PCA}

        \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
          List of IDs of features/variables to include in the transformation process.
  \default{None}

        \item \xmlNode{whichSpace}: \xmlDesc{string}, 
          Which space to search? Target or Feature?
  \default{Feature}
      \end{itemize}

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{estimator}: \xmlDesc{string}, 
      name of a ROM that can be used as an estimator
      The \xmlNode{estimator} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, required}, 
            RAVEN class for this entity (e.g. Samplers, Models, DataObjects)
          \item \xmlAttr{type}: \xmlDesc{string, required}, 
            RAVEN type for this entity; a subtype of the class (e.g. MonteCarlo, Code, PointSet)
      \end{itemize}

    \item \xmlNode{n\_jobs}: \xmlDesc{integer}, 
      The number of jobs to use for the computation: the n\_classes * ( n\_classes - 1) / 2 OVO
      problems are computed in parallel. None means 1 unless in a joblib.parallel\_backend
      context. -1 means using all processors.
  \default{None}
  \end{itemize}


\subsubsection{OneVsRestClassifier}
  The \xmlNode{OneVsRestClassifier} (\textit{One-vs-the-rest (OvR) multiclass strategy})
  Also known as one-vs-all, this strategy consists in fitting one classifier per class. For each
  classifier, the class is fitted against all the other classes. In addition to its computational
  efficiency (only n\_classes classifiers are needed), one advantage of this approach is its
  interpretability. Since each class is represented by one and one classifier only, it is
  possible to gain knowledge about the class by inspecting its corresponding classifier.
  This is the most commonly used strategy for multiclass classification and is a fair default
  choice.                         \zNormalizationNotPerformed{OneVsRestClassifier}

  The \xmlNode{OneVsRestClassifier} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{OneVsRestClassifier} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.
  \default{time}

    \item \xmlNode{featureSelection}:
      Apply feature selection algorithm

      The \xmlNode{featureSelection} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{RFE}:
          The \xmlString{RFE} (Recursive Feature Elimination) is a feature selection algorithm.
          Feature selection refers to techniques that select a subset of the most relevant features
          for a model (ROM).         Fewer features can allow ROMs to run more efficiently (less
          space or time complexity) and be more effective.         Indeed, some ROMs (machine
          learning algorithms) can be misled by irrelevant input features, resulting in worse
          predictive performance.         RFE is a wrapper-type feature selection algorithm. This
          means that a different ROM is given and used in the core of the         method,         is
          wrapped by RFE, and used to help select features.         \\RFE works by searching for a
          subset of features by starting with all features in the training dataset and successfully
          removing         features until the desired number remains.         This is achieved by
          fitting the given ROME used in the core of the model, ranking features by importance,
          discarding the least important features, and re-fitting the model. This process is
          repeated until a specified number of         features remains.         When the full model
          is created, a measure of variable importance is computed that ranks the predictors from
          most         important to least.         At each stage of the search, the least important
          predictors are iteratively eliminated prior to rebuilding the model.         Features are
          scored either using the ROM model (if the model provides a mean to compute feature
          importances) or by         using a statistical method.         \\In RAVEN the
          \xmlString{RFE} class refers to an augmentation of the basic algorithm, since it allows,
          optionally,         to perform the search on multiple groups of targets (separately) and
          then combine the results of the search in a         single set. In addition, when the RFE
          search is concluded, the user can request to identify the set of features         that
          bring to a minimization of the score (i.e. maximimization of the accuracy).         In
          addition, using the ``applyClusteringFiltering'' option, the algorithm can, using an
          hierarchal clustering algorithm,         identify highly correlated features to speed up
          the subsequential search.
          The \xmlNode{RFE} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{RFE} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{nFeaturesToSelect}: \xmlDesc{integer}, 
              Exact Number of features to select. If not inputted, ``nFeaturesToSelect'' will be set
              to $1/2$ of the features in the training dataset.
  \default{None}

            \item \xmlNode{maxNumberFeatures}: \xmlDesc{integer}, 
              Maximum Number of features to select, the algorithm will automatically determine the
              feature list to minimize a total score.
  \default{None}

            \item \xmlNode{onlyOutputScore}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              If maxNumberFeatures is on, only output score should beconsidered? Or, in case of
              particular models (e.g. DMDC), state variable space score should be considered as
              well.
  \default{False}

            \item \xmlNode{applyClusteringFiltering}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              Applying clustering correlation before RFE search? If true, an hierarchal clustering
              is applied on the feature         space aimed to remove features that are correlated
              before the actual RFE search is performed. This approach can stabilize and
              accelerate the process in case of large feature spaces (e.g > 500 features).
  \default{False}

            \item \xmlNode{applyCrossCorrelation}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              In case of subgroupping, should a cross correleation analysis should be performed
              cross sub-groups?         If it is activated, a cross correleation analysis is used to
              additionally filter the features selected for each         sub-groupping search.
  \default{False}

            \item \xmlNode{step}: \xmlDesc{float}, 
              If greater than or equal to 1, then step corresponds to the (integer) number
              of features to remove at each iteration. If within (0.0, 1.0), then step
              corresponds to the percentage (rounded down) of features to remove at         each
              iteration.
  \default{1}

            \item \xmlNode{subGroup}: \xmlDesc{comma-separated strings, integers, and floats}, 
              Subgroup of output variables on which to perform the search. Multiple nodes of this
              type can be inputted. The RFE search will be then performed in each ``subgroup''
              separately and then the the union of the different feature sets are used for the final
              ROM.
          \end{itemize}

        \item \xmlNode{VarianceThreshold}:
          The \xmlString{VarianceThreshold} is a feature selector that removes     all low-variance
          features. This feature selection algorithm looks only at the features and not     the
          desired outputs. The variance threshold can be set by the user.
          The \xmlNode{VarianceThreshold} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{VarianceThreshold} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{threshold}: \xmlDesc{float}, 
              Features with a training-set variance lower than this threshold                   will
              be removed. The default is to keep all features with non-zero
              variance, i.e. remove the features that have the same value in all
              samples.
  \default{0.0}
          \end{itemize}
      \end{itemize}

    \item \xmlNode{featureSpaceTransformation}:
      Use dimensionality reduction technique to perform a trasformation of the training dataset
      into an uncorrelated one. The dimensionality of the problem will not be reduced but
      the data will be transformed in the transformed space. E.g if the number of features
      are 5, the method projects such features into a new uncorrelated space (still 5-dimensional).
      In case of time-dependent ROMs, all the samples are concatenated in a global 2D matrix
      (n\_samples*n\_timesteps,n\_features) before applying the transformation and then reconstructed
      back into the original shape (before fitting the model).

      The \xmlNode{featureSpaceTransformation} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{transformationMethod}: \xmlDesc{[PCA, KernelLinearPCA, KernelPolyPCA, KernelRbfPCA, KernelSigmoidPCA, KernelCosinePCA, ICA]}, 
          Transformation method to use. Eight options (5 Kernel PCAs) are available:
          \begin{itemize}                     \item \textit{PCA}, Principal Component Analysis;
          \item \textit{KernelLinearPCA}, Kernel (Linear) Principal component analysis;
          \item \textit{KernelPolyPCA}, Kernel (Poly) Principal component analysis;
          \item \textit{KernelRbfPCA}, Kernel(Rbf) Principal component analysis;
          \item \textit{KernelSigmoidPCA}, Kernel (Sigmoid) Principal component analysis;
          \item \textit{KernelCosinePCA}, Kernel (Cosine) Principal component analysis;
          \item \textit{ICA}, Independent component analysis;                    \end{itemize}
  \default{PCA}

        \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
          List of IDs of features/variables to include in the transformation process.
  \default{None}

        \item \xmlNode{whichSpace}: \xmlDesc{string}, 
          Which space to search? Target or Feature?
  \default{Feature}
      \end{itemize}

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{estimator}: \xmlDesc{string}, 
      name of a ROM that can be used as an estimator
      The \xmlNode{estimator} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, required}, 
            RAVEN class for this entity (e.g. Samplers, Models, DataObjects)
          \item \xmlAttr{type}: \xmlDesc{string, required}, 
            RAVEN type for this entity; a subtype of the class (e.g. MonteCarlo, Code, PointSet)
      \end{itemize}

    \item \xmlNode{n\_jobs}: \xmlDesc{integer}, 
      TThe number of jobs to use for the computation: the n\_classes one-vs-rest
      problems are computed in parallel. None means 1 unless in a joblib.parallel\_backend
      context. -1 means using all processors.
  \default{None}
  \end{itemize}


\subsubsection{OutputCodeClassifier}
  The \xmlNode{OutputCodeClassifier} (\textit{(Error-Correcting) Output-Code multiclass strategy})
  Output-code based strategies consist in representing each class with a binary code (an array of
  0s and 1s). At fitting time, one binary classifier per bit in the code book is fitted. At
  prediction time, the classifiers are used to project new points in the class space and the class
  closest to the points is chosen. The main advantage of these strategies is that the number of
  classifiers used can be controlled by the user, either for compressing the model
  (0 < code\_size < 1) or for making the model more robust to errors (code\_size > 1). See the
  documentation for more details.
  \zNormalizationNotPerformed{OutputCodeClassifier}

  The \xmlNode{OutputCodeClassifier} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{OutputCodeClassifier} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.
  \default{time}

    \item \xmlNode{featureSelection}:
      Apply feature selection algorithm

      The \xmlNode{featureSelection} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{RFE}:
          The \xmlString{RFE} (Recursive Feature Elimination) is a feature selection algorithm.
          Feature selection refers to techniques that select a subset of the most relevant features
          for a model (ROM).         Fewer features can allow ROMs to run more efficiently (less
          space or time complexity) and be more effective.         Indeed, some ROMs (machine
          learning algorithms) can be misled by irrelevant input features, resulting in worse
          predictive performance.         RFE is a wrapper-type feature selection algorithm. This
          means that a different ROM is given and used in the core of the         method,         is
          wrapped by RFE, and used to help select features.         \\RFE works by searching for a
          subset of features by starting with all features in the training dataset and successfully
          removing         features until the desired number remains.         This is achieved by
          fitting the given ROME used in the core of the model, ranking features by importance,
          discarding the least important features, and re-fitting the model. This process is
          repeated until a specified number of         features remains.         When the full model
          is created, a measure of variable importance is computed that ranks the predictors from
          most         important to least.         At each stage of the search, the least important
          predictors are iteratively eliminated prior to rebuilding the model.         Features are
          scored either using the ROM model (if the model provides a mean to compute feature
          importances) or by         using a statistical method.         \\In RAVEN the
          \xmlString{RFE} class refers to an augmentation of the basic algorithm, since it allows,
          optionally,         to perform the search on multiple groups of targets (separately) and
          then combine the results of the search in a         single set. In addition, when the RFE
          search is concluded, the user can request to identify the set of features         that
          bring to a minimization of the score (i.e. maximimization of the accuracy).         In
          addition, using the ``applyClusteringFiltering'' option, the algorithm can, using an
          hierarchal clustering algorithm,         identify highly correlated features to speed up
          the subsequential search.
          The \xmlNode{RFE} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{RFE} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{nFeaturesToSelect}: \xmlDesc{integer}, 
              Exact Number of features to select. If not inputted, ``nFeaturesToSelect'' will be set
              to $1/2$ of the features in the training dataset.
  \default{None}

            \item \xmlNode{maxNumberFeatures}: \xmlDesc{integer}, 
              Maximum Number of features to select, the algorithm will automatically determine the
              feature list to minimize a total score.
  \default{None}

            \item \xmlNode{onlyOutputScore}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              If maxNumberFeatures is on, only output score should beconsidered? Or, in case of
              particular models (e.g. DMDC), state variable space score should be considered as
              well.
  \default{False}

            \item \xmlNode{applyClusteringFiltering}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              Applying clustering correlation before RFE search? If true, an hierarchal clustering
              is applied on the feature         space aimed to remove features that are correlated
              before the actual RFE search is performed. This approach can stabilize and
              accelerate the process in case of large feature spaces (e.g > 500 features).
  \default{False}

            \item \xmlNode{applyCrossCorrelation}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              In case of subgroupping, should a cross correleation analysis should be performed
              cross sub-groups?         If it is activated, a cross correleation analysis is used to
              additionally filter the features selected for each         sub-groupping search.
  \default{False}

            \item \xmlNode{step}: \xmlDesc{float}, 
              If greater than or equal to 1, then step corresponds to the (integer) number
              of features to remove at each iteration. If within (0.0, 1.0), then step
              corresponds to the percentage (rounded down) of features to remove at         each
              iteration.
  \default{1}

            \item \xmlNode{subGroup}: \xmlDesc{comma-separated strings, integers, and floats}, 
              Subgroup of output variables on which to perform the search. Multiple nodes of this
              type can be inputted. The RFE search will be then performed in each ``subgroup''
              separately and then the the union of the different feature sets are used for the final
              ROM.
          \end{itemize}

        \item \xmlNode{VarianceThreshold}:
          The \xmlString{VarianceThreshold} is a feature selector that removes     all low-variance
          features. This feature selection algorithm looks only at the features and not     the
          desired outputs. The variance threshold can be set by the user.
          The \xmlNode{VarianceThreshold} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{VarianceThreshold} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{threshold}: \xmlDesc{float}, 
              Features with a training-set variance lower than this threshold                   will
              be removed. The default is to keep all features with non-zero
              variance, i.e. remove the features that have the same value in all
              samples.
  \default{0.0}
          \end{itemize}
      \end{itemize}

    \item \xmlNode{featureSpaceTransformation}:
      Use dimensionality reduction technique to perform a trasformation of the training dataset
      into an uncorrelated one. The dimensionality of the problem will not be reduced but
      the data will be transformed in the transformed space. E.g if the number of features
      are 5, the method projects such features into a new uncorrelated space (still 5-dimensional).
      In case of time-dependent ROMs, all the samples are concatenated in a global 2D matrix
      (n\_samples*n\_timesteps,n\_features) before applying the transformation and then reconstructed
      back into the original shape (before fitting the model).

      The \xmlNode{featureSpaceTransformation} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{transformationMethod}: \xmlDesc{[PCA, KernelLinearPCA, KernelPolyPCA, KernelRbfPCA, KernelSigmoidPCA, KernelCosinePCA, ICA]}, 
          Transformation method to use. Eight options (5 Kernel PCAs) are available:
          \begin{itemize}                     \item \textit{PCA}, Principal Component Analysis;
          \item \textit{KernelLinearPCA}, Kernel (Linear) Principal component analysis;
          \item \textit{KernelPolyPCA}, Kernel (Poly) Principal component analysis;
          \item \textit{KernelRbfPCA}, Kernel(Rbf) Principal component analysis;
          \item \textit{KernelSigmoidPCA}, Kernel (Sigmoid) Principal component analysis;
          \item \textit{KernelCosinePCA}, Kernel (Cosine) Principal component analysis;
          \item \textit{ICA}, Independent component analysis;                    \end{itemize}
  \default{PCA}

        \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
          List of IDs of features/variables to include in the transformation process.
  \default{None}

        \item \xmlNode{whichSpace}: \xmlDesc{string}, 
          Which space to search? Target or Feature?
  \default{Feature}
      \end{itemize}

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{estimator}: \xmlDesc{string}, 
      name of a ROM that can be used as an estimator
      The \xmlNode{estimator} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, required}, 
            RAVEN class for this entity (e.g. Samplers, Models, DataObjects)
          \item \xmlAttr{type}: \xmlDesc{string, required}, 
            RAVEN type for this entity; a subtype of the class (e.g. MonteCarlo, Code, PointSet)
      \end{itemize}

    \item \xmlNode{code\_size}: \xmlDesc{float}, 
      Percentage of the number of classes to be used to create
      the code book. A number between 0 and 1 will require fewer classifiers
      than one-vs-the-rest. A number greater than 1 will require more classifiers
      than one-vs-the-rest.
  \default{1.5}

    \item \xmlNode{random\_state}: \xmlDesc{integer}, 
      The generator used to initialize the codebook. Pass an int
      for reproducible output across multiple function calls.
  \default{None}

    \item \xmlNode{n\_jobs}: \xmlDesc{integer}, 
      TThe number of jobs to use for the computation: the n\_classes one-vs-rest
      problems are computed in parallel. None means 1 unless in a joblib.parallel\_backend
      context. -1 means using all processors. See Glossary for more details.
  \default{None}
  \end{itemize}


\subsubsection{KNeighborsClassifier}
  The \xmlNode{KNeighborsClassifier} is a type of instance-based learning or
  non-generalizing learning: it does not attempt to construct a general internal
  model, but simply stores instances of the training data.                          Classification
  is computed from a simple majority vote of the nearest neighbors                          of each
  point: a query point is assigned the data class which has the most
  representatives within the nearest neighbors of the point.                          It implements
  learning based on the $k$ nearest neighbors of each query point,                          where
  $k$ is an integer value specified by the user.
  \zNormalizationPerformed{KNeighborsClassifier}

  The \xmlNode{KNeighborsClassifier} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{KNeighborsClassifier} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.
  \default{time}

    \item \xmlNode{featureSelection}:
      Apply feature selection algorithm

      The \xmlNode{featureSelection} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{RFE}:
          The \xmlString{RFE} (Recursive Feature Elimination) is a feature selection algorithm.
          Feature selection refers to techniques that select a subset of the most relevant features
          for a model (ROM).         Fewer features can allow ROMs to run more efficiently (less
          space or time complexity) and be more effective.         Indeed, some ROMs (machine
          learning algorithms) can be misled by irrelevant input features, resulting in worse
          predictive performance.         RFE is a wrapper-type feature selection algorithm. This
          means that a different ROM is given and used in the core of the         method,         is
          wrapped by RFE, and used to help select features.         \\RFE works by searching for a
          subset of features by starting with all features in the training dataset and successfully
          removing         features until the desired number remains.         This is achieved by
          fitting the given ROME used in the core of the model, ranking features by importance,
          discarding the least important features, and re-fitting the model. This process is
          repeated until a specified number of         features remains.         When the full model
          is created, a measure of variable importance is computed that ranks the predictors from
          most         important to least.         At each stage of the search, the least important
          predictors are iteratively eliminated prior to rebuilding the model.         Features are
          scored either using the ROM model (if the model provides a mean to compute feature
          importances) or by         using a statistical method.         \\In RAVEN the
          \xmlString{RFE} class refers to an augmentation of the basic algorithm, since it allows,
          optionally,         to perform the search on multiple groups of targets (separately) and
          then combine the results of the search in a         single set. In addition, when the RFE
          search is concluded, the user can request to identify the set of features         that
          bring to a minimization of the score (i.e. maximimization of the accuracy).         In
          addition, using the ``applyClusteringFiltering'' option, the algorithm can, using an
          hierarchal clustering algorithm,         identify highly correlated features to speed up
          the subsequential search.
          The \xmlNode{RFE} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{RFE} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{nFeaturesToSelect}: \xmlDesc{integer}, 
              Exact Number of features to select. If not inputted, ``nFeaturesToSelect'' will be set
              to $1/2$ of the features in the training dataset.
  \default{None}

            \item \xmlNode{maxNumberFeatures}: \xmlDesc{integer}, 
              Maximum Number of features to select, the algorithm will automatically determine the
              feature list to minimize a total score.
  \default{None}

            \item \xmlNode{onlyOutputScore}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              If maxNumberFeatures is on, only output score should beconsidered? Or, in case of
              particular models (e.g. DMDC), state variable space score should be considered as
              well.
  \default{False}

            \item \xmlNode{applyClusteringFiltering}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              Applying clustering correlation before RFE search? If true, an hierarchal clustering
              is applied on the feature         space aimed to remove features that are correlated
              before the actual RFE search is performed. This approach can stabilize and
              accelerate the process in case of large feature spaces (e.g > 500 features).
  \default{False}

            \item \xmlNode{applyCrossCorrelation}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              In case of subgroupping, should a cross correleation analysis should be performed
              cross sub-groups?         If it is activated, a cross correleation analysis is used to
              additionally filter the features selected for each         sub-groupping search.
  \default{False}

            \item \xmlNode{step}: \xmlDesc{float}, 
              If greater than or equal to 1, then step corresponds to the (integer) number
              of features to remove at each iteration. If within (0.0, 1.0), then step
              corresponds to the percentage (rounded down) of features to remove at         each
              iteration.
  \default{1}

            \item \xmlNode{subGroup}: \xmlDesc{comma-separated strings, integers, and floats}, 
              Subgroup of output variables on which to perform the search. Multiple nodes of this
              type can be inputted. The RFE search will be then performed in each ``subgroup''
              separately and then the the union of the different feature sets are used for the final
              ROM.
          \end{itemize}

        \item \xmlNode{VarianceThreshold}:
          The \xmlString{VarianceThreshold} is a feature selector that removes     all low-variance
          features. This feature selection algorithm looks only at the features and not     the
          desired outputs. The variance threshold can be set by the user.
          The \xmlNode{VarianceThreshold} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{VarianceThreshold} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{threshold}: \xmlDesc{float}, 
              Features with a training-set variance lower than this threshold                   will
              be removed. The default is to keep all features with non-zero
              variance, i.e. remove the features that have the same value in all
              samples.
  \default{0.0}
          \end{itemize}
      \end{itemize}

    \item \xmlNode{featureSpaceTransformation}:
      Use dimensionality reduction technique to perform a trasformation of the training dataset
      into an uncorrelated one. The dimensionality of the problem will not be reduced but
      the data will be transformed in the transformed space. E.g if the number of features
      are 5, the method projects such features into a new uncorrelated space (still 5-dimensional).
      In case of time-dependent ROMs, all the samples are concatenated in a global 2D matrix
      (n\_samples*n\_timesteps,n\_features) before applying the transformation and then reconstructed
      back into the original shape (before fitting the model).

      The \xmlNode{featureSpaceTransformation} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{transformationMethod}: \xmlDesc{[PCA, KernelLinearPCA, KernelPolyPCA, KernelRbfPCA, KernelSigmoidPCA, KernelCosinePCA, ICA]}, 
          Transformation method to use. Eight options (5 Kernel PCAs) are available:
          \begin{itemize}                     \item \textit{PCA}, Principal Component Analysis;
          \item \textit{KernelLinearPCA}, Kernel (Linear) Principal component analysis;
          \item \textit{KernelPolyPCA}, Kernel (Poly) Principal component analysis;
          \item \textit{KernelRbfPCA}, Kernel(Rbf) Principal component analysis;
          \item \textit{KernelSigmoidPCA}, Kernel (Sigmoid) Principal component analysis;
          \item \textit{KernelCosinePCA}, Kernel (Cosine) Principal component analysis;
          \item \textit{ICA}, Independent component analysis;                    \end{itemize}
  \default{PCA}

        \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
          List of IDs of features/variables to include in the transformation process.
  \default{None}

        \item \xmlNode{whichSpace}: \xmlDesc{string}, 
          Which space to search? Target or Feature?
  \default{Feature}
      \end{itemize}

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{n\_neighbors}: \xmlDesc{integer}, 
      Number of neighbors to use by default for kneighbors queries.
  \default{5}

    \item \xmlNode{weights}: \xmlDesc{[uniform, distance]}, 
      weight function used in prediction. If ``uniform'', all points in each neighborhood
      are weighted equally. If ``distance'' weight points by the inverse of their distance. in this
      case,closer neighbors of a query point will have a greater influence than neighbors which are
      further away.
  \default{uniform}

    \item \xmlNode{algorithm}: \xmlDesc{[auto, ball\_tree, kd\_tree, brute]}, 
      Algorithm used to compute the nearest neighbors
  \default{auto}

    \item \xmlNode{leaf\_size}: \xmlDesc{integer}, 
      Leaf size passed to BallTree or KDTree. This can affect the speed of the construction
      and query, as well as the memory required to store the tree. The optimal value depends on the
      nature of the problem.
  \default{30}

    \item \xmlNode{p}: \xmlDesc{integer}, 
      Power parameter for the Minkowski metric. When $p = 1$, this is equivalent to using
      manhattan\_distance (l1), and euclidean\_distance (l2) for $p = 2$. For arbitrary $p$,
      minkowski\_distance                                                  (l\_p) is used.
  \default{2}

    \item \xmlNode{metric}: \xmlDesc{[euclidean, manhattan, minkowski, chebyshev, hamming, braycurtis]}, 
      the distance metric to use for the tree. The default metric is minkowski, and with
      $p=2$ is equivalent to the standard Euclidean metric.
      The available metrics are:                                                  \begin{itemize}
      \item minkowski: $sum(|x - y|^p)^(1/p)$
      \item euclidean: $sqrt(sum((x - y)^2))$
      \item manhattan: $sum(|x - y|)$                                                    \item
      chebyshev: $max(|x - y|)$                                                    \item hamming:
      $N\_unequal(x, y) / N\_tot$                                                    \item canberra:
      $sum(|x - y| / (|x| + |y|))$                                                    \item
      braycurtis: $sum(|x - y|) / (sum(|x|) + sum(|y|))$
      \end{itemize}
  \default{minkowski}
  \end{itemize}


\subsubsection{NearestCentroid}
  The \xmlNode{RadiusNeighborsClassifier} is a type of instance-based learning or
  non-generalizing learning: it does not attempt to construct a general internal
  model, but simply stores instances of the training data.                          Classification
  is computed from a simple majority vote of the nearest neighbors                          of each
  point: a query point is assigned the data class which has the most
  representatives within the nearest neighbors of the point.                          It implements
  learning based on the number of neighbors within a fixed radius                          $r$ of
  each training point, where $r$ is a floating-point value specified by the
  user.                          \zNormalizationPerformed{RadiusNeighborsClassifier}

  The \xmlNode{NearestCentroid} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{NearestCentroid} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.
  \default{time}

    \item \xmlNode{featureSelection}:
      Apply feature selection algorithm

      The \xmlNode{featureSelection} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{RFE}:
          The \xmlString{RFE} (Recursive Feature Elimination) is a feature selection algorithm.
          Feature selection refers to techniques that select a subset of the most relevant features
          for a model (ROM).         Fewer features can allow ROMs to run more efficiently (less
          space or time complexity) and be more effective.         Indeed, some ROMs (machine
          learning algorithms) can be misled by irrelevant input features, resulting in worse
          predictive performance.         RFE is a wrapper-type feature selection algorithm. This
          means that a different ROM is given and used in the core of the         method,         is
          wrapped by RFE, and used to help select features.         \\RFE works by searching for a
          subset of features by starting with all features in the training dataset and successfully
          removing         features until the desired number remains.         This is achieved by
          fitting the given ROME used in the core of the model, ranking features by importance,
          discarding the least important features, and re-fitting the model. This process is
          repeated until a specified number of         features remains.         When the full model
          is created, a measure of variable importance is computed that ranks the predictors from
          most         important to least.         At each stage of the search, the least important
          predictors are iteratively eliminated prior to rebuilding the model.         Features are
          scored either using the ROM model (if the model provides a mean to compute feature
          importances) or by         using a statistical method.         \\In RAVEN the
          \xmlString{RFE} class refers to an augmentation of the basic algorithm, since it allows,
          optionally,         to perform the search on multiple groups of targets (separately) and
          then combine the results of the search in a         single set. In addition, when the RFE
          search is concluded, the user can request to identify the set of features         that
          bring to a minimization of the score (i.e. maximimization of the accuracy).         In
          addition, using the ``applyClusteringFiltering'' option, the algorithm can, using an
          hierarchal clustering algorithm,         identify highly correlated features to speed up
          the subsequential search.
          The \xmlNode{RFE} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{RFE} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{nFeaturesToSelect}: \xmlDesc{integer}, 
              Exact Number of features to select. If not inputted, ``nFeaturesToSelect'' will be set
              to $1/2$ of the features in the training dataset.
  \default{None}

            \item \xmlNode{maxNumberFeatures}: \xmlDesc{integer}, 
              Maximum Number of features to select, the algorithm will automatically determine the
              feature list to minimize a total score.
  \default{None}

            \item \xmlNode{onlyOutputScore}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              If maxNumberFeatures is on, only output score should beconsidered? Or, in case of
              particular models (e.g. DMDC), state variable space score should be considered as
              well.
  \default{False}

            \item \xmlNode{applyClusteringFiltering}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              Applying clustering correlation before RFE search? If true, an hierarchal clustering
              is applied on the feature         space aimed to remove features that are correlated
              before the actual RFE search is performed. This approach can stabilize and
              accelerate the process in case of large feature spaces (e.g > 500 features).
  \default{False}

            \item \xmlNode{applyCrossCorrelation}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              In case of subgroupping, should a cross correleation analysis should be performed
              cross sub-groups?         If it is activated, a cross correleation analysis is used to
              additionally filter the features selected for each         sub-groupping search.
  \default{False}

            \item \xmlNode{step}: \xmlDesc{float}, 
              If greater than or equal to 1, then step corresponds to the (integer) number
              of features to remove at each iteration. If within (0.0, 1.0), then step
              corresponds to the percentage (rounded down) of features to remove at         each
              iteration.
  \default{1}

            \item \xmlNode{subGroup}: \xmlDesc{comma-separated strings, integers, and floats}, 
              Subgroup of output variables on which to perform the search. Multiple nodes of this
              type can be inputted. The RFE search will be then performed in each ``subgroup''
              separately and then the the union of the different feature sets are used for the final
              ROM.
          \end{itemize}

        \item \xmlNode{VarianceThreshold}:
          The \xmlString{VarianceThreshold} is a feature selector that removes     all low-variance
          features. This feature selection algorithm looks only at the features and not     the
          desired outputs. The variance threshold can be set by the user.
          The \xmlNode{VarianceThreshold} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{VarianceThreshold} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{threshold}: \xmlDesc{float}, 
              Features with a training-set variance lower than this threshold                   will
              be removed. The default is to keep all features with non-zero
              variance, i.e. remove the features that have the same value in all
              samples.
  \default{0.0}
          \end{itemize}
      \end{itemize}

    \item \xmlNode{featureSpaceTransformation}:
      Use dimensionality reduction technique to perform a trasformation of the training dataset
      into an uncorrelated one. The dimensionality of the problem will not be reduced but
      the data will be transformed in the transformed space. E.g if the number of features
      are 5, the method projects such features into a new uncorrelated space (still 5-dimensional).
      In case of time-dependent ROMs, all the samples are concatenated in a global 2D matrix
      (n\_samples*n\_timesteps,n\_features) before applying the transformation and then reconstructed
      back into the original shape (before fitting the model).

      The \xmlNode{featureSpaceTransformation} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{transformationMethod}: \xmlDesc{[PCA, KernelLinearPCA, KernelPolyPCA, KernelRbfPCA, KernelSigmoidPCA, KernelCosinePCA, ICA]}, 
          Transformation method to use. Eight options (5 Kernel PCAs) are available:
          \begin{itemize}                     \item \textit{PCA}, Principal Component Analysis;
          \item \textit{KernelLinearPCA}, Kernel (Linear) Principal component analysis;
          \item \textit{KernelPolyPCA}, Kernel (Poly) Principal component analysis;
          \item \textit{KernelRbfPCA}, Kernel(Rbf) Principal component analysis;
          \item \textit{KernelSigmoidPCA}, Kernel (Sigmoid) Principal component analysis;
          \item \textit{KernelCosinePCA}, Kernel (Cosine) Principal component analysis;
          \item \textit{ICA}, Independent component analysis;                    \end{itemize}
  \default{PCA}

        \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
          List of IDs of features/variables to include in the transformation process.
  \default{None}

        \item \xmlNode{whichSpace}: \xmlDesc{string}, 
          Which space to search? Target or Feature?
  \default{Feature}
      \end{itemize}

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{shrink\_threshold}: \xmlDesc{float}, 
      Threshold for shrinking centroids to remove features.
  \default{None}

    \item \xmlNode{metric}: \xmlDesc{[uniform, distance]}, 
      The metric to use when calculating distance between instances in a feature array.
      The available metrics are allo the ones explained in the \xmlNode{Metrics} section (pairwise).
      The centroids for the samples corresponding to each class is the point from which the sum of
      the distances (according to the metric) of all samples that belong to that particular class
      are                                                  minimized. If the ``manhattan'' metric is
      provided, this centroid is the median and for all other metrics,
      the centroid is now set to be the mean.
  \default{minkowski}
  \end{itemize}


\subsubsection{RadiusNeighborsRegressor}
  The \xmlNode{RadiusNeighborsRegressor} is a type of instance-based learning or
  non-generalizing learning: it does not attempt to construct a general internal
  model, but simply stores instances of the training data.                          The target is
  predicted by local interpolation of the targets associated of the                          nearest
  neighbors in the training set.                          It implements learning based on the number
  of neighbors within a fixed radius                          $r$ of each training point, where $r$
  is a floating-point value specified by the                          user.
  \zNormalizationPerformed{RadiusNeighborsRegressor}

  The \xmlNode{RadiusNeighborsRegressor} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{RadiusNeighborsRegressor} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.
  \default{time}

    \item \xmlNode{featureSelection}:
      Apply feature selection algorithm

      The \xmlNode{featureSelection} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{RFE}:
          The \xmlString{RFE} (Recursive Feature Elimination) is a feature selection algorithm.
          Feature selection refers to techniques that select a subset of the most relevant features
          for a model (ROM).         Fewer features can allow ROMs to run more efficiently (less
          space or time complexity) and be more effective.         Indeed, some ROMs (machine
          learning algorithms) can be misled by irrelevant input features, resulting in worse
          predictive performance.         RFE is a wrapper-type feature selection algorithm. This
          means that a different ROM is given and used in the core of the         method,         is
          wrapped by RFE, and used to help select features.         \\RFE works by searching for a
          subset of features by starting with all features in the training dataset and successfully
          removing         features until the desired number remains.         This is achieved by
          fitting the given ROME used in the core of the model, ranking features by importance,
          discarding the least important features, and re-fitting the model. This process is
          repeated until a specified number of         features remains.         When the full model
          is created, a measure of variable importance is computed that ranks the predictors from
          most         important to least.         At each stage of the search, the least important
          predictors are iteratively eliminated prior to rebuilding the model.         Features are
          scored either using the ROM model (if the model provides a mean to compute feature
          importances) or by         using a statistical method.         \\In RAVEN the
          \xmlString{RFE} class refers to an augmentation of the basic algorithm, since it allows,
          optionally,         to perform the search on multiple groups of targets (separately) and
          then combine the results of the search in a         single set. In addition, when the RFE
          search is concluded, the user can request to identify the set of features         that
          bring to a minimization of the score (i.e. maximimization of the accuracy).         In
          addition, using the ``applyClusteringFiltering'' option, the algorithm can, using an
          hierarchal clustering algorithm,         identify highly correlated features to speed up
          the subsequential search.
          The \xmlNode{RFE} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{RFE} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{nFeaturesToSelect}: \xmlDesc{integer}, 
              Exact Number of features to select. If not inputted, ``nFeaturesToSelect'' will be set
              to $1/2$ of the features in the training dataset.
  \default{None}

            \item \xmlNode{maxNumberFeatures}: \xmlDesc{integer}, 
              Maximum Number of features to select, the algorithm will automatically determine the
              feature list to minimize a total score.
  \default{None}

            \item \xmlNode{onlyOutputScore}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              If maxNumberFeatures is on, only output score should beconsidered? Or, in case of
              particular models (e.g. DMDC), state variable space score should be considered as
              well.
  \default{False}

            \item \xmlNode{applyClusteringFiltering}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              Applying clustering correlation before RFE search? If true, an hierarchal clustering
              is applied on the feature         space aimed to remove features that are correlated
              before the actual RFE search is performed. This approach can stabilize and
              accelerate the process in case of large feature spaces (e.g > 500 features).
  \default{False}

            \item \xmlNode{applyCrossCorrelation}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              In case of subgroupping, should a cross correleation analysis should be performed
              cross sub-groups?         If it is activated, a cross correleation analysis is used to
              additionally filter the features selected for each         sub-groupping search.
  \default{False}

            \item \xmlNode{step}: \xmlDesc{float}, 
              If greater than or equal to 1, then step corresponds to the (integer) number
              of features to remove at each iteration. If within (0.0, 1.0), then step
              corresponds to the percentage (rounded down) of features to remove at         each
              iteration.
  \default{1}

            \item \xmlNode{subGroup}: \xmlDesc{comma-separated strings, integers, and floats}, 
              Subgroup of output variables on which to perform the search. Multiple nodes of this
              type can be inputted. The RFE search will be then performed in each ``subgroup''
              separately and then the the union of the different feature sets are used for the final
              ROM.
          \end{itemize}

        \item \xmlNode{VarianceThreshold}:
          The \xmlString{VarianceThreshold} is a feature selector that removes     all low-variance
          features. This feature selection algorithm looks only at the features and not     the
          desired outputs. The variance threshold can be set by the user.
          The \xmlNode{VarianceThreshold} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{VarianceThreshold} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{threshold}: \xmlDesc{float}, 
              Features with a training-set variance lower than this threshold                   will
              be removed. The default is to keep all features with non-zero
              variance, i.e. remove the features that have the same value in all
              samples.
  \default{0.0}
          \end{itemize}
      \end{itemize}

    \item \xmlNode{featureSpaceTransformation}:
      Use dimensionality reduction technique to perform a trasformation of the training dataset
      into an uncorrelated one. The dimensionality of the problem will not be reduced but
      the data will be transformed in the transformed space. E.g if the number of features
      are 5, the method projects such features into a new uncorrelated space (still 5-dimensional).
      In case of time-dependent ROMs, all the samples are concatenated in a global 2D matrix
      (n\_samples*n\_timesteps,n\_features) before applying the transformation and then reconstructed
      back into the original shape (before fitting the model).

      The \xmlNode{featureSpaceTransformation} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{transformationMethod}: \xmlDesc{[PCA, KernelLinearPCA, KernelPolyPCA, KernelRbfPCA, KernelSigmoidPCA, KernelCosinePCA, ICA]}, 
          Transformation method to use. Eight options (5 Kernel PCAs) are available:
          \begin{itemize}                     \item \textit{PCA}, Principal Component Analysis;
          \item \textit{KernelLinearPCA}, Kernel (Linear) Principal component analysis;
          \item \textit{KernelPolyPCA}, Kernel (Poly) Principal component analysis;
          \item \textit{KernelRbfPCA}, Kernel(Rbf) Principal component analysis;
          \item \textit{KernelSigmoidPCA}, Kernel (Sigmoid) Principal component analysis;
          \item \textit{KernelCosinePCA}, Kernel (Cosine) Principal component analysis;
          \item \textit{ICA}, Independent component analysis;                    \end{itemize}
  \default{PCA}

        \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
          List of IDs of features/variables to include in the transformation process.
  \default{None}

        \item \xmlNode{whichSpace}: \xmlDesc{string}, 
          Which space to search? Target or Feature?
  \default{Feature}
      \end{itemize}

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{radius}: \xmlDesc{float}, 
      Range of parameter space to use by default for radius neighbors queries.
  \default{1.0}

    \item \xmlNode{weights}: \xmlDesc{[uniform, distance]}, 
      weight function used in prediction. If ``uniform'', all points in each neighborhood
      are weighted equally. If ``distance'' weight points by the inverse of their distance. in this
      case,closer neighbors of a query point will have a greater influence than neighbors which are
      further away.
  \default{uniform}

    \item \xmlNode{algorithm}: \xmlDesc{[auto, ball\_tree, kd\_tree, brute]}, 
      Algorithm used to compute the nearest neighbors
  \default{auto}

    \item \xmlNode{leaf\_size}: \xmlDesc{integer}, 
      Leaf size passed to BallTree or KDTree. This can affect the speed of the construction
      and query, as well as the memory required to store the tree. The optimal value depends on the
      nature of the problem.
  \default{30}

    \item \xmlNode{p}: \xmlDesc{integer}, 
      Power parameter for the Minkowski metric. When $p = 1$, this is equivalent to using
      manhattan\_distance (l1), and euclidean\_distance (l2) for $p = 2$. For arbitrary $p$,
      minkowski\_distance                                                  (l\_p) is used.
  \default{2}

    \item \xmlNode{metric}: \xmlDesc{[minkowski, euclidean, manhattan, chebyshev, hamming, canberra, braycurtis]}, 
      the distance metric to use for the tree. The default metric is minkowski, and with
      $p=2$ is equivalent to the standard Euclidean metric.
      The available metrics are:                                                  \begin{itemize}
      \item minkowski: $sum(|x - y|^p)^(1/p)$
      \item euclidean: $sqrt(sum((x - y)^2))$
      \item manhattan: $sum(|x - y|)$                                                    \item
      chebyshev: $max(|x - y|)$                                                    \item hamming:
      $N\_unequal(x, y) / N\_tot$                                                    \item canberra:
      $sum(|x - y| / (|x| + |y|))$                                                    \item
      braycurtis: $sum(|x - y|) / (sum(|x|) + sum(|y|))$
      \end{itemize}
  \default{minkowski}
  \end{itemize}


\subsubsection{KNeighborsRegressor}
  The \xmlNode{KNeighborsRegressor} is a type of instance-based learning or
  non-generalizing learning: it does not attempt to construct a general internal
  model, but simply stores instances of the training data.                          The target is
  predicted by local interpolation of the targets associated                          of the nearest
  neighbors in the training set.                          It implements learning based on the $k$
  nearest neighbors of each query point,                          where $k$ is an integer value
  specified by the user.                          \zNormalizationPerformed{KNeighborsRegressor}

  The \xmlNode{KNeighborsRegressor} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{KNeighborsRegressor} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.
  \default{time}

    \item \xmlNode{featureSelection}:
      Apply feature selection algorithm

      The \xmlNode{featureSelection} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{RFE}:
          The \xmlString{RFE} (Recursive Feature Elimination) is a feature selection algorithm.
          Feature selection refers to techniques that select a subset of the most relevant features
          for a model (ROM).         Fewer features can allow ROMs to run more efficiently (less
          space or time complexity) and be more effective.         Indeed, some ROMs (machine
          learning algorithms) can be misled by irrelevant input features, resulting in worse
          predictive performance.         RFE is a wrapper-type feature selection algorithm. This
          means that a different ROM is given and used in the core of the         method,         is
          wrapped by RFE, and used to help select features.         \\RFE works by searching for a
          subset of features by starting with all features in the training dataset and successfully
          removing         features until the desired number remains.         This is achieved by
          fitting the given ROME used in the core of the model, ranking features by importance,
          discarding the least important features, and re-fitting the model. This process is
          repeated until a specified number of         features remains.         When the full model
          is created, a measure of variable importance is computed that ranks the predictors from
          most         important to least.         At each stage of the search, the least important
          predictors are iteratively eliminated prior to rebuilding the model.         Features are
          scored either using the ROM model (if the model provides a mean to compute feature
          importances) or by         using a statistical method.         \\In RAVEN the
          \xmlString{RFE} class refers to an augmentation of the basic algorithm, since it allows,
          optionally,         to perform the search on multiple groups of targets (separately) and
          then combine the results of the search in a         single set. In addition, when the RFE
          search is concluded, the user can request to identify the set of features         that
          bring to a minimization of the score (i.e. maximimization of the accuracy).         In
          addition, using the ``applyClusteringFiltering'' option, the algorithm can, using an
          hierarchal clustering algorithm,         identify highly correlated features to speed up
          the subsequential search.
          The \xmlNode{RFE} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{RFE} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{nFeaturesToSelect}: \xmlDesc{integer}, 
              Exact Number of features to select. If not inputted, ``nFeaturesToSelect'' will be set
              to $1/2$ of the features in the training dataset.
  \default{None}

            \item \xmlNode{maxNumberFeatures}: \xmlDesc{integer}, 
              Maximum Number of features to select, the algorithm will automatically determine the
              feature list to minimize a total score.
  \default{None}

            \item \xmlNode{onlyOutputScore}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              If maxNumberFeatures is on, only output score should beconsidered? Or, in case of
              particular models (e.g. DMDC), state variable space score should be considered as
              well.
  \default{False}

            \item \xmlNode{applyClusteringFiltering}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              Applying clustering correlation before RFE search? If true, an hierarchal clustering
              is applied on the feature         space aimed to remove features that are correlated
              before the actual RFE search is performed. This approach can stabilize and
              accelerate the process in case of large feature spaces (e.g > 500 features).
  \default{False}

            \item \xmlNode{applyCrossCorrelation}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              In case of subgroupping, should a cross correleation analysis should be performed
              cross sub-groups?         If it is activated, a cross correleation analysis is used to
              additionally filter the features selected for each         sub-groupping search.
  \default{False}

            \item \xmlNode{step}: \xmlDesc{float}, 
              If greater than or equal to 1, then step corresponds to the (integer) number
              of features to remove at each iteration. If within (0.0, 1.0), then step
              corresponds to the percentage (rounded down) of features to remove at         each
              iteration.
  \default{1}

            \item \xmlNode{subGroup}: \xmlDesc{comma-separated strings, integers, and floats}, 
              Subgroup of output variables on which to perform the search. Multiple nodes of this
              type can be inputted. The RFE search will be then performed in each ``subgroup''
              separately and then the the union of the different feature sets are used for the final
              ROM.
          \end{itemize}

        \item \xmlNode{VarianceThreshold}:
          The \xmlString{VarianceThreshold} is a feature selector that removes     all low-variance
          features. This feature selection algorithm looks only at the features and not     the
          desired outputs. The variance threshold can be set by the user.
          The \xmlNode{VarianceThreshold} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{VarianceThreshold} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{threshold}: \xmlDesc{float}, 
              Features with a training-set variance lower than this threshold                   will
              be removed. The default is to keep all features with non-zero
              variance, i.e. remove the features that have the same value in all
              samples.
  \default{0.0}
          \end{itemize}
      \end{itemize}

    \item \xmlNode{featureSpaceTransformation}:
      Use dimensionality reduction technique to perform a trasformation of the training dataset
      into an uncorrelated one. The dimensionality of the problem will not be reduced but
      the data will be transformed in the transformed space. E.g if the number of features
      are 5, the method projects such features into a new uncorrelated space (still 5-dimensional).
      In case of time-dependent ROMs, all the samples are concatenated in a global 2D matrix
      (n\_samples*n\_timesteps,n\_features) before applying the transformation and then reconstructed
      back into the original shape (before fitting the model).

      The \xmlNode{featureSpaceTransformation} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{transformationMethod}: \xmlDesc{[PCA, KernelLinearPCA, KernelPolyPCA, KernelRbfPCA, KernelSigmoidPCA, KernelCosinePCA, ICA]}, 
          Transformation method to use. Eight options (5 Kernel PCAs) are available:
          \begin{itemize}                     \item \textit{PCA}, Principal Component Analysis;
          \item \textit{KernelLinearPCA}, Kernel (Linear) Principal component analysis;
          \item \textit{KernelPolyPCA}, Kernel (Poly) Principal component analysis;
          \item \textit{KernelRbfPCA}, Kernel(Rbf) Principal component analysis;
          \item \textit{KernelSigmoidPCA}, Kernel (Sigmoid) Principal component analysis;
          \item \textit{KernelCosinePCA}, Kernel (Cosine) Principal component analysis;
          \item \textit{ICA}, Independent component analysis;                    \end{itemize}
  \default{PCA}

        \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
          List of IDs of features/variables to include in the transformation process.
  \default{None}

        \item \xmlNode{whichSpace}: \xmlDesc{string}, 
          Which space to search? Target or Feature?
  \default{Feature}
      \end{itemize}

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{n\_neighbors}: \xmlDesc{integer}, 
      Number of neighbors to use by default for kneighbors queries.
  \default{5}

    \item \xmlNode{weights}: \xmlDesc{[uniform, distance]}, 
      weight function used in prediction. If ``uniform'', all points in each neighborhood
      are weighted equally. If ``distance'' weight points by the inverse of their distance. in this
      case,closer neighbors of a query point will have a greater influence than neighbors which are
      further away.
  \default{uniform}

    \item \xmlNode{algorithm}: \xmlDesc{[auto, ball\_tree, kd\_tree, brute]}, 
      Algorithm used to compute the nearest neighbors
  \default{auto}

    \item \xmlNode{leaf\_size}: \xmlDesc{integer}, 
      Leaf size passed to BallTree or KDTree. This can affect the speed of the construction
      and query, as well as the memory required to store the tree. The optimal value depends on the
      nature of the problem.
  \default{30}

    \item \xmlNode{p}: \xmlDesc{integer}, 
      Power parameter for the Minkowski metric. When $p = 1$, this is equivalent to using
      manhattan\_distance (l1), and euclidean\_distance (l2) for $p = 2$. For arbitrary $p$,
      minkowski\_distance                                                  (l\_p) is used.
  \default{2}

    \item \xmlNode{metric}: \xmlDesc{[euclidean, manhattan, minkowski, chebyshev, hamming, braycurtis]}, 
      the distance metric to use for the tree. The default metric is minkowski, and with
      $p=2$ is equivalent to the standard Euclidean metric.
      The available metrics are:                                                  \begin{itemize}
      \item minkowski: $sum(|x - y|^p)^(1/p)$
      \item euclidean: $sqrt(sum((x - y)^2))$
      \item manhattan: $sum(|x - y|)$                                                    \item
      chebyshev: $max(|x - y|)$                                                    \item hamming:
      $N\_unequal(x, y) / N\_tot$                                                    \item canberra:
      $sum(|x - y| / (|x| + |y|))$                                                    \item
      braycurtis: $sum(|x - y|) / (sum(|x|) + sum(|y|))$
      \end{itemize}
  \default{minkowski}
  \end{itemize}


\subsubsection{RadiusNeighborsClassifier}
  The \xmlNode{RadiusNeighborsClassifier} is a type of instance-based learning or
  non-generalizing learning: it does not attempt to construct a general internal
  model, but simply stores instances of the training data.                          Classification
  is computed from a simple majority vote of the nearest neighbors                          of each
  point: a query point is assigned the data class which has the most
  representatives within the nearest neighbors of the point.                          It implements
  learning based on the number of neighbors within a fixed radius                          $r$ of
  each training point, where $r$ is a floating-point value specified by the
  user.                          \zNormalizationPerformed{RadiusNeighborsClassifier}

  The \xmlNode{RadiusNeighborsClassifier} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{RadiusNeighborsClassifier} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.
  \default{time}

    \item \xmlNode{featureSelection}:
      Apply feature selection algorithm

      The \xmlNode{featureSelection} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{RFE}:
          The \xmlString{RFE} (Recursive Feature Elimination) is a feature selection algorithm.
          Feature selection refers to techniques that select a subset of the most relevant features
          for a model (ROM).         Fewer features can allow ROMs to run more efficiently (less
          space or time complexity) and be more effective.         Indeed, some ROMs (machine
          learning algorithms) can be misled by irrelevant input features, resulting in worse
          predictive performance.         RFE is a wrapper-type feature selection algorithm. This
          means that a different ROM is given and used in the core of the         method,         is
          wrapped by RFE, and used to help select features.         \\RFE works by searching for a
          subset of features by starting with all features in the training dataset and successfully
          removing         features until the desired number remains.         This is achieved by
          fitting the given ROME used in the core of the model, ranking features by importance,
          discarding the least important features, and re-fitting the model. This process is
          repeated until a specified number of         features remains.         When the full model
          is created, a measure of variable importance is computed that ranks the predictors from
          most         important to least.         At each stage of the search, the least important
          predictors are iteratively eliminated prior to rebuilding the model.         Features are
          scored either using the ROM model (if the model provides a mean to compute feature
          importances) or by         using a statistical method.         \\In RAVEN the
          \xmlString{RFE} class refers to an augmentation of the basic algorithm, since it allows,
          optionally,         to perform the search on multiple groups of targets (separately) and
          then combine the results of the search in a         single set. In addition, when the RFE
          search is concluded, the user can request to identify the set of features         that
          bring to a minimization of the score (i.e. maximimization of the accuracy).         In
          addition, using the ``applyClusteringFiltering'' option, the algorithm can, using an
          hierarchal clustering algorithm,         identify highly correlated features to speed up
          the subsequential search.
          The \xmlNode{RFE} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{RFE} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{nFeaturesToSelect}: \xmlDesc{integer}, 
              Exact Number of features to select. If not inputted, ``nFeaturesToSelect'' will be set
              to $1/2$ of the features in the training dataset.
  \default{None}

            \item \xmlNode{maxNumberFeatures}: \xmlDesc{integer}, 
              Maximum Number of features to select, the algorithm will automatically determine the
              feature list to minimize a total score.
  \default{None}

            \item \xmlNode{onlyOutputScore}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              If maxNumberFeatures is on, only output score should beconsidered? Or, in case of
              particular models (e.g. DMDC), state variable space score should be considered as
              well.
  \default{False}

            \item \xmlNode{applyClusteringFiltering}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              Applying clustering correlation before RFE search? If true, an hierarchal clustering
              is applied on the feature         space aimed to remove features that are correlated
              before the actual RFE search is performed. This approach can stabilize and
              accelerate the process in case of large feature spaces (e.g > 500 features).
  \default{False}

            \item \xmlNode{applyCrossCorrelation}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              In case of subgroupping, should a cross correleation analysis should be performed
              cross sub-groups?         If it is activated, a cross correleation analysis is used to
              additionally filter the features selected for each         sub-groupping search.
  \default{False}

            \item \xmlNode{step}: \xmlDesc{float}, 
              If greater than or equal to 1, then step corresponds to the (integer) number
              of features to remove at each iteration. If within (0.0, 1.0), then step
              corresponds to the percentage (rounded down) of features to remove at         each
              iteration.
  \default{1}

            \item \xmlNode{subGroup}: \xmlDesc{comma-separated strings, integers, and floats}, 
              Subgroup of output variables on which to perform the search. Multiple nodes of this
              type can be inputted. The RFE search will be then performed in each ``subgroup''
              separately and then the the union of the different feature sets are used for the final
              ROM.
          \end{itemize}

        \item \xmlNode{VarianceThreshold}:
          The \xmlString{VarianceThreshold} is a feature selector that removes     all low-variance
          features. This feature selection algorithm looks only at the features and not     the
          desired outputs. The variance threshold can be set by the user.
          The \xmlNode{VarianceThreshold} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{VarianceThreshold} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{threshold}: \xmlDesc{float}, 
              Features with a training-set variance lower than this threshold                   will
              be removed. The default is to keep all features with non-zero
              variance, i.e. remove the features that have the same value in all
              samples.
  \default{0.0}
          \end{itemize}
      \end{itemize}

    \item \xmlNode{featureSpaceTransformation}:
      Use dimensionality reduction technique to perform a trasformation of the training dataset
      into an uncorrelated one. The dimensionality of the problem will not be reduced but
      the data will be transformed in the transformed space. E.g if the number of features
      are 5, the method projects such features into a new uncorrelated space (still 5-dimensional).
      In case of time-dependent ROMs, all the samples are concatenated in a global 2D matrix
      (n\_samples*n\_timesteps,n\_features) before applying the transformation and then reconstructed
      back into the original shape (before fitting the model).

      The \xmlNode{featureSpaceTransformation} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{transformationMethod}: \xmlDesc{[PCA, KernelLinearPCA, KernelPolyPCA, KernelRbfPCA, KernelSigmoidPCA, KernelCosinePCA, ICA]}, 
          Transformation method to use. Eight options (5 Kernel PCAs) are available:
          \begin{itemize}                     \item \textit{PCA}, Principal Component Analysis;
          \item \textit{KernelLinearPCA}, Kernel (Linear) Principal component analysis;
          \item \textit{KernelPolyPCA}, Kernel (Poly) Principal component analysis;
          \item \textit{KernelRbfPCA}, Kernel(Rbf) Principal component analysis;
          \item \textit{KernelSigmoidPCA}, Kernel (Sigmoid) Principal component analysis;
          \item \textit{KernelCosinePCA}, Kernel (Cosine) Principal component analysis;
          \item \textit{ICA}, Independent component analysis;                    \end{itemize}
  \default{PCA}

        \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
          List of IDs of features/variables to include in the transformation process.
  \default{None}

        \item \xmlNode{whichSpace}: \xmlDesc{string}, 
          Which space to search? Target or Feature?
  \default{Feature}
      \end{itemize}

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{radius}: \xmlDesc{float}, 
      Range of parameter space to use by default for radius neighbors queries.
  \default{1.0}

    \item \xmlNode{weights}: \xmlDesc{[uniform, distance]}, 
      weight function used in prediction. If ``uniform'', all points in each neighborhood
      are weighted equally. If ``distance'' weight points by the inverse of their distance. in this
      case,closer neighbors of a query point will have a greater influence than neighbors which are
      further away.
  \default{uniform}

    \item \xmlNode{algorithm}: \xmlDesc{[auto, ball\_tree, kd\_tree, brute]}, 
      Algorithm used to compute the nearest neighbors
  \default{auto}

    \item \xmlNode{leaf\_size}: \xmlDesc{integer}, 
      Leaf size passed to BallTree or KDTree. This can affect the speed of the construction
      and query, as well as the memory required to store the tree. The optimal value depends on the
      nature of the problem.
  \default{30}

    \item \xmlNode{p}: \xmlDesc{integer}, 
      Power parameter for the Minkowski metric. When $p = 1$, this is equivalent to using
      manhattan\_distance (l1), and euclidean\_distance (l2) for $p = 2$. For arbitrary $p$,
      minkowski\_distance                                                  (l\_p) is used.
  \default{2}

    \item \xmlNode{metric}: \xmlDesc{[minkowski, euclidean, manhattan, chebyshev, hamming, canberra, braycurtis]}, 
      the distance metric to use for the tree. The default metric is minkowski, and with
      $p=2$ is equivalent to the standard Euclidean metric.
      The available metrics are:                                                  \begin{itemize}
      \item minkowski: $sum(|x - y|^p)^(1/p)$
      \item euclidean: $sqrt(sum((x - y)^2))$
      \item manhattan: $sum(|x - y|)$                                                    \item
      chebyshev: $max(|x - y|)$                                                    \item hamming:
      $N\_unequal(x, y) / N\_tot$                                                    \item canberra:
      $sum(|x - y| / (|x| + |y|))$                                                    \item
      braycurtis: $sum(|x - y|) / (sum(|x|) + sum(|y|))$
      \end{itemize}
  \default{minkowski}

    \item \xmlNode{outlier\_label}: \xmlDesc{comma-separated strings}, 
      label for outlier samples (samples with no neighbors in given radius).
      The available options are:                                                  \begin{itemize}
      \item manual label: strings or int labels. list of manual labels if multi-output is used.
      \item most\_frequent: assign the most frequent label of y to outliers.
      \item None: when any outlier is detected, an error will be raised.
      \end{itemize}
  \default{None}
  \end{itemize}


\subsubsection{LinearSVC}
  The \xmlNode{LinearSVC} \textit{Linear Support Vector Classification} is
  similar to SVC with parameter kernel=’linear’, but implemented in terms of liblinear rather than
  libsvm,                             so it has more flexibility in the choice of penalties and loss
  functions and should scale better to large numbers of samples.                             This
  class supports both dense and sparse input and the multiclass support is handled according to a
  one-vs-the-rest scheme.                             \zNormalizationPerformed{LinearSVC}

  The \xmlNode{LinearSVC} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{LinearSVC} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.
  \default{time}

    \item \xmlNode{featureSelection}:
      Apply feature selection algorithm

      The \xmlNode{featureSelection} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{RFE}:
          The \xmlString{RFE} (Recursive Feature Elimination) is a feature selection algorithm.
          Feature selection refers to techniques that select a subset of the most relevant features
          for a model (ROM).         Fewer features can allow ROMs to run more efficiently (less
          space or time complexity) and be more effective.         Indeed, some ROMs (machine
          learning algorithms) can be misled by irrelevant input features, resulting in worse
          predictive performance.         RFE is a wrapper-type feature selection algorithm. This
          means that a different ROM is given and used in the core of the         method,         is
          wrapped by RFE, and used to help select features.         \\RFE works by searching for a
          subset of features by starting with all features in the training dataset and successfully
          removing         features until the desired number remains.         This is achieved by
          fitting the given ROME used in the core of the model, ranking features by importance,
          discarding the least important features, and re-fitting the model. This process is
          repeated until a specified number of         features remains.         When the full model
          is created, a measure of variable importance is computed that ranks the predictors from
          most         important to least.         At each stage of the search, the least important
          predictors are iteratively eliminated prior to rebuilding the model.         Features are
          scored either using the ROM model (if the model provides a mean to compute feature
          importances) or by         using a statistical method.         \\In RAVEN the
          \xmlString{RFE} class refers to an augmentation of the basic algorithm, since it allows,
          optionally,         to perform the search on multiple groups of targets (separately) and
          then combine the results of the search in a         single set. In addition, when the RFE
          search is concluded, the user can request to identify the set of features         that
          bring to a minimization of the score (i.e. maximimization of the accuracy).         In
          addition, using the ``applyClusteringFiltering'' option, the algorithm can, using an
          hierarchal clustering algorithm,         identify highly correlated features to speed up
          the subsequential search.
          The \xmlNode{RFE} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{RFE} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{nFeaturesToSelect}: \xmlDesc{integer}, 
              Exact Number of features to select. If not inputted, ``nFeaturesToSelect'' will be set
              to $1/2$ of the features in the training dataset.
  \default{None}

            \item \xmlNode{maxNumberFeatures}: \xmlDesc{integer}, 
              Maximum Number of features to select, the algorithm will automatically determine the
              feature list to minimize a total score.
  \default{None}

            \item \xmlNode{onlyOutputScore}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              If maxNumberFeatures is on, only output score should beconsidered? Or, in case of
              particular models (e.g. DMDC), state variable space score should be considered as
              well.
  \default{False}

            \item \xmlNode{applyClusteringFiltering}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              Applying clustering correlation before RFE search? If true, an hierarchal clustering
              is applied on the feature         space aimed to remove features that are correlated
              before the actual RFE search is performed. This approach can stabilize and
              accelerate the process in case of large feature spaces (e.g > 500 features).
  \default{False}

            \item \xmlNode{applyCrossCorrelation}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              In case of subgroupping, should a cross correleation analysis should be performed
              cross sub-groups?         If it is activated, a cross correleation analysis is used to
              additionally filter the features selected for each         sub-groupping search.
  \default{False}

            \item \xmlNode{step}: \xmlDesc{float}, 
              If greater than or equal to 1, then step corresponds to the (integer) number
              of features to remove at each iteration. If within (0.0, 1.0), then step
              corresponds to the percentage (rounded down) of features to remove at         each
              iteration.
  \default{1}

            \item \xmlNode{subGroup}: \xmlDesc{comma-separated strings, integers, and floats}, 
              Subgroup of output variables on which to perform the search. Multiple nodes of this
              type can be inputted. The RFE search will be then performed in each ``subgroup''
              separately and then the the union of the different feature sets are used for the final
              ROM.
          \end{itemize}

        \item \xmlNode{VarianceThreshold}:
          The \xmlString{VarianceThreshold} is a feature selector that removes     all low-variance
          features. This feature selection algorithm looks only at the features and not     the
          desired outputs. The variance threshold can be set by the user.
          The \xmlNode{VarianceThreshold} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{VarianceThreshold} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{threshold}: \xmlDesc{float}, 
              Features with a training-set variance lower than this threshold                   will
              be removed. The default is to keep all features with non-zero
              variance, i.e. remove the features that have the same value in all
              samples.
  \default{0.0}
          \end{itemize}
      \end{itemize}

    \item \xmlNode{featureSpaceTransformation}:
      Use dimensionality reduction technique to perform a trasformation of the training dataset
      into an uncorrelated one. The dimensionality of the problem will not be reduced but
      the data will be transformed in the transformed space. E.g if the number of features
      are 5, the method projects such features into a new uncorrelated space (still 5-dimensional).
      In case of time-dependent ROMs, all the samples are concatenated in a global 2D matrix
      (n\_samples*n\_timesteps,n\_features) before applying the transformation and then reconstructed
      back into the original shape (before fitting the model).

      The \xmlNode{featureSpaceTransformation} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{transformationMethod}: \xmlDesc{[PCA, KernelLinearPCA, KernelPolyPCA, KernelRbfPCA, KernelSigmoidPCA, KernelCosinePCA, ICA]}, 
          Transformation method to use. Eight options (5 Kernel PCAs) are available:
          \begin{itemize}                     \item \textit{PCA}, Principal Component Analysis;
          \item \textit{KernelLinearPCA}, Kernel (Linear) Principal component analysis;
          \item \textit{KernelPolyPCA}, Kernel (Poly) Principal component analysis;
          \item \textit{KernelRbfPCA}, Kernel(Rbf) Principal component analysis;
          \item \textit{KernelSigmoidPCA}, Kernel (Sigmoid) Principal component analysis;
          \item \textit{KernelCosinePCA}, Kernel (Cosine) Principal component analysis;
          \item \textit{ICA}, Independent component analysis;                    \end{itemize}
  \default{PCA}

        \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
          List of IDs of features/variables to include in the transformation process.
  \default{None}

        \item \xmlNode{whichSpace}: \xmlDesc{string}, 
          Which space to search? Target or Feature?
  \default{Feature}
      \end{itemize}

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{penalty}: \xmlDesc{[l1, l2]}, 
      Specifies the norm used in the penalization. The ``l2'' penalty is the standard used in SVC.
      The ``l1' leads to coefficients vectors that are sparse.
  \default{l2}

    \item \xmlNode{loss}: \xmlDesc{[hinge, squared\_hinge]}, 
      Specifies the loss function. ``hinge'' is the standard SVM loss (used e.g. by the SVC class)
      while ``squared\_hinge'' is the square of the hinge loss. The combination of penalty=``l1' and
      loss=``hinge''                                                  is not supported.
  \default{squared\_hinge}

    \item \xmlNode{dual}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Select the algorithm to either solve the dual or primal optimization problem.
      Prefer dual=False when $n\_samples > n\_features$.
  \default{True}

    \item \xmlNode{C}: \xmlDesc{float}, 
      Regularization parameter. The strength of the regularization is inversely
      proportional to C.                                                            Must be strictly
      positive. The penalty is a squared l2 penalty..
  \default{1.0}

    \item \xmlNode{tol}: \xmlDesc{float}, 
      Tolerance for stopping criterion
  \default{0.0001}

    \item \xmlNode{multi\_class}: \xmlDesc{[crammer\_singer, ovr]}, 
      Determines the multi-class strategy if y contains more than two classes. ``ovr'' trains
      $n\_classes$ one-vs-rest classifiers, while ``crammer\_singer'' optimizes a joint objective over
      all classes.                                                  While crammer\_singer is
      interesting from a theoretical perspective as it is consistent, it is seldom used
      in practice as it rarely leads to better accuracy and is more expensive to compute. If
      ``crammer\_singer''                                                  is chosen, the options
      loss, penalty and dual will be ignored.
  \default{ovr}

    \item \xmlNode{fit\_intercept}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Whether to calculate the intercept for this model. If set to false, no
      intercept will be used in calculations (i.e. data is expected to be already centered).
  \default{True}

    \item \xmlNode{intercept\_scaling}: \xmlDesc{float}, 
      When fit\_intercept is True, instance vector x becomes $[x, intercept\_scaling]$,
      i.e. a “synthetic” feature with constant value equals to intercept\_scaling is appended
      to the instance vector. The intercept becomes $intercept\_scaling * synthetic feature weight$
      \nb the synthetic feature weight is subject to $l1/l2$ regularization as all other features.
      To lessen the effect of regularization on synthetic feature weight (and therefore on the
      intercept)                                                  $intercept\_scaling$ has to be
      increased.
  \default{1.0}

    \item \xmlNode{max\_iter}: \xmlDesc{integer}, 
      Hard limit on iterations within solver.``-1'' for no limit
  \default{1000}

    \item \xmlNode{verbose}: \xmlDesc{integer}, 
      Enable verbose output. Note that this setting takes advantage
      of a per-process runtime setting in liblinear that, if enabled, may not
      work properly in a multithreaded context.
  \default{0}

    \item \xmlNode{random\_state}: \xmlDesc{integer}, 
      Controls the pseudo random number generation for shuffling
      the data for the dual coordinate descent (if dual=True). When dual=False
      the underlying implementation of LinearSVC is not random and
      random\_state has no effect on the results. Pass an int for reproducible
      output across multiple function calls.
  \default{None}

    \item \xmlNode{class\_weight}: \xmlDesc{[balanced]}, 
      If not given, all classes are supposed to have weight one.
      The “balanced” mode uses the values of y to automatically adjust weights
      inversely proportional to class frequencies in the input data
  \default{None}
  \end{itemize}


\subsubsection{LinearSVR}
  The \xmlNode{LinearSVR} \textit{Linear Support Vector Regressor} is
  similar to SVR with parameter kernel=’linear’, but implemented in terms of liblinear rather than
  libsvm,                             so it has more flexibility in the choice of penalties and loss
  functions and should scale better to large numbers of samples.                             This
  class supports both dense and sparse input.
  \zNormalizationPerformed{LinearSVR}

  The \xmlNode{LinearSVR} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{LinearSVR} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.
  \default{time}

    \item \xmlNode{featureSelection}:
      Apply feature selection algorithm

      The \xmlNode{featureSelection} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{RFE}:
          The \xmlString{RFE} (Recursive Feature Elimination) is a feature selection algorithm.
          Feature selection refers to techniques that select a subset of the most relevant features
          for a model (ROM).         Fewer features can allow ROMs to run more efficiently (less
          space or time complexity) and be more effective.         Indeed, some ROMs (machine
          learning algorithms) can be misled by irrelevant input features, resulting in worse
          predictive performance.         RFE is a wrapper-type feature selection algorithm. This
          means that a different ROM is given and used in the core of the         method,         is
          wrapped by RFE, and used to help select features.         \\RFE works by searching for a
          subset of features by starting with all features in the training dataset and successfully
          removing         features until the desired number remains.         This is achieved by
          fitting the given ROME used in the core of the model, ranking features by importance,
          discarding the least important features, and re-fitting the model. This process is
          repeated until a specified number of         features remains.         When the full model
          is created, a measure of variable importance is computed that ranks the predictors from
          most         important to least.         At each stage of the search, the least important
          predictors are iteratively eliminated prior to rebuilding the model.         Features are
          scored either using the ROM model (if the model provides a mean to compute feature
          importances) or by         using a statistical method.         \\In RAVEN the
          \xmlString{RFE} class refers to an augmentation of the basic algorithm, since it allows,
          optionally,         to perform the search on multiple groups of targets (separately) and
          then combine the results of the search in a         single set. In addition, when the RFE
          search is concluded, the user can request to identify the set of features         that
          bring to a minimization of the score (i.e. maximimization of the accuracy).         In
          addition, using the ``applyClusteringFiltering'' option, the algorithm can, using an
          hierarchal clustering algorithm,         identify highly correlated features to speed up
          the subsequential search.
          The \xmlNode{RFE} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{RFE} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{nFeaturesToSelect}: \xmlDesc{integer}, 
              Exact Number of features to select. If not inputted, ``nFeaturesToSelect'' will be set
              to $1/2$ of the features in the training dataset.
  \default{None}

            \item \xmlNode{maxNumberFeatures}: \xmlDesc{integer}, 
              Maximum Number of features to select, the algorithm will automatically determine the
              feature list to minimize a total score.
  \default{None}

            \item \xmlNode{onlyOutputScore}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              If maxNumberFeatures is on, only output score should beconsidered? Or, in case of
              particular models (e.g. DMDC), state variable space score should be considered as
              well.
  \default{False}

            \item \xmlNode{applyClusteringFiltering}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              Applying clustering correlation before RFE search? If true, an hierarchal clustering
              is applied on the feature         space aimed to remove features that are correlated
              before the actual RFE search is performed. This approach can stabilize and
              accelerate the process in case of large feature spaces (e.g > 500 features).
  \default{False}

            \item \xmlNode{applyCrossCorrelation}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              In case of subgroupping, should a cross correleation analysis should be performed
              cross sub-groups?         If it is activated, a cross correleation analysis is used to
              additionally filter the features selected for each         sub-groupping search.
  \default{False}

            \item \xmlNode{step}: \xmlDesc{float}, 
              If greater than or equal to 1, then step corresponds to the (integer) number
              of features to remove at each iteration. If within (0.0, 1.0), then step
              corresponds to the percentage (rounded down) of features to remove at         each
              iteration.
  \default{1}

            \item \xmlNode{subGroup}: \xmlDesc{comma-separated strings, integers, and floats}, 
              Subgroup of output variables on which to perform the search. Multiple nodes of this
              type can be inputted. The RFE search will be then performed in each ``subgroup''
              separately and then the the union of the different feature sets are used for the final
              ROM.
          \end{itemize}

        \item \xmlNode{VarianceThreshold}:
          The \xmlString{VarianceThreshold} is a feature selector that removes     all low-variance
          features. This feature selection algorithm looks only at the features and not     the
          desired outputs. The variance threshold can be set by the user.
          The \xmlNode{VarianceThreshold} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{VarianceThreshold} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{threshold}: \xmlDesc{float}, 
              Features with a training-set variance lower than this threshold                   will
              be removed. The default is to keep all features with non-zero
              variance, i.e. remove the features that have the same value in all
              samples.
  \default{0.0}
          \end{itemize}
      \end{itemize}

    \item \xmlNode{featureSpaceTransformation}:
      Use dimensionality reduction technique to perform a trasformation of the training dataset
      into an uncorrelated one. The dimensionality of the problem will not be reduced but
      the data will be transformed in the transformed space. E.g if the number of features
      are 5, the method projects such features into a new uncorrelated space (still 5-dimensional).
      In case of time-dependent ROMs, all the samples are concatenated in a global 2D matrix
      (n\_samples*n\_timesteps,n\_features) before applying the transformation and then reconstructed
      back into the original shape (before fitting the model).

      The \xmlNode{featureSpaceTransformation} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{transformationMethod}: \xmlDesc{[PCA, KernelLinearPCA, KernelPolyPCA, KernelRbfPCA, KernelSigmoidPCA, KernelCosinePCA, ICA]}, 
          Transformation method to use. Eight options (5 Kernel PCAs) are available:
          \begin{itemize}                     \item \textit{PCA}, Principal Component Analysis;
          \item \textit{KernelLinearPCA}, Kernel (Linear) Principal component analysis;
          \item \textit{KernelPolyPCA}, Kernel (Poly) Principal component analysis;
          \item \textit{KernelRbfPCA}, Kernel(Rbf) Principal component analysis;
          \item \textit{KernelSigmoidPCA}, Kernel (Sigmoid) Principal component analysis;
          \item \textit{KernelCosinePCA}, Kernel (Cosine) Principal component analysis;
          \item \textit{ICA}, Independent component analysis;                    \end{itemize}
  \default{PCA}

        \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
          List of IDs of features/variables to include in the transformation process.
  \default{None}

        \item \xmlNode{whichSpace}: \xmlDesc{string}, 
          Which space to search? Target or Feature?
  \default{Feature}
      \end{itemize}

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{epsilon}: \xmlDesc{float}, 
      Epsilon parameter in the epsilon-insensitive loss function. The value of
      this parameter depends on the scale of the target variable y. If unsure, set $epsilon=0.$
  \default{0.0}

    \item \xmlNode{loss}: \xmlDesc{[epsilon\_insensitive’, squared\_epsilon\_insensitive]}, 
      Specifies the loss function. The epsilon-insensitive loss (standard SVR)
      is the L1 loss, while the squared epsilon-insensitive loss (``squared\_epsilon\_insensitive'')
      is the L2 loss.
  \default{squared\_epsilon\_insensitive}

    \item \xmlNode{tol}: \xmlDesc{float}, 
      Tolerance for stopping criterion
  \default{0.0001}

    \item \xmlNode{fit\_intercept}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Whether to calculate the intercept for this model. If set to false, no
      intercept will be used in calculations (i.e. data is expected to be already centered).
  \default{True}

    \item \xmlNode{intercept\_scaling}: \xmlDesc{float}, 
      When fit\_intercept is True, instance vector x becomes $[x, intercept\_scaling]$,
      i.e. a “synthetic” feature with constant value equals to intercept\_scaling is appended
      to the instance vector. The intercept becomes $intercept\_scaling * synthetic feature weight$
      \nb the synthetic feature weight is subject to $l1/l2$ regularization as all other features.
      To lessen the effect of regularization on synthetic feature weight (and therefore on the
      intercept)                                                  $intercept\_scaling$ has to be
      increased.
  \default{1.0}

    \item \xmlNode{dual}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Select the algorithm to either solve the dual or primal optimization problem.
      Prefer dual=False when $n\_samples > n\_features$.
  \default{True}

    \item \xmlNode{max\_iter}: \xmlDesc{integer}, 
      Hard limit on iterations within solver.``-1'' for no limit
  \default{-1}
  \end{itemize}


\subsubsection{NuSVC}
  The \xmlNode{NuSVC} \textit{Nu-Support Vector Classification} is an Nu-Support Vector
  Classification.                             It is very similar to SVC but with the addition of the
  hyper-parameter Nu for controlling the                             number of support vectors. In
  NuSVC nu replaces C of SVC.                             The implementation is based on libsvm.
  \zNormalizationPerformed{NuSVC}

  The \xmlNode{NuSVC} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{NuSVC} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.
  \default{time}

    \item \xmlNode{featureSelection}:
      Apply feature selection algorithm

      The \xmlNode{featureSelection} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{RFE}:
          The \xmlString{RFE} (Recursive Feature Elimination) is a feature selection algorithm.
          Feature selection refers to techniques that select a subset of the most relevant features
          for a model (ROM).         Fewer features can allow ROMs to run more efficiently (less
          space or time complexity) and be more effective.         Indeed, some ROMs (machine
          learning algorithms) can be misled by irrelevant input features, resulting in worse
          predictive performance.         RFE is a wrapper-type feature selection algorithm. This
          means that a different ROM is given and used in the core of the         method,         is
          wrapped by RFE, and used to help select features.         \\RFE works by searching for a
          subset of features by starting with all features in the training dataset and successfully
          removing         features until the desired number remains.         This is achieved by
          fitting the given ROME used in the core of the model, ranking features by importance,
          discarding the least important features, and re-fitting the model. This process is
          repeated until a specified number of         features remains.         When the full model
          is created, a measure of variable importance is computed that ranks the predictors from
          most         important to least.         At each stage of the search, the least important
          predictors are iteratively eliminated prior to rebuilding the model.         Features are
          scored either using the ROM model (if the model provides a mean to compute feature
          importances) or by         using a statistical method.         \\In RAVEN the
          \xmlString{RFE} class refers to an augmentation of the basic algorithm, since it allows,
          optionally,         to perform the search on multiple groups of targets (separately) and
          then combine the results of the search in a         single set. In addition, when the RFE
          search is concluded, the user can request to identify the set of features         that
          bring to a minimization of the score (i.e. maximimization of the accuracy).         In
          addition, using the ``applyClusteringFiltering'' option, the algorithm can, using an
          hierarchal clustering algorithm,         identify highly correlated features to speed up
          the subsequential search.
          The \xmlNode{RFE} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{RFE} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{nFeaturesToSelect}: \xmlDesc{integer}, 
              Exact Number of features to select. If not inputted, ``nFeaturesToSelect'' will be set
              to $1/2$ of the features in the training dataset.
  \default{None}

            \item \xmlNode{maxNumberFeatures}: \xmlDesc{integer}, 
              Maximum Number of features to select, the algorithm will automatically determine the
              feature list to minimize a total score.
  \default{None}

            \item \xmlNode{onlyOutputScore}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              If maxNumberFeatures is on, only output score should beconsidered? Or, in case of
              particular models (e.g. DMDC), state variable space score should be considered as
              well.
  \default{False}

            \item \xmlNode{applyClusteringFiltering}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              Applying clustering correlation before RFE search? If true, an hierarchal clustering
              is applied on the feature         space aimed to remove features that are correlated
              before the actual RFE search is performed. This approach can stabilize and
              accelerate the process in case of large feature spaces (e.g > 500 features).
  \default{False}

            \item \xmlNode{applyCrossCorrelation}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              In case of subgroupping, should a cross correleation analysis should be performed
              cross sub-groups?         If it is activated, a cross correleation analysis is used to
              additionally filter the features selected for each         sub-groupping search.
  \default{False}

            \item \xmlNode{step}: \xmlDesc{float}, 
              If greater than or equal to 1, then step corresponds to the (integer) number
              of features to remove at each iteration. If within (0.0, 1.0), then step
              corresponds to the percentage (rounded down) of features to remove at         each
              iteration.
  \default{1}

            \item \xmlNode{subGroup}: \xmlDesc{comma-separated strings, integers, and floats}, 
              Subgroup of output variables on which to perform the search. Multiple nodes of this
              type can be inputted. The RFE search will be then performed in each ``subgroup''
              separately and then the the union of the different feature sets are used for the final
              ROM.
          \end{itemize}

        \item \xmlNode{VarianceThreshold}:
          The \xmlString{VarianceThreshold} is a feature selector that removes     all low-variance
          features. This feature selection algorithm looks only at the features and not     the
          desired outputs. The variance threshold can be set by the user.
          The \xmlNode{VarianceThreshold} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{VarianceThreshold} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{threshold}: \xmlDesc{float}, 
              Features with a training-set variance lower than this threshold                   will
              be removed. The default is to keep all features with non-zero
              variance, i.e. remove the features that have the same value in all
              samples.
  \default{0.0}
          \end{itemize}
      \end{itemize}

    \item \xmlNode{featureSpaceTransformation}:
      Use dimensionality reduction technique to perform a trasformation of the training dataset
      into an uncorrelated one. The dimensionality of the problem will not be reduced but
      the data will be transformed in the transformed space. E.g if the number of features
      are 5, the method projects such features into a new uncorrelated space (still 5-dimensional).
      In case of time-dependent ROMs, all the samples are concatenated in a global 2D matrix
      (n\_samples*n\_timesteps,n\_features) before applying the transformation and then reconstructed
      back into the original shape (before fitting the model).

      The \xmlNode{featureSpaceTransformation} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{transformationMethod}: \xmlDesc{[PCA, KernelLinearPCA, KernelPolyPCA, KernelRbfPCA, KernelSigmoidPCA, KernelCosinePCA, ICA]}, 
          Transformation method to use. Eight options (5 Kernel PCAs) are available:
          \begin{itemize}                     \item \textit{PCA}, Principal Component Analysis;
          \item \textit{KernelLinearPCA}, Kernel (Linear) Principal component analysis;
          \item \textit{KernelPolyPCA}, Kernel (Poly) Principal component analysis;
          \item \textit{KernelRbfPCA}, Kernel(Rbf) Principal component analysis;
          \item \textit{KernelSigmoidPCA}, Kernel (Sigmoid) Principal component analysis;
          \item \textit{KernelCosinePCA}, Kernel (Cosine) Principal component analysis;
          \item \textit{ICA}, Independent component analysis;                    \end{itemize}
  \default{PCA}

        \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
          List of IDs of features/variables to include in the transformation process.
  \default{None}

        \item \xmlNode{whichSpace}: \xmlDesc{string}, 
          Which space to search? Target or Feature?
  \default{Feature}
      \end{itemize}

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{nu}: \xmlDesc{float}, 
      An upper bound on the fraction of margin errors and
      a lower bound of the fraction of support vectors. Should be in the interval $(0, 1]$.
  \default{0.5}

    \item \xmlNode{kernel}: \xmlDesc{[linear, poly, rbf, sigmoid]}, 
      Specifies the kernel type to be used in the algorithm. It must be one of
      ``linear'', ``poly'', ``rbf'' or ``sigmoid''.
  \default{rbf}

    \item \xmlNode{degree}: \xmlDesc{integer}, 
      Degree of the polynomial kernel function ('poly').Ignored by all other kernels.
  \default{3}

    \item \xmlNode{gamma}: \xmlDesc{float}, 
      Kernel coefficient for ``poly'', ``rbf'' or ``sigmoid''. If not input, then it uses
      $1 / (n\_features * X.var())$ as value of gamma
  \default{scale}

    \item \xmlNode{coef0}: \xmlDesc{float}, 
      Independent term in kernel function
  \default{0.0}

    \item \xmlNode{tol}: \xmlDesc{float}, 
      Tolerance for stopping criterion
  \default{0.001}

    \item \xmlNode{cache\_size}: \xmlDesc{float}, 
      Size of the kernel cache (in MB)
  \default{200.0}

    \item \xmlNode{shrinking}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Whether to use the shrinking heuristic.
  \default{True}

    \item \xmlNode{max\_iter}: \xmlDesc{integer}, 
      Hard limit on iterations within solver.``-1'' for no limit
  \default{-1}

    \item \xmlNode{decision\_function\_shape}: \xmlDesc{[ovo, ovr]}, 
      Whether to return a one-vs-rest (``ovr'') decision function of shape $(n\_samples, n\_classes)$
      as                                                            all other classifiers, or the
      original one-vs-one (``ovo'') decision function of libsvm which has
      shape $(n\_samples, n\_classes * (n\_classes - 1) / 2)$. However, one-vs-one (``ovo'') is always
      used as                                                            multi-class strategy. The
      parameter is ignored for binary classification.
  \default{ovr}

    \item \xmlNode{verbose}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Enable verbose output. Note that this setting takes advantage
      of a per-process runtime setting in libsvm that, if enabled, may not
      work properly in a multithreaded context.
  \default{False}

    \item \xmlNode{probability}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Whether to enable probability estimates.
  \default{False}

    \item \xmlNode{class\_weight}: \xmlDesc{[balanced]}, 
      If not given, all classes are supposed to have weight one.
      The “balanced” mode uses the values of y to automatically adjust weights
      inversely proportional to class frequencies in the input data
  \default{None}

    \item \xmlNode{random\_state}: \xmlDesc{integer}, 
      Controls the pseudo random number generation for shuffling
      the data for probability estimates. Ignored when probability is False.
      Pass an int for reproducible output across multiple function calls.
  \default{None}
  \end{itemize}


\subsubsection{NuSVR}
  The \xmlNode{NuSVR} \textit{Nu-Support Vector Regression} is an Nu-Support Vector Regressor.
  It is very similar to SVC but with the addition of the hyper-parameter Nu for controlling the
  number of support vectors. However, unlike NuSVC, where nu replaces C,
  here nu replaces the parameter epsilon of epsilon-SVR.
  \zNormalizationPerformed{NuSVR}

  The \xmlNode{NuSVR} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{NuSVR} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.
  \default{time}

    \item \xmlNode{featureSelection}:
      Apply feature selection algorithm

      The \xmlNode{featureSelection} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{RFE}:
          The \xmlString{RFE} (Recursive Feature Elimination) is a feature selection algorithm.
          Feature selection refers to techniques that select a subset of the most relevant features
          for a model (ROM).         Fewer features can allow ROMs to run more efficiently (less
          space or time complexity) and be more effective.         Indeed, some ROMs (machine
          learning algorithms) can be misled by irrelevant input features, resulting in worse
          predictive performance.         RFE is a wrapper-type feature selection algorithm. This
          means that a different ROM is given and used in the core of the         method,         is
          wrapped by RFE, and used to help select features.         \\RFE works by searching for a
          subset of features by starting with all features in the training dataset and successfully
          removing         features until the desired number remains.         This is achieved by
          fitting the given ROME used in the core of the model, ranking features by importance,
          discarding the least important features, and re-fitting the model. This process is
          repeated until a specified number of         features remains.         When the full model
          is created, a measure of variable importance is computed that ranks the predictors from
          most         important to least.         At each stage of the search, the least important
          predictors are iteratively eliminated prior to rebuilding the model.         Features are
          scored either using the ROM model (if the model provides a mean to compute feature
          importances) or by         using a statistical method.         \\In RAVEN the
          \xmlString{RFE} class refers to an augmentation of the basic algorithm, since it allows,
          optionally,         to perform the search on multiple groups of targets (separately) and
          then combine the results of the search in a         single set. In addition, when the RFE
          search is concluded, the user can request to identify the set of features         that
          bring to a minimization of the score (i.e. maximimization of the accuracy).         In
          addition, using the ``applyClusteringFiltering'' option, the algorithm can, using an
          hierarchal clustering algorithm,         identify highly correlated features to speed up
          the subsequential search.
          The \xmlNode{RFE} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{RFE} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{nFeaturesToSelect}: \xmlDesc{integer}, 
              Exact Number of features to select. If not inputted, ``nFeaturesToSelect'' will be set
              to $1/2$ of the features in the training dataset.
  \default{None}

            \item \xmlNode{maxNumberFeatures}: \xmlDesc{integer}, 
              Maximum Number of features to select, the algorithm will automatically determine the
              feature list to minimize a total score.
  \default{None}

            \item \xmlNode{onlyOutputScore}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              If maxNumberFeatures is on, only output score should beconsidered? Or, in case of
              particular models (e.g. DMDC), state variable space score should be considered as
              well.
  \default{False}

            \item \xmlNode{applyClusteringFiltering}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              Applying clustering correlation before RFE search? If true, an hierarchal clustering
              is applied on the feature         space aimed to remove features that are correlated
              before the actual RFE search is performed. This approach can stabilize and
              accelerate the process in case of large feature spaces (e.g > 500 features).
  \default{False}

            \item \xmlNode{applyCrossCorrelation}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              In case of subgroupping, should a cross correleation analysis should be performed
              cross sub-groups?         If it is activated, a cross correleation analysis is used to
              additionally filter the features selected for each         sub-groupping search.
  \default{False}

            \item \xmlNode{step}: \xmlDesc{float}, 
              If greater than or equal to 1, then step corresponds to the (integer) number
              of features to remove at each iteration. If within (0.0, 1.0), then step
              corresponds to the percentage (rounded down) of features to remove at         each
              iteration.
  \default{1}

            \item \xmlNode{subGroup}: \xmlDesc{comma-separated strings, integers, and floats}, 
              Subgroup of output variables on which to perform the search. Multiple nodes of this
              type can be inputted. The RFE search will be then performed in each ``subgroup''
              separately and then the the union of the different feature sets are used for the final
              ROM.
          \end{itemize}

        \item \xmlNode{VarianceThreshold}:
          The \xmlString{VarianceThreshold} is a feature selector that removes     all low-variance
          features. This feature selection algorithm looks only at the features and not     the
          desired outputs. The variance threshold can be set by the user.
          The \xmlNode{VarianceThreshold} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{VarianceThreshold} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{threshold}: \xmlDesc{float}, 
              Features with a training-set variance lower than this threshold                   will
              be removed. The default is to keep all features with non-zero
              variance, i.e. remove the features that have the same value in all
              samples.
  \default{0.0}
          \end{itemize}
      \end{itemize}

    \item \xmlNode{featureSpaceTransformation}:
      Use dimensionality reduction technique to perform a trasformation of the training dataset
      into an uncorrelated one. The dimensionality of the problem will not be reduced but
      the data will be transformed in the transformed space. E.g if the number of features
      are 5, the method projects such features into a new uncorrelated space (still 5-dimensional).
      In case of time-dependent ROMs, all the samples are concatenated in a global 2D matrix
      (n\_samples*n\_timesteps,n\_features) before applying the transformation and then reconstructed
      back into the original shape (before fitting the model).

      The \xmlNode{featureSpaceTransformation} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{transformationMethod}: \xmlDesc{[PCA, KernelLinearPCA, KernelPolyPCA, KernelRbfPCA, KernelSigmoidPCA, KernelCosinePCA, ICA]}, 
          Transformation method to use. Eight options (5 Kernel PCAs) are available:
          \begin{itemize}                     \item \textit{PCA}, Principal Component Analysis;
          \item \textit{KernelLinearPCA}, Kernel (Linear) Principal component analysis;
          \item \textit{KernelPolyPCA}, Kernel (Poly) Principal component analysis;
          \item \textit{KernelRbfPCA}, Kernel(Rbf) Principal component analysis;
          \item \textit{KernelSigmoidPCA}, Kernel (Sigmoid) Principal component analysis;
          \item \textit{KernelCosinePCA}, Kernel (Cosine) Principal component analysis;
          \item \textit{ICA}, Independent component analysis;                    \end{itemize}
  \default{PCA}

        \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
          List of IDs of features/variables to include in the transformation process.
  \default{None}

        \item \xmlNode{whichSpace}: \xmlDesc{string}, 
          Which space to search? Target or Feature?
  \default{Feature}
      \end{itemize}

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{nu}: \xmlDesc{float}, 
      An upper bound on the fraction of margin errors and
      a lower bound of the fraction of support vectors. Should be in the interval $(0, 1]$.
  \default{0.5}

    \item \xmlNode{C}: \xmlDesc{float}, 
      Regularization parameter. The strength of the regularization is inversely
      proportional to C.                                                           Must be strictly
      positive. The penalty is a squared l2 penalty.
  \default{1.0}

    \item \xmlNode{kernel}: \xmlDesc{[linear, poly, rbf, sigmoid]}, 
      Specifies the kernel type to be used in the algorithm. It must be one of
      ``linear'', ``poly'', ``rbf'' or ``sigmoid''.
  \default{rbf}

    \item \xmlNode{degree}: \xmlDesc{integer}, 
      Degree of the polynomial kernel function ('poly').Ignored by all other kernels.
  \default{3}

    \item \xmlNode{gamma}: \xmlDesc{float}, 
      Kernel coefficient for ``poly'', ``rbf'' or ``sigmoid''. If not input, then it uses
      $1 / (n\_features * X.var())$ as value of gamma
  \default{scale}

    \item \xmlNode{coef0}: \xmlDesc{float}, 
      Independent term in kernel function
  \default{0.0}

    \item \xmlNode{tol}: \xmlDesc{float}, 
      Tolerance for stopping criterion
  \default{0.001}

    \item \xmlNode{cache\_size}: \xmlDesc{float}, 
      Size of the kernel cache (in MB)
  \default{200.0}

    \item \xmlNode{shrinking}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Whether to use the shrinking heuristic.
  \default{True}

    \item \xmlNode{max\_iter}: \xmlDesc{integer}, 
      Hard limit on iterations within solver.``-1'' for no limit
  \default{-1}
  \end{itemize}


\subsubsection{SVC}
  The \xmlNode{SVC} \textit{C-Support Vector Classification} is an epsilon-Support Vector
  Classification.                             The free parameters in this model are C and epsilon.
  The implementation is based on libsvm. The fit time scales at least
  quadratically with the number of samples and may be impractical                             beyond
  tens of thousands of samples. The multiclass support is handled according to a one-vs-one scheme.
  \zNormalizationPerformed{SVC}

  The \xmlNode{SVC} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{SVC} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.
  \default{time}

    \item \xmlNode{featureSelection}:
      Apply feature selection algorithm

      The \xmlNode{featureSelection} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{RFE}:
          The \xmlString{RFE} (Recursive Feature Elimination) is a feature selection algorithm.
          Feature selection refers to techniques that select a subset of the most relevant features
          for a model (ROM).         Fewer features can allow ROMs to run more efficiently (less
          space or time complexity) and be more effective.         Indeed, some ROMs (machine
          learning algorithms) can be misled by irrelevant input features, resulting in worse
          predictive performance.         RFE is a wrapper-type feature selection algorithm. This
          means that a different ROM is given and used in the core of the         method,         is
          wrapped by RFE, and used to help select features.         \\RFE works by searching for a
          subset of features by starting with all features in the training dataset and successfully
          removing         features until the desired number remains.         This is achieved by
          fitting the given ROME used in the core of the model, ranking features by importance,
          discarding the least important features, and re-fitting the model. This process is
          repeated until a specified number of         features remains.         When the full model
          is created, a measure of variable importance is computed that ranks the predictors from
          most         important to least.         At each stage of the search, the least important
          predictors are iteratively eliminated prior to rebuilding the model.         Features are
          scored either using the ROM model (if the model provides a mean to compute feature
          importances) or by         using a statistical method.         \\In RAVEN the
          \xmlString{RFE} class refers to an augmentation of the basic algorithm, since it allows,
          optionally,         to perform the search on multiple groups of targets (separately) and
          then combine the results of the search in a         single set. In addition, when the RFE
          search is concluded, the user can request to identify the set of features         that
          bring to a minimization of the score (i.e. maximimization of the accuracy).         In
          addition, using the ``applyClusteringFiltering'' option, the algorithm can, using an
          hierarchal clustering algorithm,         identify highly correlated features to speed up
          the subsequential search.
          The \xmlNode{RFE} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{RFE} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{nFeaturesToSelect}: \xmlDesc{integer}, 
              Exact Number of features to select. If not inputted, ``nFeaturesToSelect'' will be set
              to $1/2$ of the features in the training dataset.
  \default{None}

            \item \xmlNode{maxNumberFeatures}: \xmlDesc{integer}, 
              Maximum Number of features to select, the algorithm will automatically determine the
              feature list to minimize a total score.
  \default{None}

            \item \xmlNode{onlyOutputScore}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              If maxNumberFeatures is on, only output score should beconsidered? Or, in case of
              particular models (e.g. DMDC), state variable space score should be considered as
              well.
  \default{False}

            \item \xmlNode{applyClusteringFiltering}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              Applying clustering correlation before RFE search? If true, an hierarchal clustering
              is applied on the feature         space aimed to remove features that are correlated
              before the actual RFE search is performed. This approach can stabilize and
              accelerate the process in case of large feature spaces (e.g > 500 features).
  \default{False}

            \item \xmlNode{applyCrossCorrelation}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              In case of subgroupping, should a cross correleation analysis should be performed
              cross sub-groups?         If it is activated, a cross correleation analysis is used to
              additionally filter the features selected for each         sub-groupping search.
  \default{False}

            \item \xmlNode{step}: \xmlDesc{float}, 
              If greater than or equal to 1, then step corresponds to the (integer) number
              of features to remove at each iteration. If within (0.0, 1.0), then step
              corresponds to the percentage (rounded down) of features to remove at         each
              iteration.
  \default{1}

            \item \xmlNode{subGroup}: \xmlDesc{comma-separated strings, integers, and floats}, 
              Subgroup of output variables on which to perform the search. Multiple nodes of this
              type can be inputted. The RFE search will be then performed in each ``subgroup''
              separately and then the the union of the different feature sets are used for the final
              ROM.
          \end{itemize}

        \item \xmlNode{VarianceThreshold}:
          The \xmlString{VarianceThreshold} is a feature selector that removes     all low-variance
          features. This feature selection algorithm looks only at the features and not     the
          desired outputs. The variance threshold can be set by the user.
          The \xmlNode{VarianceThreshold} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{VarianceThreshold} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{threshold}: \xmlDesc{float}, 
              Features with a training-set variance lower than this threshold                   will
              be removed. The default is to keep all features with non-zero
              variance, i.e. remove the features that have the same value in all
              samples.
  \default{0.0}
          \end{itemize}
      \end{itemize}

    \item \xmlNode{featureSpaceTransformation}:
      Use dimensionality reduction technique to perform a trasformation of the training dataset
      into an uncorrelated one. The dimensionality of the problem will not be reduced but
      the data will be transformed in the transformed space. E.g if the number of features
      are 5, the method projects such features into a new uncorrelated space (still 5-dimensional).
      In case of time-dependent ROMs, all the samples are concatenated in a global 2D matrix
      (n\_samples*n\_timesteps,n\_features) before applying the transformation and then reconstructed
      back into the original shape (before fitting the model).

      The \xmlNode{featureSpaceTransformation} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{transformationMethod}: \xmlDesc{[PCA, KernelLinearPCA, KernelPolyPCA, KernelRbfPCA, KernelSigmoidPCA, KernelCosinePCA, ICA]}, 
          Transformation method to use. Eight options (5 Kernel PCAs) are available:
          \begin{itemize}                     \item \textit{PCA}, Principal Component Analysis;
          \item \textit{KernelLinearPCA}, Kernel (Linear) Principal component analysis;
          \item \textit{KernelPolyPCA}, Kernel (Poly) Principal component analysis;
          \item \textit{KernelRbfPCA}, Kernel(Rbf) Principal component analysis;
          \item \textit{KernelSigmoidPCA}, Kernel (Sigmoid) Principal component analysis;
          \item \textit{KernelCosinePCA}, Kernel (Cosine) Principal component analysis;
          \item \textit{ICA}, Independent component analysis;                    \end{itemize}
  \default{PCA}

        \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
          List of IDs of features/variables to include in the transformation process.
  \default{None}

        \item \xmlNode{whichSpace}: \xmlDesc{string}, 
          Which space to search? Target or Feature?
  \default{Feature}
      \end{itemize}

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{C}: \xmlDesc{float}, 
      Regularization parameter. The strength of the regularization is inversely
      proportional to C.                                                            Must be strictly
      positive. The penalty is a squared l2 penalty..
  \default{1.0}

    \item \xmlNode{kernel}: \xmlDesc{[linear, poly, rbf, sigmoid]}, 
      Specifies the kernel type to be used in the algorithm. It must be one of
      ``linear'', ``poly'', ``rbf'' or ``sigmoid''.
  \default{rbf}

    \item \xmlNode{degree}: \xmlDesc{integer}, 
      Degree of the polynomial kernel function ('poly').Ignored by all other kernels.
  \default{3}

    \item \xmlNode{gamma}: \xmlDesc{float}, 
      Kernel coefficient for ``poly'', ``rbf'' or ``sigmoid''. If not input, then it uses
      $1 / (n\_features * X.var())$ as value of gamma
  \default{scale}

    \item \xmlNode{coef0}: \xmlDesc{float}, 
      Independent term in kernel function
  \default{0.0}

    \item \xmlNode{tol}: \xmlDesc{float}, 
      Tolerance for stopping criterion
  \default{0.001}

    \item \xmlNode{cache\_size}: \xmlDesc{float}, 
      Size of the kernel cache (in MB)
  \default{200.0}

    \item \xmlNode{shrinking}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Whether to use the shrinking heuristic.
  \default{True}

    \item \xmlNode{max\_iter}: \xmlDesc{integer}, 
      Hard limit on iterations within solver.``-1'' for no limit
  \default{-1}

    \item \xmlNode{decision\_function\_shape}: \xmlDesc{[ovo, ovr]}, 
      Whether to return a one-vs-rest (``ovr'') decision function of shape $(n\_samples, n\_classes)$
      as                                                            all other classifiers, or the
      original one-vs-one (``ovo'') decision function of libsvm which has
      shape $(n\_samples, n\_classes * (n\_classes - 1) / 2)$. However, one-vs-one (``ovo'') is always
      used as                                                            multi-class strategy. The
      parameter is ignored for binary classification.
  \default{ovr}

    \item \xmlNode{verbose}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Enable verbose output. Note that this setting takes advantage
      of a per-process runtime setting in libsvm that, if enabled, may not
      work properly in a multithreaded context.
  \default{False}

    \item \xmlNode{probability}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Whether to enable probability estimates.
  \default{False}

    \item \xmlNode{class\_weight}: \xmlDesc{[balanced]}, 
      If not given, all classes are supposed to have weight one.
      The “balanced” mode uses the values of y to automatically adjust weights
      inversely proportional to class frequencies in the input data
  \default{None}

    \item \xmlNode{random\_state}: \xmlDesc{integer}, 
      Controls the pseudo random number generation for shuffling
      the data for probability estimates. Ignored when probability is False.
      Pass an int for reproducible output across multiple function calls.
  \default{None}
  \end{itemize}


\subsubsection{SVR}
  The \xmlNode{SVR} \textit{Support Vector Regression} is an epsilon-Support Vector Regression.
  The free parameters in this model are C and epsilon. The implementations is a based on libsvm.
  The implementation is based on libsvm. The fit time complexity                             is more
  than quadratic with the number of samples which makes it hard                             to scale
  to datasets with more than a couple of 10000 samples.
  \zNormalizationPerformed{SVR}

  The \xmlNode{SVR} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{SVR} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.
  \default{time}

    \item \xmlNode{featureSelection}:
      Apply feature selection algorithm

      The \xmlNode{featureSelection} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{RFE}:
          The \xmlString{RFE} (Recursive Feature Elimination) is a feature selection algorithm.
          Feature selection refers to techniques that select a subset of the most relevant features
          for a model (ROM).         Fewer features can allow ROMs to run more efficiently (less
          space or time complexity) and be more effective.         Indeed, some ROMs (machine
          learning algorithms) can be misled by irrelevant input features, resulting in worse
          predictive performance.         RFE is a wrapper-type feature selection algorithm. This
          means that a different ROM is given and used in the core of the         method,         is
          wrapped by RFE, and used to help select features.         \\RFE works by searching for a
          subset of features by starting with all features in the training dataset and successfully
          removing         features until the desired number remains.         This is achieved by
          fitting the given ROME used in the core of the model, ranking features by importance,
          discarding the least important features, and re-fitting the model. This process is
          repeated until a specified number of         features remains.         When the full model
          is created, a measure of variable importance is computed that ranks the predictors from
          most         important to least.         At each stage of the search, the least important
          predictors are iteratively eliminated prior to rebuilding the model.         Features are
          scored either using the ROM model (if the model provides a mean to compute feature
          importances) or by         using a statistical method.         \\In RAVEN the
          \xmlString{RFE} class refers to an augmentation of the basic algorithm, since it allows,
          optionally,         to perform the search on multiple groups of targets (separately) and
          then combine the results of the search in a         single set. In addition, when the RFE
          search is concluded, the user can request to identify the set of features         that
          bring to a minimization of the score (i.e. maximimization of the accuracy).         In
          addition, using the ``applyClusteringFiltering'' option, the algorithm can, using an
          hierarchal clustering algorithm,         identify highly correlated features to speed up
          the subsequential search.
          The \xmlNode{RFE} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{RFE} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{nFeaturesToSelect}: \xmlDesc{integer}, 
              Exact Number of features to select. If not inputted, ``nFeaturesToSelect'' will be set
              to $1/2$ of the features in the training dataset.
  \default{None}

            \item \xmlNode{maxNumberFeatures}: \xmlDesc{integer}, 
              Maximum Number of features to select, the algorithm will automatically determine the
              feature list to minimize a total score.
  \default{None}

            \item \xmlNode{onlyOutputScore}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              If maxNumberFeatures is on, only output score should beconsidered? Or, in case of
              particular models (e.g. DMDC), state variable space score should be considered as
              well.
  \default{False}

            \item \xmlNode{applyClusteringFiltering}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              Applying clustering correlation before RFE search? If true, an hierarchal clustering
              is applied on the feature         space aimed to remove features that are correlated
              before the actual RFE search is performed. This approach can stabilize and
              accelerate the process in case of large feature spaces (e.g > 500 features).
  \default{False}

            \item \xmlNode{applyCrossCorrelation}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              In case of subgroupping, should a cross correleation analysis should be performed
              cross sub-groups?         If it is activated, a cross correleation analysis is used to
              additionally filter the features selected for each         sub-groupping search.
  \default{False}

            \item \xmlNode{step}: \xmlDesc{float}, 
              If greater than or equal to 1, then step corresponds to the (integer) number
              of features to remove at each iteration. If within (0.0, 1.0), then step
              corresponds to the percentage (rounded down) of features to remove at         each
              iteration.
  \default{1}

            \item \xmlNode{subGroup}: \xmlDesc{comma-separated strings, integers, and floats}, 
              Subgroup of output variables on which to perform the search. Multiple nodes of this
              type can be inputted. The RFE search will be then performed in each ``subgroup''
              separately and then the the union of the different feature sets are used for the final
              ROM.
          \end{itemize}

        \item \xmlNode{VarianceThreshold}:
          The \xmlString{VarianceThreshold} is a feature selector that removes     all low-variance
          features. This feature selection algorithm looks only at the features and not     the
          desired outputs. The variance threshold can be set by the user.
          The \xmlNode{VarianceThreshold} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{VarianceThreshold} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{threshold}: \xmlDesc{float}, 
              Features with a training-set variance lower than this threshold                   will
              be removed. The default is to keep all features with non-zero
              variance, i.e. remove the features that have the same value in all
              samples.
  \default{0.0}
          \end{itemize}
      \end{itemize}

    \item \xmlNode{featureSpaceTransformation}:
      Use dimensionality reduction technique to perform a trasformation of the training dataset
      into an uncorrelated one. The dimensionality of the problem will not be reduced but
      the data will be transformed in the transformed space. E.g if the number of features
      are 5, the method projects such features into a new uncorrelated space (still 5-dimensional).
      In case of time-dependent ROMs, all the samples are concatenated in a global 2D matrix
      (n\_samples*n\_timesteps,n\_features) before applying the transformation and then reconstructed
      back into the original shape (before fitting the model).

      The \xmlNode{featureSpaceTransformation} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{transformationMethod}: \xmlDesc{[PCA, KernelLinearPCA, KernelPolyPCA, KernelRbfPCA, KernelSigmoidPCA, KernelCosinePCA, ICA]}, 
          Transformation method to use. Eight options (5 Kernel PCAs) are available:
          \begin{itemize}                     \item \textit{PCA}, Principal Component Analysis;
          \item \textit{KernelLinearPCA}, Kernel (Linear) Principal component analysis;
          \item \textit{KernelPolyPCA}, Kernel (Poly) Principal component analysis;
          \item \textit{KernelRbfPCA}, Kernel(Rbf) Principal component analysis;
          \item \textit{KernelSigmoidPCA}, Kernel (Sigmoid) Principal component analysis;
          \item \textit{KernelCosinePCA}, Kernel (Cosine) Principal component analysis;
          \item \textit{ICA}, Independent component analysis;                    \end{itemize}
  \default{PCA}

        \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
          List of IDs of features/variables to include in the transformation process.
  \default{None}

        \item \xmlNode{whichSpace}: \xmlDesc{string}, 
          Which space to search? Target or Feature?
  \default{Feature}
      \end{itemize}

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{C}: \xmlDesc{float}, 
      Regularization parameter. The strength of the regularization is inversely
      proportional to C.                                                            Must be strictly
      positive. The penalty is a squared l2 penalty..
  \default{1.0}

    \item \xmlNode{kernel}: \xmlDesc{[linear, poly, rbf, sigmoid]}, 
      Specifies the kernel type to be used in the algorithm. It must be one of
      ``linear'', ``poly'', ``rbf'' or ``sigmoid''.
  \default{rbf}

    \item \xmlNode{degree}: \xmlDesc{integer}, 
      Degree of the polynomial kernel function ('poly').Ignored by all other kernels.
  \default{3}

    \item \xmlNode{gamma}: \xmlDesc{float}, 
      Kernel coefficient for ``poly'', ``rbf'' or ``sigmoid''. If not input, then it uses
      $1 / (n\_features * X.var())$ as value of gamma
  \default{scale}

    \item \xmlNode{coef0}: \xmlDesc{float}, 
      Independent term in kernel function
  \default{0.0}

    \item \xmlNode{tol}: \xmlDesc{float}, 
      Tolerance for stopping criterion
  \default{0.001}

    \item \xmlNode{cache\_size}: \xmlDesc{float}, 
      Size of the kernel cache (in MB)
  \default{200.0}

    \item \xmlNode{epsilon}: \xmlDesc{float}, 
      Epsilon in the epsilon-SVR model. It specifies the epsilon-tube
      within which no penalty is associated in the training loss function
      with points predicted within a distance epsilon from the actual
      value.
  \default{0.1}

    \item \xmlNode{shrinking}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Whether to use the shrinking heuristic.
  \default{True}

    \item \xmlNode{max\_iter}: \xmlDesc{integer}, 
      Hard limit on iterations within solver.``-1'' for no limit
  \default{-1}

    \item \xmlNode{verbose}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Enable verbose output. Note that this setting takes advantage
      of a per-process runtime setting in libsvm that, if enabled, may not
      work properly in a multithreaded context.
  \default{False}
  \end{itemize}


\subsubsection{DecisionTreeClassifier}
  The \xmlNode{DecisionTreeClassifier} is a classifier that is based on the
  decision tree logic.                          \zNormalizationPerformed{DecisionTreeClassifier}

  The \xmlNode{DecisionTreeClassifier} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{DecisionTreeClassifier} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.
  \default{time}

    \item \xmlNode{featureSelection}:
      Apply feature selection algorithm

      The \xmlNode{featureSelection} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{RFE}:
          The \xmlString{RFE} (Recursive Feature Elimination) is a feature selection algorithm.
          Feature selection refers to techniques that select a subset of the most relevant features
          for a model (ROM).         Fewer features can allow ROMs to run more efficiently (less
          space or time complexity) and be more effective.         Indeed, some ROMs (machine
          learning algorithms) can be misled by irrelevant input features, resulting in worse
          predictive performance.         RFE is a wrapper-type feature selection algorithm. This
          means that a different ROM is given and used in the core of the         method,         is
          wrapped by RFE, and used to help select features.         \\RFE works by searching for a
          subset of features by starting with all features in the training dataset and successfully
          removing         features until the desired number remains.         This is achieved by
          fitting the given ROME used in the core of the model, ranking features by importance,
          discarding the least important features, and re-fitting the model. This process is
          repeated until a specified number of         features remains.         When the full model
          is created, a measure of variable importance is computed that ranks the predictors from
          most         important to least.         At each stage of the search, the least important
          predictors are iteratively eliminated prior to rebuilding the model.         Features are
          scored either using the ROM model (if the model provides a mean to compute feature
          importances) or by         using a statistical method.         \\In RAVEN the
          \xmlString{RFE} class refers to an augmentation of the basic algorithm, since it allows,
          optionally,         to perform the search on multiple groups of targets (separately) and
          then combine the results of the search in a         single set. In addition, when the RFE
          search is concluded, the user can request to identify the set of features         that
          bring to a minimization of the score (i.e. maximimization of the accuracy).         In
          addition, using the ``applyClusteringFiltering'' option, the algorithm can, using an
          hierarchal clustering algorithm,         identify highly correlated features to speed up
          the subsequential search.
          The \xmlNode{RFE} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{RFE} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{nFeaturesToSelect}: \xmlDesc{integer}, 
              Exact Number of features to select. If not inputted, ``nFeaturesToSelect'' will be set
              to $1/2$ of the features in the training dataset.
  \default{None}

            \item \xmlNode{maxNumberFeatures}: \xmlDesc{integer}, 
              Maximum Number of features to select, the algorithm will automatically determine the
              feature list to minimize a total score.
  \default{None}

            \item \xmlNode{onlyOutputScore}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              If maxNumberFeatures is on, only output score should beconsidered? Or, in case of
              particular models (e.g. DMDC), state variable space score should be considered as
              well.
  \default{False}

            \item \xmlNode{applyClusteringFiltering}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              Applying clustering correlation before RFE search? If true, an hierarchal clustering
              is applied on the feature         space aimed to remove features that are correlated
              before the actual RFE search is performed. This approach can stabilize and
              accelerate the process in case of large feature spaces (e.g > 500 features).
  \default{False}

            \item \xmlNode{applyCrossCorrelation}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              In case of subgroupping, should a cross correleation analysis should be performed
              cross sub-groups?         If it is activated, a cross correleation analysis is used to
              additionally filter the features selected for each         sub-groupping search.
  \default{False}

            \item \xmlNode{step}: \xmlDesc{float}, 
              If greater than or equal to 1, then step corresponds to the (integer) number
              of features to remove at each iteration. If within (0.0, 1.0), then step
              corresponds to the percentage (rounded down) of features to remove at         each
              iteration.
  \default{1}

            \item \xmlNode{subGroup}: \xmlDesc{comma-separated strings, integers, and floats}, 
              Subgroup of output variables on which to perform the search. Multiple nodes of this
              type can be inputted. The RFE search will be then performed in each ``subgroup''
              separately and then the the union of the different feature sets are used for the final
              ROM.
          \end{itemize}

        \item \xmlNode{VarianceThreshold}:
          The \xmlString{VarianceThreshold} is a feature selector that removes     all low-variance
          features. This feature selection algorithm looks only at the features and not     the
          desired outputs. The variance threshold can be set by the user.
          The \xmlNode{VarianceThreshold} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{VarianceThreshold} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{threshold}: \xmlDesc{float}, 
              Features with a training-set variance lower than this threshold                   will
              be removed. The default is to keep all features with non-zero
              variance, i.e. remove the features that have the same value in all
              samples.
  \default{0.0}
          \end{itemize}
      \end{itemize}

    \item \xmlNode{featureSpaceTransformation}:
      Use dimensionality reduction technique to perform a trasformation of the training dataset
      into an uncorrelated one. The dimensionality of the problem will not be reduced but
      the data will be transformed in the transformed space. E.g if the number of features
      are 5, the method projects such features into a new uncorrelated space (still 5-dimensional).
      In case of time-dependent ROMs, all the samples are concatenated in a global 2D matrix
      (n\_samples*n\_timesteps,n\_features) before applying the transformation and then reconstructed
      back into the original shape (before fitting the model).

      The \xmlNode{featureSpaceTransformation} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{transformationMethod}: \xmlDesc{[PCA, KernelLinearPCA, KernelPolyPCA, KernelRbfPCA, KernelSigmoidPCA, KernelCosinePCA, ICA]}, 
          Transformation method to use. Eight options (5 Kernel PCAs) are available:
          \begin{itemize}                     \item \textit{PCA}, Principal Component Analysis;
          \item \textit{KernelLinearPCA}, Kernel (Linear) Principal component analysis;
          \item \textit{KernelPolyPCA}, Kernel (Poly) Principal component analysis;
          \item \textit{KernelRbfPCA}, Kernel(Rbf) Principal component analysis;
          \item \textit{KernelSigmoidPCA}, Kernel (Sigmoid) Principal component analysis;
          \item \textit{KernelCosinePCA}, Kernel (Cosine) Principal component analysis;
          \item \textit{ICA}, Independent component analysis;                    \end{itemize}
  \default{PCA}

        \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
          List of IDs of features/variables to include in the transformation process.
  \default{None}

        \item \xmlNode{whichSpace}: \xmlDesc{string}, 
          Which space to search? Target or Feature?
  \default{Feature}
      \end{itemize}

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{criterion}: \xmlDesc{[gini, entropy]}, 
      The function to measure the quality of a split. Supported criteria are ``gini'' for the
      Gini impurity and ``entropy'' for the information gain.
  \default{gini}

    \item \xmlNode{splitter}: \xmlDesc{[best, random]}, 
      The strategy used to choose the split at each node. Supported strategies are ``best''
      to choose the best split and ``random'' to choose the best random split.
  \default{best}

    \item \xmlNode{max\_depth}: \xmlDesc{integer}, 
      The maximum depth of the tree. If None, then nodes are expanded until all leaves are pure
      or until all leaves contain less than min\_samples\_split samples.
  \default{None}

    \item \xmlNode{min\_samples\_split}: \xmlDesc{integer}, 
      The minimum number of samples required to split an internal node
  \default{2}

    \item \xmlNode{min\_samples\_leaf}: \xmlDesc{integer}, 
      The minimum number of samples required to be at a leaf node. A split point at any
      depth will only be considered if it leaves at least min\_samples\_leaf training samples in
      each                                                  of the left and right branches. This may
      have the effect of smoothing the model, especially
      in regression.
  \default{1}

    \item \xmlNode{min\_weight\_fraction\_leaf}: \xmlDesc{float}, 
      The minimum weighted fraction of the sum total of weights (of all the input samples)
      required to be at a leaf node. Samples have equal weight when sample\_weight is not provided.
  \default{0.0}

    \item \xmlNode{max\_features}: \xmlDesc{[auto, sqrt, log2]}, 
      The strategy to compute the number of features to consider when looking for the best split:
      \begin{itemize}                                                     \item sqrt:
      $max\_features=sqrt(n\_features)$                                                     \item
      log2: $max\_features=log2(n\_features)$
      \item auto: automatic selection
      \end{itemize}                                                   \nb the search for a split
      does not stop until at least one valid partition of the node
      samples is found, even if it requires to effectively inspect more than max\_features features.
  \default{None}

    \item \xmlNode{max\_leaf\_nodes}: \xmlDesc{integer}, 
      Grow a tree with max\_leaf\_nodes in best-first fashion. Best nodes are defined as relative
      reduction                                                  in impurity. If None then unlimited
      number of leaf nodes.
  \default{None}

    \item \xmlNode{min\_impurity\_decrease}: \xmlDesc{float}, 
      A node will be split if this split induces a decrease of the impurity greater than or equal to
      this value.                                                  The weighted impurity decrease
      equation is the following:                                                  $N\_t / N *
      (impurity - N\_t\_R / N\_t * right\_impurity - N\_t\_L / N\_t * left\_impurity)$
      where $N$ is the total number of samples, $N\_t$ is the number of samples at the current node,
      $N\_t\_L$ is the number                                                  of samples in the
      left child, and $N\_t\_R$ is the number of samples in the right child.
      $N$, $N\_t$, $N\_t]\_R$ and $N\_t\_L$ all refer to the weighted sum, if sample\_weight is
      passed.
  \default{0.0}

    \item \xmlNode{random\_state}: \xmlDesc{integer}, 
      Controls the randomness of the estimator. The features are
      always randomly permuted at each split, even if splitter is set to
      "best". When max\_features < n\_features, the algorithm will select
      max\_features at random at each split before finding the best split
      among them. But the best found split may vary across different runs,
      even if max\_features=n\_features. That is the case, if the improvement
      of the criterion is identical for several splits and one split has to
      be selected at random. To obtain a deterministic behaviour during
      fitting, random\_state has to be fixed to an integer.
  \default{None}
  \end{itemize}


\subsubsection{DecisionTreeRegressor}
  The \xmlNode{DecisionTreeRegressor} is a regressor that is based on the
  decision tree logic.                          \zNormalizationPerformed{DecisionTreeRegressor}

  The \xmlNode{DecisionTreeRegressor} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{DecisionTreeRegressor} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.
  \default{time}

    \item \xmlNode{featureSelection}:
      Apply feature selection algorithm

      The \xmlNode{featureSelection} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{RFE}:
          The \xmlString{RFE} (Recursive Feature Elimination) is a feature selection algorithm.
          Feature selection refers to techniques that select a subset of the most relevant features
          for a model (ROM).         Fewer features can allow ROMs to run more efficiently (less
          space or time complexity) and be more effective.         Indeed, some ROMs (machine
          learning algorithms) can be misled by irrelevant input features, resulting in worse
          predictive performance.         RFE is a wrapper-type feature selection algorithm. This
          means that a different ROM is given and used in the core of the         method,         is
          wrapped by RFE, and used to help select features.         \\RFE works by searching for a
          subset of features by starting with all features in the training dataset and successfully
          removing         features until the desired number remains.         This is achieved by
          fitting the given ROME used in the core of the model, ranking features by importance,
          discarding the least important features, and re-fitting the model. This process is
          repeated until a specified number of         features remains.         When the full model
          is created, a measure of variable importance is computed that ranks the predictors from
          most         important to least.         At each stage of the search, the least important
          predictors are iteratively eliminated prior to rebuilding the model.         Features are
          scored either using the ROM model (if the model provides a mean to compute feature
          importances) or by         using a statistical method.         \\In RAVEN the
          \xmlString{RFE} class refers to an augmentation of the basic algorithm, since it allows,
          optionally,         to perform the search on multiple groups of targets (separately) and
          then combine the results of the search in a         single set. In addition, when the RFE
          search is concluded, the user can request to identify the set of features         that
          bring to a minimization of the score (i.e. maximimization of the accuracy).         In
          addition, using the ``applyClusteringFiltering'' option, the algorithm can, using an
          hierarchal clustering algorithm,         identify highly correlated features to speed up
          the subsequential search.
          The \xmlNode{RFE} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{RFE} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{nFeaturesToSelect}: \xmlDesc{integer}, 
              Exact Number of features to select. If not inputted, ``nFeaturesToSelect'' will be set
              to $1/2$ of the features in the training dataset.
  \default{None}

            \item \xmlNode{maxNumberFeatures}: \xmlDesc{integer}, 
              Maximum Number of features to select, the algorithm will automatically determine the
              feature list to minimize a total score.
  \default{None}

            \item \xmlNode{onlyOutputScore}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              If maxNumberFeatures is on, only output score should beconsidered? Or, in case of
              particular models (e.g. DMDC), state variable space score should be considered as
              well.
  \default{False}

            \item \xmlNode{applyClusteringFiltering}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              Applying clustering correlation before RFE search? If true, an hierarchal clustering
              is applied on the feature         space aimed to remove features that are correlated
              before the actual RFE search is performed. This approach can stabilize and
              accelerate the process in case of large feature spaces (e.g > 500 features).
  \default{False}

            \item \xmlNode{applyCrossCorrelation}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              In case of subgroupping, should a cross correleation analysis should be performed
              cross sub-groups?         If it is activated, a cross correleation analysis is used to
              additionally filter the features selected for each         sub-groupping search.
  \default{False}

            \item \xmlNode{step}: \xmlDesc{float}, 
              If greater than or equal to 1, then step corresponds to the (integer) number
              of features to remove at each iteration. If within (0.0, 1.0), then step
              corresponds to the percentage (rounded down) of features to remove at         each
              iteration.
  \default{1}

            \item \xmlNode{subGroup}: \xmlDesc{comma-separated strings, integers, and floats}, 
              Subgroup of output variables on which to perform the search. Multiple nodes of this
              type can be inputted. The RFE search will be then performed in each ``subgroup''
              separately and then the the union of the different feature sets are used for the final
              ROM.
          \end{itemize}

        \item \xmlNode{VarianceThreshold}:
          The \xmlString{VarianceThreshold} is a feature selector that removes     all low-variance
          features. This feature selection algorithm looks only at the features and not     the
          desired outputs. The variance threshold can be set by the user.
          The \xmlNode{VarianceThreshold} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{VarianceThreshold} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{threshold}: \xmlDesc{float}, 
              Features with a training-set variance lower than this threshold                   will
              be removed. The default is to keep all features with non-zero
              variance, i.e. remove the features that have the same value in all
              samples.
  \default{0.0}
          \end{itemize}
      \end{itemize}

    \item \xmlNode{featureSpaceTransformation}:
      Use dimensionality reduction technique to perform a trasformation of the training dataset
      into an uncorrelated one. The dimensionality of the problem will not be reduced but
      the data will be transformed in the transformed space. E.g if the number of features
      are 5, the method projects such features into a new uncorrelated space (still 5-dimensional).
      In case of time-dependent ROMs, all the samples are concatenated in a global 2D matrix
      (n\_samples*n\_timesteps,n\_features) before applying the transformation and then reconstructed
      back into the original shape (before fitting the model).

      The \xmlNode{featureSpaceTransformation} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{transformationMethod}: \xmlDesc{[PCA, KernelLinearPCA, KernelPolyPCA, KernelRbfPCA, KernelSigmoidPCA, KernelCosinePCA, ICA]}, 
          Transformation method to use. Eight options (5 Kernel PCAs) are available:
          \begin{itemize}                     \item \textit{PCA}, Principal Component Analysis;
          \item \textit{KernelLinearPCA}, Kernel (Linear) Principal component analysis;
          \item \textit{KernelPolyPCA}, Kernel (Poly) Principal component analysis;
          \item \textit{KernelRbfPCA}, Kernel(Rbf) Principal component analysis;
          \item \textit{KernelSigmoidPCA}, Kernel (Sigmoid) Principal component analysis;
          \item \textit{KernelCosinePCA}, Kernel (Cosine) Principal component analysis;
          \item \textit{ICA}, Independent component analysis;                    \end{itemize}
  \default{PCA}

        \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
          List of IDs of features/variables to include in the transformation process.
  \default{None}

        \item \xmlNode{whichSpace}: \xmlDesc{string}, 
          Which space to search? Target or Feature?
  \default{Feature}
      \end{itemize}

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{criterion}: \xmlDesc{[mse, friedman\_mse, mae, poisson]}, 
      The function to measure the quality of a split. Supported criteria are ``mse'' for the mean
      squared error,                                                  which is equal to variance
      reduction as feature selection criterion and minimizes the L2 loss using the mean of each
      terminal node, ``friedman\_mse'', which uses mean squared error with Friedman's improvement
      score for potential splits,                                                  ``mae'' for the
      mean absolute error, which minimizes the L1 loss using the median of each terminal node, and
      ``poisson''                                                  which uses reduction in Poisson
      deviance to find splits.
  \default{mse}

    \item \xmlNode{splitter}: \xmlDesc{[best, random]}, 
      The strategy used to choose the split at each node. Supported strategies are ``best''
      to choose the best split and ``random'' to choose the best random split.
  \default{best}

    \item \xmlNode{max\_depth}: \xmlDesc{integer}, 
      The maximum depth of the tree. If None, then nodes are expanded until all leaves are pure
      or until all leaves contain less than min\_samples\_split samples.
  \default{None}

    \item \xmlNode{min\_samples\_split}: \xmlDesc{integer}, 
      The minimum number of samples required to split an internal node
  \default{2}

    \item \xmlNode{min\_samples\_leaf}: \xmlDesc{integer}, 
      The minimum number of samples required to be at a leaf node. A split point at any
      depth will only be considered if it leaves at least min\_samples\_leaf training samples in
      each                                                  of the left and right branches. This may
      have the effect of smoothing the model, especially
      in regression.
  \default{1}

    \item \xmlNode{min\_weight\_fraction\_leaf}: \xmlDesc{float}, 
      The minimum weighted fraction of the sum total of weights (of all the input samples)
      required to be at a leaf node. Samples have equal weight when sample\_weight is not provided.
  \default{0.0}

    \item \xmlNode{max\_features}: \xmlDesc{[auto, sqrt, log2]}, 
      The strategy to compute the number of features to consider when looking for the best split:
      \begin{itemize}                                                     \item sqrt:
      $max\_features=sqrt(n\_features)$                                                     \item
      log2: $max\_features=log2(n\_features)$
      \item None: $max\_features=n\_features$
      \item auto: automatic selection
      \end{itemize}                                                   \nb the search for a split
      does not stop until at least one valid partition of the node
      samples is found, even if it requires to effectively inspect more than max\_features features.
  \default{None}

    \item \xmlNode{max\_leaf\_nodes}: \xmlDesc{integer}, 
      Grow a tree with max\_leaf\_nodes in best-first fashion. Best nodes are defined as relative
      reduction                                                  in impurity. If None then unlimited
      number of leaf nodes.
  \default{None}

    \item \xmlNode{min\_impurity\_decrease}: \xmlDesc{float}, 
      A node will be split if this split induces a decrease of the impurity greater than or equal to
      this value.                                                  The weighted impurity decrease
      equation is the following:                                                  $N\_t / N *
      (impurity - N\_t\_R / N\_t * right\_impurity - N\_t\_L / N\_t * left\_impurity)$
      where $N$ is the total number of samples, $N\_t$ is the number of samples at the current node,
      $N\_t\_L$ is the number                                                  of samples in the
      left child, and $N\_t\_R$ is the number of samples in the right child.
      $N$, $N\_t$, $N\_t]\_R$ and $N\_t\_L$ all refer to the weighted sum, if sample\_weight is
      passed.
  \default{0.0}

    \item \xmlNode{random\_state}: \xmlDesc{integer}, 
      Controls the randomness of the estimator. The features are
      always randomly permuted at each split, even if splitter is set to
      "best". When max\_features < n\_features, the algorithm will select
      max\_features at random at each split before finding the best split
      among them. But the best found split may vary across different runs,
      even if max\_features=n\_features. That is the case, if the improvement
      of the criterion is identical for several splits and one split has to
      be selected at random. To obtain a deterministic behaviour during
      fitting, random\_state has to be fixed to an integer.
  \default{None}
  \end{itemize}


\subsubsection{ExtraTreeClassifier}
  The \xmlNode{ExtraTreeClassifier} is an ``extremely randomized tree classifier''.
  Extra-trees differ from classic decision trees in the way they are built. When looking for the
  best                          split to separate the samples of a node into two groups, random
  splits are drawn for each of the                          max\_features randomly selected features
  and the best split among those is chosen. When max\_features                          is set 1,
  this amounts to building a totally random decision tree.
  \zNormalizationPerformed{ExtraTreeClassifier}

  The \xmlNode{ExtraTreeClassifier} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{ExtraTreeClassifier} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.
  \default{time}

    \item \xmlNode{featureSelection}:
      Apply feature selection algorithm

      The \xmlNode{featureSelection} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{RFE}:
          The \xmlString{RFE} (Recursive Feature Elimination) is a feature selection algorithm.
          Feature selection refers to techniques that select a subset of the most relevant features
          for a model (ROM).         Fewer features can allow ROMs to run more efficiently (less
          space or time complexity) and be more effective.         Indeed, some ROMs (machine
          learning algorithms) can be misled by irrelevant input features, resulting in worse
          predictive performance.         RFE is a wrapper-type feature selection algorithm. This
          means that a different ROM is given and used in the core of the         method,         is
          wrapped by RFE, and used to help select features.         \\RFE works by searching for a
          subset of features by starting with all features in the training dataset and successfully
          removing         features until the desired number remains.         This is achieved by
          fitting the given ROME used in the core of the model, ranking features by importance,
          discarding the least important features, and re-fitting the model. This process is
          repeated until a specified number of         features remains.         When the full model
          is created, a measure of variable importance is computed that ranks the predictors from
          most         important to least.         At each stage of the search, the least important
          predictors are iteratively eliminated prior to rebuilding the model.         Features are
          scored either using the ROM model (if the model provides a mean to compute feature
          importances) or by         using a statistical method.         \\In RAVEN the
          \xmlString{RFE} class refers to an augmentation of the basic algorithm, since it allows,
          optionally,         to perform the search on multiple groups of targets (separately) and
          then combine the results of the search in a         single set. In addition, when the RFE
          search is concluded, the user can request to identify the set of features         that
          bring to a minimization of the score (i.e. maximimization of the accuracy).         In
          addition, using the ``applyClusteringFiltering'' option, the algorithm can, using an
          hierarchal clustering algorithm,         identify highly correlated features to speed up
          the subsequential search.
          The \xmlNode{RFE} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{RFE} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{nFeaturesToSelect}: \xmlDesc{integer}, 
              Exact Number of features to select. If not inputted, ``nFeaturesToSelect'' will be set
              to $1/2$ of the features in the training dataset.
  \default{None}

            \item \xmlNode{maxNumberFeatures}: \xmlDesc{integer}, 
              Maximum Number of features to select, the algorithm will automatically determine the
              feature list to minimize a total score.
  \default{None}

            \item \xmlNode{onlyOutputScore}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              If maxNumberFeatures is on, only output score should beconsidered? Or, in case of
              particular models (e.g. DMDC), state variable space score should be considered as
              well.
  \default{False}

            \item \xmlNode{applyClusteringFiltering}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              Applying clustering correlation before RFE search? If true, an hierarchal clustering
              is applied on the feature         space aimed to remove features that are correlated
              before the actual RFE search is performed. This approach can stabilize and
              accelerate the process in case of large feature spaces (e.g > 500 features).
  \default{False}

            \item \xmlNode{applyCrossCorrelation}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              In case of subgroupping, should a cross correleation analysis should be performed
              cross sub-groups?         If it is activated, a cross correleation analysis is used to
              additionally filter the features selected for each         sub-groupping search.
  \default{False}

            \item \xmlNode{step}: \xmlDesc{float}, 
              If greater than or equal to 1, then step corresponds to the (integer) number
              of features to remove at each iteration. If within (0.0, 1.0), then step
              corresponds to the percentage (rounded down) of features to remove at         each
              iteration.
  \default{1}

            \item \xmlNode{subGroup}: \xmlDesc{comma-separated strings, integers, and floats}, 
              Subgroup of output variables on which to perform the search. Multiple nodes of this
              type can be inputted. The RFE search will be then performed in each ``subgroup''
              separately and then the the union of the different feature sets are used for the final
              ROM.
          \end{itemize}

        \item \xmlNode{VarianceThreshold}:
          The \xmlString{VarianceThreshold} is a feature selector that removes     all low-variance
          features. This feature selection algorithm looks only at the features and not     the
          desired outputs. The variance threshold can be set by the user.
          The \xmlNode{VarianceThreshold} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{VarianceThreshold} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{threshold}: \xmlDesc{float}, 
              Features with a training-set variance lower than this threshold                   will
              be removed. The default is to keep all features with non-zero
              variance, i.e. remove the features that have the same value in all
              samples.
  \default{0.0}
          \end{itemize}
      \end{itemize}

    \item \xmlNode{featureSpaceTransformation}:
      Use dimensionality reduction technique to perform a trasformation of the training dataset
      into an uncorrelated one. The dimensionality of the problem will not be reduced but
      the data will be transformed in the transformed space. E.g if the number of features
      are 5, the method projects such features into a new uncorrelated space (still 5-dimensional).
      In case of time-dependent ROMs, all the samples are concatenated in a global 2D matrix
      (n\_samples*n\_timesteps,n\_features) before applying the transformation and then reconstructed
      back into the original shape (before fitting the model).

      The \xmlNode{featureSpaceTransformation} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{transformationMethod}: \xmlDesc{[PCA, KernelLinearPCA, KernelPolyPCA, KernelRbfPCA, KernelSigmoidPCA, KernelCosinePCA, ICA]}, 
          Transformation method to use. Eight options (5 Kernel PCAs) are available:
          \begin{itemize}                     \item \textit{PCA}, Principal Component Analysis;
          \item \textit{KernelLinearPCA}, Kernel (Linear) Principal component analysis;
          \item \textit{KernelPolyPCA}, Kernel (Poly) Principal component analysis;
          \item \textit{KernelRbfPCA}, Kernel(Rbf) Principal component analysis;
          \item \textit{KernelSigmoidPCA}, Kernel (Sigmoid) Principal component analysis;
          \item \textit{KernelCosinePCA}, Kernel (Cosine) Principal component analysis;
          \item \textit{ICA}, Independent component analysis;                    \end{itemize}
  \default{PCA}

        \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
          List of IDs of features/variables to include in the transformation process.
  \default{None}

        \item \xmlNode{whichSpace}: \xmlDesc{string}, 
          Which space to search? Target or Feature?
  \default{Feature}
      \end{itemize}

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{criterion}: \xmlDesc{[gini, entropy]}, 
      The function to measure the quality of a split. Supported criteria are ``gini'' for the
      Gini impurity and ``entropy'' for the information gain.
  \default{gini}

    \item \xmlNode{splitter}: \xmlDesc{[best, random]}, 
      The strategy used to choose the split at each node. Supported strategies are ``best''
      to choose the best split and ``random'' to choose the best random split.
  \default{best}

    \item \xmlNode{max\_depth}: \xmlDesc{integer}, 
      The maximum depth of the tree. If None, then nodes are expanded until all leaves are pure
      or until all leaves contain less than min\_samples\_split samples.
  \default{None}

    \item \xmlNode{min\_samples\_split}: \xmlDesc{integer}, 
      The minimum number of samples required to split an internal node
  \default{2}

    \item \xmlNode{min\_samples\_leaf}: \xmlDesc{integer}, 
      The minimum number of samples required to be at a leaf node. A split point at any
      depth will only be considered if it leaves at least min\_samples\_leaf training samples in
      each                                                  of the left and right branches. This may
      have the effect of smoothing the model, especially
      in regression.
  \default{1}

    \item \xmlNode{min\_weight\_fraction\_leaf}: \xmlDesc{float}, 
      The minimum weighted fraction of the sum total of weights (of all the input samples)
      required to be at a leaf node. Samples have equal weight when sample\_weight is not provided.
  \default{0.0}

    \item \xmlNode{max\_features}: \xmlDesc{[auto, sqrt, log2]}, 
      The strategy to compute the number of features to consider when looking for the best split:
      \begin{itemize}                                                     \item sqrt:
      $max\_features=sqrt(n\_features)$                                                     \item
      log2: $max\_features=log2(n\_features)$
      \item None: $max\_features=n\_features$
      \item auto: automatic selection
      \end{itemize}                                                   \nb the search for a split
      does not stop until at least one valid partition of the node
      samples is found, even if it requires to effectively inspect more than max\_features features.
  \default{None}

    \item \xmlNode{max\_leaf\_nodes}: \xmlDesc{integer}, 
      Grow a tree with max\_leaf\_nodes in best-first fashion. Best nodes are defined as relative
      reduction                                                  in impurity. If None then unlimited
      number of leaf nodes.
  \default{None}

    \item \xmlNode{min\_impurity\_decrease}: \xmlDesc{float}, 
      A node will be split if this split induces a decrease of the impurity greater than or equal to
      this value.                                                  The weighted impurity decrease
      equation is the following:                                                  $N\_t / N *
      (impurity - N\_t\_R / N\_t * right\_impurity - N\_t\_L / N\_t * left\_impurity)$
      where $N$ is the total number of samples, $N\_t$ is the number of samples at the current node,
      $N\_t\_L$ is the number                                                  of samples in the
      left child, and $N\_t\_R$ is the number of samples in the right child.
      $N$, $N\_t$, $N\_t]\_R$ and $N\_t\_L$ all refer to the weighted sum, if sample\_weight is
      passed.
  \default{0.0}

    \item \xmlNode{random\_state}: \xmlDesc{integer}, 
      Used to pick randomly the max\_features used at each split.
  \default{None}
  \end{itemize}


\subsubsection{ExtraTreeRegressor}
  The \xmlNode{ExtraTreeRegressor} is extremely randomized tree regressor.
  Extra-trees differ from classic decision trees in the way they are built. When
  looking for the best split to separate the samples of a node into two groups,
  random splits are drawn for each of the max\_features randomly selected features
  and the best split among those is chosen. When max\_features is set 1, this amounts
  to building a totally random decision tree.
  \zNormalizationPerformed{ExtraTreeRegressor}

  The \xmlNode{ExtraTreeRegressor} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{ExtraTreeRegressor} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.
  \default{time}

    \item \xmlNode{featureSelection}:
      Apply feature selection algorithm

      The \xmlNode{featureSelection} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{RFE}:
          The \xmlString{RFE} (Recursive Feature Elimination) is a feature selection algorithm.
          Feature selection refers to techniques that select a subset of the most relevant features
          for a model (ROM).         Fewer features can allow ROMs to run more efficiently (less
          space or time complexity) and be more effective.         Indeed, some ROMs (machine
          learning algorithms) can be misled by irrelevant input features, resulting in worse
          predictive performance.         RFE is a wrapper-type feature selection algorithm. This
          means that a different ROM is given and used in the core of the         method,         is
          wrapped by RFE, and used to help select features.         \\RFE works by searching for a
          subset of features by starting with all features in the training dataset and successfully
          removing         features until the desired number remains.         This is achieved by
          fitting the given ROME used in the core of the model, ranking features by importance,
          discarding the least important features, and re-fitting the model. This process is
          repeated until a specified number of         features remains.         When the full model
          is created, a measure of variable importance is computed that ranks the predictors from
          most         important to least.         At each stage of the search, the least important
          predictors are iteratively eliminated prior to rebuilding the model.         Features are
          scored either using the ROM model (if the model provides a mean to compute feature
          importances) or by         using a statistical method.         \\In RAVEN the
          \xmlString{RFE} class refers to an augmentation of the basic algorithm, since it allows,
          optionally,         to perform the search on multiple groups of targets (separately) and
          then combine the results of the search in a         single set. In addition, when the RFE
          search is concluded, the user can request to identify the set of features         that
          bring to a minimization of the score (i.e. maximimization of the accuracy).         In
          addition, using the ``applyClusteringFiltering'' option, the algorithm can, using an
          hierarchal clustering algorithm,         identify highly correlated features to speed up
          the subsequential search.
          The \xmlNode{RFE} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{RFE} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{nFeaturesToSelect}: \xmlDesc{integer}, 
              Exact Number of features to select. If not inputted, ``nFeaturesToSelect'' will be set
              to $1/2$ of the features in the training dataset.
  \default{None}

            \item \xmlNode{maxNumberFeatures}: \xmlDesc{integer}, 
              Maximum Number of features to select, the algorithm will automatically determine the
              feature list to minimize a total score.
  \default{None}

            \item \xmlNode{onlyOutputScore}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              If maxNumberFeatures is on, only output score should beconsidered? Or, in case of
              particular models (e.g. DMDC), state variable space score should be considered as
              well.
  \default{False}

            \item \xmlNode{applyClusteringFiltering}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              Applying clustering correlation before RFE search? If true, an hierarchal clustering
              is applied on the feature         space aimed to remove features that are correlated
              before the actual RFE search is performed. This approach can stabilize and
              accelerate the process in case of large feature spaces (e.g > 500 features).
  \default{False}

            \item \xmlNode{applyCrossCorrelation}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              In case of subgroupping, should a cross correleation analysis should be performed
              cross sub-groups?         If it is activated, a cross correleation analysis is used to
              additionally filter the features selected for each         sub-groupping search.
  \default{False}

            \item \xmlNode{step}: \xmlDesc{float}, 
              If greater than or equal to 1, then step corresponds to the (integer) number
              of features to remove at each iteration. If within (0.0, 1.0), then step
              corresponds to the percentage (rounded down) of features to remove at         each
              iteration.
  \default{1}

            \item \xmlNode{subGroup}: \xmlDesc{comma-separated strings, integers, and floats}, 
              Subgroup of output variables on which to perform the search. Multiple nodes of this
              type can be inputted. The RFE search will be then performed in each ``subgroup''
              separately and then the the union of the different feature sets are used for the final
              ROM.
          \end{itemize}

        \item \xmlNode{VarianceThreshold}:
          The \xmlString{VarianceThreshold} is a feature selector that removes     all low-variance
          features. This feature selection algorithm looks only at the features and not     the
          desired outputs. The variance threshold can be set by the user.
          The \xmlNode{VarianceThreshold} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{VarianceThreshold} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{threshold}: \xmlDesc{float}, 
              Features with a training-set variance lower than this threshold                   will
              be removed. The default is to keep all features with non-zero
              variance, i.e. remove the features that have the same value in all
              samples.
  \default{0.0}
          \end{itemize}
      \end{itemize}

    \item \xmlNode{featureSpaceTransformation}:
      Use dimensionality reduction technique to perform a trasformation of the training dataset
      into an uncorrelated one. The dimensionality of the problem will not be reduced but
      the data will be transformed in the transformed space. E.g if the number of features
      are 5, the method projects such features into a new uncorrelated space (still 5-dimensional).
      In case of time-dependent ROMs, all the samples are concatenated in a global 2D matrix
      (n\_samples*n\_timesteps,n\_features) before applying the transformation and then reconstructed
      back into the original shape (before fitting the model).

      The \xmlNode{featureSpaceTransformation} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{transformationMethod}: \xmlDesc{[PCA, KernelLinearPCA, KernelPolyPCA, KernelRbfPCA, KernelSigmoidPCA, KernelCosinePCA, ICA]}, 
          Transformation method to use. Eight options (5 Kernel PCAs) are available:
          \begin{itemize}                     \item \textit{PCA}, Principal Component Analysis;
          \item \textit{KernelLinearPCA}, Kernel (Linear) Principal component analysis;
          \item \textit{KernelPolyPCA}, Kernel (Poly) Principal component analysis;
          \item \textit{KernelRbfPCA}, Kernel(Rbf) Principal component analysis;
          \item \textit{KernelSigmoidPCA}, Kernel (Sigmoid) Principal component analysis;
          \item \textit{KernelCosinePCA}, Kernel (Cosine) Principal component analysis;
          \item \textit{ICA}, Independent component analysis;                    \end{itemize}
  \default{PCA}

        \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
          List of IDs of features/variables to include in the transformation process.
  \default{None}

        \item \xmlNode{whichSpace}: \xmlDesc{string}, 
          Which space to search? Target or Feature?
  \default{Feature}
      \end{itemize}

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{criterion}: \xmlDesc{[mse, friedman\_mse, mae]}, 
      The function to measure the quality of a split. Supported criteria are ``mse'' for the mean
      squared error,                                                  which is equal to variance
      reduction as feature selection criterion and minimizes the L2 loss using the mean of each
      terminal node, ``friedman\_mse'', which uses mean squared error with Friedman's improvement
      score for potential splits,                                                  ``mae'' for the
      mean absolute error, which minimizes the L1 loss using the median of each terminal node.
  \default{mse}

    \item \xmlNode{splitter}: \xmlDesc{[best, random]}, 
      The strategy used to choose the split at each node. Supported strategies are ``best''
      to choose the best split and ``random'' to choose the best random split.
  \default{best}

    \item \xmlNode{max\_depth}: \xmlDesc{integer}, 
      The maximum depth of the tree. If None, then nodes are expanded until all leaves are pure
      or until all leaves contain less than min\_samples\_split samples.
  \default{None}

    \item \xmlNode{min\_samples\_split}: \xmlDesc{integer}, 
      The minimum number of samples required to split an internal node
  \default{2}

    \item \xmlNode{min\_samples\_leaf}: \xmlDesc{integer}, 
      The minimum number of samples required to be at a leaf node. A split point at any
      depth will only be considered if it leaves at least min\_samples\_leaf training samples in
      each                                                  of the left and right branches. This may
      have the effect of smoothing the model, especially
      in regression.
  \default{1}

    \item \xmlNode{min\_weight\_fraction\_leaf}: \xmlDesc{float}, 
      The minimum weighted fraction of the sum total of weights (of all the input samples)
      required to be at a leaf node. Samples have equal weight when sample\_weight is not provided.
  \default{0.0}

    \item \xmlNode{max\_features}: \xmlDesc{[auto, sqrt, log2]}, 
      The strategy to compute the number of features to consider when looking for the best split:
      \begin{itemize}                                                     \item sqrt:
      $max\_features=sqrt(n\_features)$                                                     \item
      log2: $max\_features=log2(n\_features)$
      \item auto: automatic selection
      \end{itemize}                                                   \nb the search for a split
      does not stop until at least one valid partition of the node
      samples is found, even if it requires to effectively inspect more than max\_features features.
  \default{None}

    \item \xmlNode{max\_leaf\_nodes}: \xmlDesc{integer}, 
      Grow a tree with max\_leaf\_nodes in best-first fashion. Best nodes are defined as relative
      reduction                                                  in impurity. If None then unlimited
      number of leaf nodes.
  \default{None}

    \item \xmlNode{min\_impurity\_decrease}: \xmlDesc{float}, 
      A node will be split if this split induces a decrease of the impurity greater than or equal to
      this value.                                                  The weighted impurity decrease
      equation is the following:                                                  $N\_t / N *
      (impurity - N\_t\_R / N\_t * right\_impurity - N\_t\_L / N\_t * left\_impurity)$
      where $N$ is the total number of samples, $N\_t$ is the number of samples at the current node,
      $N\_t\_L$ is the number                                                  of samples in the
      left child, and $N\_t\_R$ is the number of samples in the right child.
      $N$, $N\_t$, $N\_t]\_R$ and $N\_t\_L$ all refer to the weighted sum, if sample\_weight is
      passed.
  \default{0.0}

    \item \xmlNode{ccp\_alpha}: \xmlDesc{float}, 
      Complexity parameter used for Minimal Cost-Complexity Pruning. The subtree with the largest
      cost                                                  complexity that is smaller than
      ccp\_alpha will be chosen. By default, no pruning is performed.
  \default{0.0}

    \item \xmlNode{random\_state}: \xmlDesc{integer}, 
      Used to pick randomly the max\_features used at each split.
  \default{None}
  \end{itemize}


\subsubsection{VotingRegressor}
  The \xmlNode{VotingRegressor} is an ensemble meta-estimator that fits several base
  regressors, each on the whole dataset. Then it averages the individual predictions to form
  a final prediction.

  The \xmlNode{VotingRegressor} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{VotingRegressor} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.
  \default{time}

    \item \xmlNode{featureSelection}:
      Apply feature selection algorithm

      The \xmlNode{featureSelection} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{RFE}:
          The \xmlString{RFE} (Recursive Feature Elimination) is a feature selection algorithm.
          Feature selection refers to techniques that select a subset of the most relevant features
          for a model (ROM).         Fewer features can allow ROMs to run more efficiently (less
          space or time complexity) and be more effective.         Indeed, some ROMs (machine
          learning algorithms) can be misled by irrelevant input features, resulting in worse
          predictive performance.         RFE is a wrapper-type feature selection algorithm. This
          means that a different ROM is given and used in the core of the         method,         is
          wrapped by RFE, and used to help select features.         \\RFE works by searching for a
          subset of features by starting with all features in the training dataset and successfully
          removing         features until the desired number remains.         This is achieved by
          fitting the given ROME used in the core of the model, ranking features by importance,
          discarding the least important features, and re-fitting the model. This process is
          repeated until a specified number of         features remains.         When the full model
          is created, a measure of variable importance is computed that ranks the predictors from
          most         important to least.         At each stage of the search, the least important
          predictors are iteratively eliminated prior to rebuilding the model.         Features are
          scored either using the ROM model (if the model provides a mean to compute feature
          importances) or by         using a statistical method.         \\In RAVEN the
          \xmlString{RFE} class refers to an augmentation of the basic algorithm, since it allows,
          optionally,         to perform the search on multiple groups of targets (separately) and
          then combine the results of the search in a         single set. In addition, when the RFE
          search is concluded, the user can request to identify the set of features         that
          bring to a minimization of the score (i.e. maximimization of the accuracy).         In
          addition, using the ``applyClusteringFiltering'' option, the algorithm can, using an
          hierarchal clustering algorithm,         identify highly correlated features to speed up
          the subsequential search.
          The \xmlNode{RFE} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{RFE} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{nFeaturesToSelect}: \xmlDesc{integer}, 
              Exact Number of features to select. If not inputted, ``nFeaturesToSelect'' will be set
              to $1/2$ of the features in the training dataset.
  \default{None}

            \item \xmlNode{maxNumberFeatures}: \xmlDesc{integer}, 
              Maximum Number of features to select, the algorithm will automatically determine the
              feature list to minimize a total score.
  \default{None}

            \item \xmlNode{onlyOutputScore}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              If maxNumberFeatures is on, only output score should beconsidered? Or, in case of
              particular models (e.g. DMDC), state variable space score should be considered as
              well.
  \default{False}

            \item \xmlNode{applyClusteringFiltering}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              Applying clustering correlation before RFE search? If true, an hierarchal clustering
              is applied on the feature         space aimed to remove features that are correlated
              before the actual RFE search is performed. This approach can stabilize and
              accelerate the process in case of large feature spaces (e.g > 500 features).
  \default{False}

            \item \xmlNode{applyCrossCorrelation}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              In case of subgroupping, should a cross correleation analysis should be performed
              cross sub-groups?         If it is activated, a cross correleation analysis is used to
              additionally filter the features selected for each         sub-groupping search.
  \default{False}

            \item \xmlNode{step}: \xmlDesc{float}, 
              If greater than or equal to 1, then step corresponds to the (integer) number
              of features to remove at each iteration. If within (0.0, 1.0), then step
              corresponds to the percentage (rounded down) of features to remove at         each
              iteration.
  \default{1}

            \item \xmlNode{subGroup}: \xmlDesc{comma-separated strings, integers, and floats}, 
              Subgroup of output variables on which to perform the search. Multiple nodes of this
              type can be inputted. The RFE search will be then performed in each ``subgroup''
              separately and then the the union of the different feature sets are used for the final
              ROM.
          \end{itemize}

        \item \xmlNode{VarianceThreshold}:
          The \xmlString{VarianceThreshold} is a feature selector that removes     all low-variance
          features. This feature selection algorithm looks only at the features and not     the
          desired outputs. The variance threshold can be set by the user.
          The \xmlNode{VarianceThreshold} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{VarianceThreshold} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{threshold}: \xmlDesc{float}, 
              Features with a training-set variance lower than this threshold                   will
              be removed. The default is to keep all features with non-zero
              variance, i.e. remove the features that have the same value in all
              samples.
  \default{0.0}
          \end{itemize}
      \end{itemize}

    \item \xmlNode{featureSpaceTransformation}:
      Use dimensionality reduction technique to perform a trasformation of the training dataset
      into an uncorrelated one. The dimensionality of the problem will not be reduced but
      the data will be transformed in the transformed space. E.g if the number of features
      are 5, the method projects such features into a new uncorrelated space (still 5-dimensional).
      In case of time-dependent ROMs, all the samples are concatenated in a global 2D matrix
      (n\_samples*n\_timesteps,n\_features) before applying the transformation and then reconstructed
      back into the original shape (before fitting the model).

      The \xmlNode{featureSpaceTransformation} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{transformationMethod}: \xmlDesc{[PCA, KernelLinearPCA, KernelPolyPCA, KernelRbfPCA, KernelSigmoidPCA, KernelCosinePCA, ICA]}, 
          Transformation method to use. Eight options (5 Kernel PCAs) are available:
          \begin{itemize}                     \item \textit{PCA}, Principal Component Analysis;
          \item \textit{KernelLinearPCA}, Kernel (Linear) Principal component analysis;
          \item \textit{KernelPolyPCA}, Kernel (Poly) Principal component analysis;
          \item \textit{KernelRbfPCA}, Kernel(Rbf) Principal component analysis;
          \item \textit{KernelSigmoidPCA}, Kernel (Sigmoid) Principal component analysis;
          \item \textit{KernelCosinePCA}, Kernel (Cosine) Principal component analysis;
          \item \textit{ICA}, Independent component analysis;                    \end{itemize}
  \default{PCA}

        \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
          List of IDs of features/variables to include in the transformation process.
  \default{None}

        \item \xmlNode{whichSpace}: \xmlDesc{string}, 
          Which space to search? Target or Feature?
  \default{Feature}
      \end{itemize}

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{estimator}: \xmlDesc{string}, 
      name of a ROM that can be used as an estimator
      The \xmlNode{estimator} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, required}, 
            RAVEN class for this entity (e.g. Samplers, Models, DataObjects)
          \item \xmlAttr{type}: \xmlDesc{string, required}, 
            RAVEN type for this entity; a subtype of the class (e.g. MonteCarlo, Code, PointSet)
      \end{itemize}

    \item \xmlNode{weights}: \xmlDesc{comma-separated floats}, 
      Sequence of weights (float or int) to weight the occurrences of predicted
      values before averaging. Uses uniform weights if None.
  \default{None}
  \end{itemize}


\subsubsection{BaggingRegressor}
  The \xmlNode{BaggingRegressor} is an ensemble meta-estimator that fits base regressors each on
  random subsets of the original                             dataset and then aggregate their
  individual predictions (either by voting or by averaging) to form a final
  prediction. Such a meta-estimator can typically be used as a way to reduce the variance of a
  black-box estimator                             (e.g., a decision tree), by introducing
  randomization into its construction procedure and then making an ensemble
  out of it.

  The \xmlNode{BaggingRegressor} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{BaggingRegressor} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.
  \default{time}

    \item \xmlNode{featureSelection}:
      Apply feature selection algorithm

      The \xmlNode{featureSelection} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{RFE}:
          The \xmlString{RFE} (Recursive Feature Elimination) is a feature selection algorithm.
          Feature selection refers to techniques that select a subset of the most relevant features
          for a model (ROM).         Fewer features can allow ROMs to run more efficiently (less
          space or time complexity) and be more effective.         Indeed, some ROMs (machine
          learning algorithms) can be misled by irrelevant input features, resulting in worse
          predictive performance.         RFE is a wrapper-type feature selection algorithm. This
          means that a different ROM is given and used in the core of the         method,         is
          wrapped by RFE, and used to help select features.         \\RFE works by searching for a
          subset of features by starting with all features in the training dataset and successfully
          removing         features until the desired number remains.         This is achieved by
          fitting the given ROME used in the core of the model, ranking features by importance,
          discarding the least important features, and re-fitting the model. This process is
          repeated until a specified number of         features remains.         When the full model
          is created, a measure of variable importance is computed that ranks the predictors from
          most         important to least.         At each stage of the search, the least important
          predictors are iteratively eliminated prior to rebuilding the model.         Features are
          scored either using the ROM model (if the model provides a mean to compute feature
          importances) or by         using a statistical method.         \\In RAVEN the
          \xmlString{RFE} class refers to an augmentation of the basic algorithm, since it allows,
          optionally,         to perform the search on multiple groups of targets (separately) and
          then combine the results of the search in a         single set. In addition, when the RFE
          search is concluded, the user can request to identify the set of features         that
          bring to a minimization of the score (i.e. maximimization of the accuracy).         In
          addition, using the ``applyClusteringFiltering'' option, the algorithm can, using an
          hierarchal clustering algorithm,         identify highly correlated features to speed up
          the subsequential search.
          The \xmlNode{RFE} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{RFE} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{nFeaturesToSelect}: \xmlDesc{integer}, 
              Exact Number of features to select. If not inputted, ``nFeaturesToSelect'' will be set
              to $1/2$ of the features in the training dataset.
  \default{None}

            \item \xmlNode{maxNumberFeatures}: \xmlDesc{integer}, 
              Maximum Number of features to select, the algorithm will automatically determine the
              feature list to minimize a total score.
  \default{None}

            \item \xmlNode{onlyOutputScore}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              If maxNumberFeatures is on, only output score should beconsidered? Or, in case of
              particular models (e.g. DMDC), state variable space score should be considered as
              well.
  \default{False}

            \item \xmlNode{applyClusteringFiltering}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              Applying clustering correlation before RFE search? If true, an hierarchal clustering
              is applied on the feature         space aimed to remove features that are correlated
              before the actual RFE search is performed. This approach can stabilize and
              accelerate the process in case of large feature spaces (e.g > 500 features).
  \default{False}

            \item \xmlNode{applyCrossCorrelation}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              In case of subgroupping, should a cross correleation analysis should be performed
              cross sub-groups?         If it is activated, a cross correleation analysis is used to
              additionally filter the features selected for each         sub-groupping search.
  \default{False}

            \item \xmlNode{step}: \xmlDesc{float}, 
              If greater than or equal to 1, then step corresponds to the (integer) number
              of features to remove at each iteration. If within (0.0, 1.0), then step
              corresponds to the percentage (rounded down) of features to remove at         each
              iteration.
  \default{1}

            \item \xmlNode{subGroup}: \xmlDesc{comma-separated strings, integers, and floats}, 
              Subgroup of output variables on which to perform the search. Multiple nodes of this
              type can be inputted. The RFE search will be then performed in each ``subgroup''
              separately and then the the union of the different feature sets are used for the final
              ROM.
          \end{itemize}

        \item \xmlNode{VarianceThreshold}:
          The \xmlString{VarianceThreshold} is a feature selector that removes     all low-variance
          features. This feature selection algorithm looks only at the features and not     the
          desired outputs. The variance threshold can be set by the user.
          The \xmlNode{VarianceThreshold} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{VarianceThreshold} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{threshold}: \xmlDesc{float}, 
              Features with a training-set variance lower than this threshold                   will
              be removed. The default is to keep all features with non-zero
              variance, i.e. remove the features that have the same value in all
              samples.
  \default{0.0}
          \end{itemize}
      \end{itemize}

    \item \xmlNode{featureSpaceTransformation}:
      Use dimensionality reduction technique to perform a trasformation of the training dataset
      into an uncorrelated one. The dimensionality of the problem will not be reduced but
      the data will be transformed in the transformed space. E.g if the number of features
      are 5, the method projects such features into a new uncorrelated space (still 5-dimensional).
      In case of time-dependent ROMs, all the samples are concatenated in a global 2D matrix
      (n\_samples*n\_timesteps,n\_features) before applying the transformation and then reconstructed
      back into the original shape (before fitting the model).

      The \xmlNode{featureSpaceTransformation} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{transformationMethod}: \xmlDesc{[PCA, KernelLinearPCA, KernelPolyPCA, KernelRbfPCA, KernelSigmoidPCA, KernelCosinePCA, ICA]}, 
          Transformation method to use. Eight options (5 Kernel PCAs) are available:
          \begin{itemize}                     \item \textit{PCA}, Principal Component Analysis;
          \item \textit{KernelLinearPCA}, Kernel (Linear) Principal component analysis;
          \item \textit{KernelPolyPCA}, Kernel (Poly) Principal component analysis;
          \item \textit{KernelRbfPCA}, Kernel(Rbf) Principal component analysis;
          \item \textit{KernelSigmoidPCA}, Kernel (Sigmoid) Principal component analysis;
          \item \textit{KernelCosinePCA}, Kernel (Cosine) Principal component analysis;
          \item \textit{ICA}, Independent component analysis;                    \end{itemize}
  \default{PCA}

        \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
          List of IDs of features/variables to include in the transformation process.
  \default{None}

        \item \xmlNode{whichSpace}: \xmlDesc{string}, 
          Which space to search? Target or Feature?
  \default{Feature}
      \end{itemize}

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{estimator}: \xmlDesc{string}, 
      name of a ROM that can be used as an estimator
      The \xmlNode{estimator} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, required}, 
            RAVEN class for this entity (e.g. Samplers, Models, DataObjects)
          \item \xmlAttr{type}: \xmlDesc{string, required}, 
            RAVEN type for this entity; a subtype of the class (e.g. MonteCarlo, Code, PointSet)
      \end{itemize}

    \item \xmlNode{n\_estimators}: \xmlDesc{integer}, 
      The number of base estimators in the ensemble.
  \default{10}

    \item \xmlNode{max\_samples}: \xmlDesc{float}, 
      The number of samples to draw from X to train each base estimator
  \default{1.0}

    \item \xmlNode{max\_features}: \xmlDesc{float}, 
      The number of features to draw from X to train each base estimator
  \default{1.0}

    \item \xmlNode{bootstrap}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Whether samples are drawn with replacement. If False, sampling without
      replacement is performed.
  \default{True}

    \item \xmlNode{bootstrap\_features}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Whether features are drawn with replacement.
  \default{False}

    \item \xmlNode{oob\_score}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      Whether to use out-of-bag samples to estimate the generalization error.
      Only available if bootstrap=True.
  \default{False}

    \item \xmlNode{warm\_start}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      When set to True, reuse the solution of the previous call to fit and add more
      estimators to the ensemble, otherwise, just fit a whole new ensemble.
  \default{False}

    \item \xmlNode{random\_state}: \xmlDesc{integer}, 
      Controls the random resampling of the original dataset (sample wise and feature wise).
  \default{None}
  \end{itemize}


\subsubsection{AdaBoostRegressor}
  The \xmlNode{AdaBoostRegressor} is a meta-estimator that begins by fitting a regressor on
  the original dataset and then fits additional copies of the regressor on the same dataset
  but where the weights of instances are adjusted according to the error of the current
  prediction. As such, subsequent regressors focus more on difficult cases.

  The \xmlNode{AdaBoostRegressor} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{AdaBoostRegressor} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.
  \default{time}

    \item \xmlNode{featureSelection}:
      Apply feature selection algorithm

      The \xmlNode{featureSelection} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{RFE}:
          The \xmlString{RFE} (Recursive Feature Elimination) is a feature selection algorithm.
          Feature selection refers to techniques that select a subset of the most relevant features
          for a model (ROM).         Fewer features can allow ROMs to run more efficiently (less
          space or time complexity) and be more effective.         Indeed, some ROMs (machine
          learning algorithms) can be misled by irrelevant input features, resulting in worse
          predictive performance.         RFE is a wrapper-type feature selection algorithm. This
          means that a different ROM is given and used in the core of the         method,         is
          wrapped by RFE, and used to help select features.         \\RFE works by searching for a
          subset of features by starting with all features in the training dataset and successfully
          removing         features until the desired number remains.         This is achieved by
          fitting the given ROME used in the core of the model, ranking features by importance,
          discarding the least important features, and re-fitting the model. This process is
          repeated until a specified number of         features remains.         When the full model
          is created, a measure of variable importance is computed that ranks the predictors from
          most         important to least.         At each stage of the search, the least important
          predictors are iteratively eliminated prior to rebuilding the model.         Features are
          scored either using the ROM model (if the model provides a mean to compute feature
          importances) or by         using a statistical method.         \\In RAVEN the
          \xmlString{RFE} class refers to an augmentation of the basic algorithm, since it allows,
          optionally,         to perform the search on multiple groups of targets (separately) and
          then combine the results of the search in a         single set. In addition, when the RFE
          search is concluded, the user can request to identify the set of features         that
          bring to a minimization of the score (i.e. maximimization of the accuracy).         In
          addition, using the ``applyClusteringFiltering'' option, the algorithm can, using an
          hierarchal clustering algorithm,         identify highly correlated features to speed up
          the subsequential search.
          The \xmlNode{RFE} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{RFE} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{nFeaturesToSelect}: \xmlDesc{integer}, 
              Exact Number of features to select. If not inputted, ``nFeaturesToSelect'' will be set
              to $1/2$ of the features in the training dataset.
  \default{None}

            \item \xmlNode{maxNumberFeatures}: \xmlDesc{integer}, 
              Maximum Number of features to select, the algorithm will automatically determine the
              feature list to minimize a total score.
  \default{None}

            \item \xmlNode{onlyOutputScore}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              If maxNumberFeatures is on, only output score should beconsidered? Or, in case of
              particular models (e.g. DMDC), state variable space score should be considered as
              well.
  \default{False}

            \item \xmlNode{applyClusteringFiltering}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              Applying clustering correlation before RFE search? If true, an hierarchal clustering
              is applied on the feature         space aimed to remove features that are correlated
              before the actual RFE search is performed. This approach can stabilize and
              accelerate the process in case of large feature spaces (e.g > 500 features).
  \default{False}

            \item \xmlNode{applyCrossCorrelation}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              In case of subgroupping, should a cross correleation analysis should be performed
              cross sub-groups?         If it is activated, a cross correleation analysis is used to
              additionally filter the features selected for each         sub-groupping search.
  \default{False}

            \item \xmlNode{step}: \xmlDesc{float}, 
              If greater than or equal to 1, then step corresponds to the (integer) number
              of features to remove at each iteration. If within (0.0, 1.0), then step
              corresponds to the percentage (rounded down) of features to remove at         each
              iteration.
  \default{1}

            \item \xmlNode{subGroup}: \xmlDesc{comma-separated strings, integers, and floats}, 
              Subgroup of output variables on which to perform the search. Multiple nodes of this
              type can be inputted. The RFE search will be then performed in each ``subgroup''
              separately and then the the union of the different feature sets are used for the final
              ROM.
          \end{itemize}

        \item \xmlNode{VarianceThreshold}:
          The \xmlString{VarianceThreshold} is a feature selector that removes     all low-variance
          features. This feature selection algorithm looks only at the features and not     the
          desired outputs. The variance threshold can be set by the user.
          The \xmlNode{VarianceThreshold} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{VarianceThreshold} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{threshold}: \xmlDesc{float}, 
              Features with a training-set variance lower than this threshold                   will
              be removed. The default is to keep all features with non-zero
              variance, i.e. remove the features that have the same value in all
              samples.
  \default{0.0}
          \end{itemize}
      \end{itemize}

    \item \xmlNode{featureSpaceTransformation}:
      Use dimensionality reduction technique to perform a trasformation of the training dataset
      into an uncorrelated one. The dimensionality of the problem will not be reduced but
      the data will be transformed in the transformed space. E.g if the number of features
      are 5, the method projects such features into a new uncorrelated space (still 5-dimensional).
      In case of time-dependent ROMs, all the samples are concatenated in a global 2D matrix
      (n\_samples*n\_timesteps,n\_features) before applying the transformation and then reconstructed
      back into the original shape (before fitting the model).

      The \xmlNode{featureSpaceTransformation} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{transformationMethod}: \xmlDesc{[PCA, KernelLinearPCA, KernelPolyPCA, KernelRbfPCA, KernelSigmoidPCA, KernelCosinePCA, ICA]}, 
          Transformation method to use. Eight options (5 Kernel PCAs) are available:
          \begin{itemize}                     \item \textit{PCA}, Principal Component Analysis;
          \item \textit{KernelLinearPCA}, Kernel (Linear) Principal component analysis;
          \item \textit{KernelPolyPCA}, Kernel (Poly) Principal component analysis;
          \item \textit{KernelRbfPCA}, Kernel(Rbf) Principal component analysis;
          \item \textit{KernelSigmoidPCA}, Kernel (Sigmoid) Principal component analysis;
          \item \textit{KernelCosinePCA}, Kernel (Cosine) Principal component analysis;
          \item \textit{ICA}, Independent component analysis;                    \end{itemize}
  \default{PCA}

        \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
          List of IDs of features/variables to include in the transformation process.
  \default{None}

        \item \xmlNode{whichSpace}: \xmlDesc{string}, 
          Which space to search? Target or Feature?
  \default{Feature}
      \end{itemize}

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{estimator}: \xmlDesc{string}, 
      name of a ROM that can be used as an estimator
      The \xmlNode{estimator} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, required}, 
            RAVEN class for this entity (e.g. Samplers, Models, DataObjects)
          \item \xmlAttr{type}: \xmlDesc{string, required}, 
            RAVEN type for this entity; a subtype of the class (e.g. MonteCarlo, Code, PointSet)
      \end{itemize}

    \item \xmlNode{n\_estimators}: \xmlDesc{integer}, 
      The maximum number of estimators at which boosting is
      terminated. In case of perfect fit, the learning procedure is
      stopped early.
  \default{50}

    \item \xmlNode{learning\_rate}: \xmlDesc{float}, 
      Weight applied to each regressor at each boosting iteration.
      A higher learning rate increases the contribution of each regressor.
      There is a trade-off between the learning\_rate and n\_estimators
      parameters.
  \default{1.0}

    \item \xmlNode{loss}: \xmlDesc{[linear, square, exponential]}, 
      The loss function to use when updating the weights after each
      boosting iteration.
  \default{linear}

    \item \xmlNode{random\_state}: \xmlDesc{integer}, 
      Controls the random seed given at each estimator at each
      boosting iteration.
  \default{None}
  \end{itemize}


\subsubsection{StackingRegressor}
  The \xmlNode{StackingRegressor} consists in stacking the output of individual estimator and
  use a regressor to compute the final prediction. Stacking allows to use the strength of each
  individual estimator by using their output as input of a final estimator.

  The \xmlNode{StackingRegressor} node recognizes the following parameters:
    \begin{itemize}
      \item \xmlAttr{name}: \xmlDesc{string, required}, 
        User-defined name to designate this entity in the RAVEN input file.
      \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
        Desired verbosity of messages coming from this entity
      \item \xmlAttr{subType}: \xmlDesc{string, required}, 
        specify the type of ROM that will be used
  \end{itemize}

  The \xmlNode{StackingRegressor} node recognizes the following subnodes:
  \begin{itemize}
    \item \xmlNode{Features}: \xmlDesc{comma-separated strings}, 
      specifies the names of the features of this ROM.         \nb These parameters are going to be
      requested for the training of this object         (see Section~\ref{subsec:stepRomTrainer})

    \item \xmlNode{Target}: \xmlDesc{comma-separated strings}, 
      contains a comma separated list of the targets of this ROM. These parameters         are the
      Figures of Merit (FOMs) this ROM is supposed to predict.         \nb These parameters are
      going to be requested for the training of this         object (see Section
      \ref{subsec:stepRomTrainer}).

    \item \xmlNode{pivotParameter}: \xmlDesc{string}, 
      If a time-dependent ROM is requested, please specifies the pivot         variable (e.g. time,
      etc) used in the input HistorySet.
  \default{time}

    \item \xmlNode{featureSelection}:
      Apply feature selection algorithm

      The \xmlNode{featureSelection} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{RFE}:
          The \xmlString{RFE} (Recursive Feature Elimination) is a feature selection algorithm.
          Feature selection refers to techniques that select a subset of the most relevant features
          for a model (ROM).         Fewer features can allow ROMs to run more efficiently (less
          space or time complexity) and be more effective.         Indeed, some ROMs (machine
          learning algorithms) can be misled by irrelevant input features, resulting in worse
          predictive performance.         RFE is a wrapper-type feature selection algorithm. This
          means that a different ROM is given and used in the core of the         method,         is
          wrapped by RFE, and used to help select features.         \\RFE works by searching for a
          subset of features by starting with all features in the training dataset and successfully
          removing         features until the desired number remains.         This is achieved by
          fitting the given ROME used in the core of the model, ranking features by importance,
          discarding the least important features, and re-fitting the model. This process is
          repeated until a specified number of         features remains.         When the full model
          is created, a measure of variable importance is computed that ranks the predictors from
          most         important to least.         At each stage of the search, the least important
          predictors are iteratively eliminated prior to rebuilding the model.         Features are
          scored either using the ROM model (if the model provides a mean to compute feature
          importances) or by         using a statistical method.         \\In RAVEN the
          \xmlString{RFE} class refers to an augmentation of the basic algorithm, since it allows,
          optionally,         to perform the search on multiple groups of targets (separately) and
          then combine the results of the search in a         single set. In addition, when the RFE
          search is concluded, the user can request to identify the set of features         that
          bring to a minimization of the score (i.e. maximimization of the accuracy).         In
          addition, using the ``applyClusteringFiltering'' option, the algorithm can, using an
          hierarchal clustering algorithm,         identify highly correlated features to speed up
          the subsequential search.
          The \xmlNode{RFE} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{RFE} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{nFeaturesToSelect}: \xmlDesc{integer}, 
              Exact Number of features to select. If not inputted, ``nFeaturesToSelect'' will be set
              to $1/2$ of the features in the training dataset.
  \default{None}

            \item \xmlNode{maxNumberFeatures}: \xmlDesc{integer}, 
              Maximum Number of features to select, the algorithm will automatically determine the
              feature list to minimize a total score.
  \default{None}

            \item \xmlNode{onlyOutputScore}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              If maxNumberFeatures is on, only output score should beconsidered? Or, in case of
              particular models (e.g. DMDC), state variable space score should be considered as
              well.
  \default{False}

            \item \xmlNode{applyClusteringFiltering}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              Applying clustering correlation before RFE search? If true, an hierarchal clustering
              is applied on the feature         space aimed to remove features that are correlated
              before the actual RFE search is performed. This approach can stabilize and
              accelerate the process in case of large feature spaces (e.g > 500 features).
  \default{False}

            \item \xmlNode{applyCrossCorrelation}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
              In case of subgroupping, should a cross correleation analysis should be performed
              cross sub-groups?         If it is activated, a cross correleation analysis is used to
              additionally filter the features selected for each         sub-groupping search.
  \default{False}

            \item \xmlNode{step}: \xmlDesc{float}, 
              If greater than or equal to 1, then step corresponds to the (integer) number
              of features to remove at each iteration. If within (0.0, 1.0), then step
              corresponds to the percentage (rounded down) of features to remove at         each
              iteration.
  \default{1}

            \item \xmlNode{subGroup}: \xmlDesc{comma-separated strings, integers, and floats}, 
              Subgroup of output variables on which to perform the search. Multiple nodes of this
              type can be inputted. The RFE search will be then performed in each ``subgroup''
              separately and then the the union of the different feature sets are used for the final
              ROM.
          \end{itemize}

        \item \xmlNode{VarianceThreshold}:
          The \xmlString{VarianceThreshold} is a feature selector that removes     all low-variance
          features. This feature selection algorithm looks only at the features and not     the
          desired outputs. The variance threshold can be set by the user.
          The \xmlNode{VarianceThreshold} node recognizes the following parameters:
            \begin{itemize}
              \item \xmlAttr{name}: \xmlDesc{string, required}, 
                User-defined name to designate this entity in the RAVEN input file.
              \item \xmlAttr{verbosity}: \xmlDesc{[silent, quiet, all, debug], optional}, 
                Desired verbosity of messages coming from this entity
          \end{itemize}

          The \xmlNode{VarianceThreshold} node recognizes the following subnodes:
          \begin{itemize}
            \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
              List of IDs of features/variables to include in the search.
  \default{None}

            \item \xmlNode{whichSpace}: \xmlDesc{[feature, target]}, 
              Which space to search? Target or Feature (this is temporary till DataSet training is
              implemented)
  \default{feature}

            \item \xmlNode{threshold}: \xmlDesc{float}, 
              Features with a training-set variance lower than this threshold                   will
              be removed. The default is to keep all features with non-zero
              variance, i.e. remove the features that have the same value in all
              samples.
  \default{0.0}
          \end{itemize}
      \end{itemize}

    \item \xmlNode{featureSpaceTransformation}:
      Use dimensionality reduction technique to perform a trasformation of the training dataset
      into an uncorrelated one. The dimensionality of the problem will not be reduced but
      the data will be transformed in the transformed space. E.g if the number of features
      are 5, the method projects such features into a new uncorrelated space (still 5-dimensional).
      In case of time-dependent ROMs, all the samples are concatenated in a global 2D matrix
      (n\_samples*n\_timesteps,n\_features) before applying the transformation and then reconstructed
      back into the original shape (before fitting the model).

      The \xmlNode{featureSpaceTransformation} node recognizes the following subnodes:
      \begin{itemize}
        \item \xmlNode{transformationMethod}: \xmlDesc{[PCA, KernelLinearPCA, KernelPolyPCA, KernelRbfPCA, KernelSigmoidPCA, KernelCosinePCA, ICA]}, 
          Transformation method to use. Eight options (5 Kernel PCAs) are available:
          \begin{itemize}                     \item \textit{PCA}, Principal Component Analysis;
          \item \textit{KernelLinearPCA}, Kernel (Linear) Principal component analysis;
          \item \textit{KernelPolyPCA}, Kernel (Poly) Principal component analysis;
          \item \textit{KernelRbfPCA}, Kernel(Rbf) Principal component analysis;
          \item \textit{KernelSigmoidPCA}, Kernel (Sigmoid) Principal component analysis;
          \item \textit{KernelCosinePCA}, Kernel (Cosine) Principal component analysis;
          \item \textit{ICA}, Independent component analysis;                    \end{itemize}
  \default{PCA}

        \item \xmlNode{parametersToInclude}: \xmlDesc{comma-separated strings}, 
          List of IDs of features/variables to include in the transformation process.
  \default{None}

        \item \xmlNode{whichSpace}: \xmlDesc{string}, 
          Which space to search? Target or Feature?
  \default{Feature}
      \end{itemize}

    \item \xmlNode{CV}: \xmlDesc{string}, 
      The text portion of this node needs to contain the name of the \xmlNode{PostProcessor} with
      \xmlAttr{subType}         ``CrossValidation``.
      The \xmlNode{CV} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, optional}, 
            should be set to \xmlString{Model}
          \item \xmlAttr{type}: \xmlDesc{string, optional}, 
            should be set to \xmlString{PostProcessor}
      \end{itemize}

    \item \xmlNode{alias}: \xmlDesc{string}, 
      specifies alias for         any variable of interest in the input or output space. These
      aliases can be used anywhere in the RAVEN input to         refer to the variables. In the body
      of this node the user specifies the name of the variable that the model is going to use
      (during its execution).
      The \xmlNode{alias} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{variable}: \xmlDesc{string, required}, 
            define the actual alias, usable throughout the RAVEN input
          \item \xmlAttr{type}: \xmlDesc{[input, output], required}, 
            either ``input'' or ``output''.
      \end{itemize}

    \item \xmlNode{estimator}: \xmlDesc{string}, 
      name of a ROM that can be used as an estimator
      The \xmlNode{estimator} node recognizes the following parameters:
        \begin{itemize}
          \item \xmlAttr{class}: \xmlDesc{string, required}, 
            RAVEN class for this entity (e.g. Samplers, Models, DataObjects)
          \item \xmlAttr{type}: \xmlDesc{string, required}, 
            RAVEN type for this entity; a subtype of the class (e.g. MonteCarlo, Code, PointSet)
      \end{itemize}

    \item \xmlNode{final\_estimator}: \xmlDesc{string}, 
      The name of estimator which will be used to combine the base estimators.

    \item \xmlNode{cv}: \xmlDesc{integer}, 
      specify the number of folds in a (Stratified) KFold,
  \default{5}

    \item \xmlNode{passthrough}: \xmlDesc{[True, Yes, 1, False, No, 0, t, y, 1, f, n, 0]}, 
      When False, only the predictions of estimators will be used as training
      data for final\_estimator. When True, the final\_estimator is trained on the predictions
      as well as the original training data.
  \default{False}
  \end{itemize}
