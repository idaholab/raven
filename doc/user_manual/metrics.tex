\section{Metrics}
\label{sec:Metrics}

The Metrics block allows the user to specify the similarity/dissimilarity metrics to be used in specific clustering algorithms available in RAVEN.
These metrics are used to calculate the distance values among points and histories.
The data mining algorithms in RAVEN which accept the definition of a metric are the following:
\begin{itemize}
  \item DBSCAN (see Section~\ref{subparagraph:DBSCAN})
  \item Affinity Propagation (see Section~\ref{subparagraph:Affinity})
  \item Metric post processor (See Secton \ref{MetricPP})
\end{itemize}

In the RAVEN input file these metrics are defined as follows:
\begin{lstlisting}[style=XML]
<Simulation>
  ...
  <Metrics>
    ...
    <MetricID name='metricName'>
      ...
     <param1>value</param1>
      ...
    </MetricID>
    ...
  </Metrics>
  ...
</Simulation>
\end{lstlisting}

\subsection{Dynamic Time Warping}
\label{subsection:DTW}
The Dynamic Time Warping (DTW) is a distance metrice that can be employed only for HistorySets (i.e., time dependent data).

The specifications of a DTW distance must be defined within the XML block.
\xmlNode{DTW}.

This XML node needs to contain the attributes:


\begin{itemize}
  \item \xmlNode{order},          \xmlDesc{int, required field},    order of the DTW calculation: $0$ specifices a classical DTW caluclation and $1$ specifies
                                                                    a derivative DTW calculation
  \item \xmlNode{pivotParameter}, \xmlDesc{string, optional field}, the ID of the temporal variable
  \item \xmlNode{localDistance},  \xmlDesc{string, optional field}, the ID of the distance function to be employed to determine the local distance
                                                                    evaluation of two time series. Available options are provided by the sklearn
                                                                    pairwise\_distances (cityblock, cosine, euclidean, $l1$, $l2$, manhattan,
                                                                    braycurtis, canberra, chebyshev, correlation, dice, hamming, jaccard,
                                                                    kulsinski, mahalanobis, matching, minkowski, rogerstanimoto, russellrao,
                                                                    seuclidean, sokalmichener, sokalsneath, sqeuclidean, yule)
\end{itemize}

An example of Minkowski distance defined in RAVEN is provided below:
\begin{lstlisting}[style=XML]
<Simulation>
  ...
  <Metrics>
    ...
    <DTW name="example" subType="">
      <order>0</order>
      <pivotParameter>time</pivotParameter>
      <localDistance>euclidean</localDistance>
    </DTW>
    ...
  </Metrics>
  ...
</Simulation>
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{SKL Metrics}
\label{subsection:SKL_metrics}

This Metric class interfaces directly with the metric distances available within scikit-learn.
Note that these distance metrics apply only to PointSets. However, note that this distance metrics can be applied to HistorySets after the HistorySets are converted into PointSets.
In this respect, the HSPS interfaced Post-Processor (see Section~\ref{Interfaced}) can be employed to perform such conversion.

The specifications of a SKL metric must be defined within the XML block \xmlNode{SKL}.
This XML node needs to contain the subnode:
\begin{itemize}
  \item \xmlNode{metricType}, \xmlDesc{vertical bar (\texttt{|}) separated string, required field}, the type of \textbf{SKL} metrics
    from the SciKit-Learn, i.e. \xmlString{paired\_distance|euclidean}.
\end{itemize}

Available metrics from SKL are:
\begin{itemize}
  \item   \textbf{paired\_distance} from scikit-learn paired\_distance kernels:
    \begin{itemize}
      \item \xmlString{paired\_distance|euclidean}: ${||u-v||}_2$
      \item \xmlString{paired\_distance|cosine}: $1 - \frac{u \cdot v}{||u||_2 ||v||_2}$ where $u \cdot v$ is the dot product of $u$ and $v$
      \item \xmlString{paired\_distance|manhattan}: $\sum_i {\left| u_i - v_i \right|}$
    \end{itemize}

  \item \textbf{regression} from scikit-learn regression metrics:
    \begin{itemize}
      \item \xmlString{regression|explained\_variance\_score}: $1.0 - \frac{Var[x-y]}{Var[x]}$
      \item \xmlString{regression|mean\_absolute\_error}: $\frac{1}{n_{samples}}\sum_{i=0}^{n_{samples}-1}|x_i-y_i|$
      \item \xmlString{regression|mean\_squared\_error}: $\frac{1}{n_{samples}}\sum_{i=0}^{n_{samples}-1}(x_i-y_i)^2$
      \item \xmlString{regression|r2\_score}: $1.0-\frac{\sum_{i=0}^{n_{samples}-1}(x_i-y_i)^2}{\sum_{i=0}^{n_{samples}-1}(x_i-mean[x])^2}$
    \end{itemize}
     
\end{itemize}

In the RAVEN input file these metrics are defined as follows:
\begin{lstlisting}[style=XML]
<Simulation>
  ...
  <Metrics>
    <SKL name="euclidean">
        <metricType>paired_distance|euclidean</metricType>
    </SKL>
    <SKL name="cosine">
        <metricType>paired_distance|cosine</metricType>
        <dense_output>True</dense_output>
    </SKL>
    <SKL name="manhattan">
        <metricType>paired_distance|manhattan</metricType>
        <sum_over_features>True</sum_over_features>
        <size_threshold>5e8</size_threshold>
    </SKL>
    <SKL name="explained_variance_score">
        <metricType>regression|explained_variance_score</metricType>
        <sample_weight>[0.1,0.1,0.1,0.05,0.05,0.2,0.1,0.1,0.1,0.1]</sample_weight>
    </SKL>
    <SKL name="mean_absolute_error">
        <metricType>regression|mean_absolute_error</metricType>
        <sample_weight>[0.1,0.1,0.1,0.05,0.05,0.2,0.1,0.1,0.1,0.1]</sample_weight>
    </SKL>
    <SKL name="r2_score">
        <metricType>regression|r2_score</metricType>
        <sample_weight>[0.1,0.1,0.1,0.05,0.05,0.2,0.1,0.1,0.1,0.1]</sample_weight>
    </SKL>
    <SKL name="mean_squared_error">
        <metricType>regression|mean_squared_error</metricType>
        <sample_weight>[0.1,0.1,0.1,0.05,0.05,0.2,0.1,0.1,0.1,0.1]</sample_weight>
    </SKL>
  </Metrics>
  ...
</Simulation>
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{ScipyMetric}
\label{subsection:ScipyMetric}
This Metric class interfaces directly with the metric distances available within Scipy.
Note that these distance metrics can apply only to PointSets. 
The specifications of a Scipy Metric must be defined within the XML block \xmlNode{ScipyMetric}.
This XML node needs to contain the subnode:
\begin{itemize}
  \item \xmlNode{metricType}, \xmlDesc{vertical bar (\texttt{|}) separated string, required field}, the type of \textbf{ScipyMetric} metrics
    from the Scipy, i.e. \xmlString{paired\_distance|minkowski}.
\end{itemize}
Available metrics from ScipyMetric are:
\begin{itemize}
  \item   \textbf{paired\_distance} from Scipy:
    \begin{itemize}
      \item \xmlString{paired\_distance|braycurtis}: $\sum{|u_i-v_i|} / \sum{|u_i+v_i|}$
      \item \xmlString{paired\_distance|canberra}: $ d(u,v) = \sum_i \frac{|u_i-v_i|}{|u_i|+|v_i|}$
      \item \xmlString{paired\_distance|chebyshev}: $\max_i {|u_i-v_i|}$
      \item \xmlString{paired\_distance|correlation}: $1 - \frac{(u - \bar{u}) \cdot (v - \bar{v})}{{||(u - \bar{u})||}_2 {||(v - \bar{v})||}_2}$
        where $\bar{u}$ is the mean of the elements of $u$
      \item \xmlString{paired\_distance|minkowski}: ${||u-v||}_p = (\sum{|u_i - v_i|^p})^{1/p}$
    \end{itemize}

  \item \textbf{boolean} from Scipy:
    \begin{itemize}
      \item \xmlString{boolean|dice}: $\frac{c_{TF} + c_{FT}}{2c_{TT} + c_{FT} + c_{TF}}$
        where $c_{ij}$ is the number of occurrences of $\mathtt{u[k]} = i$ and $\mathtt{v[k]} = j$ for $k < n$
      \item \xmlString{boolean|hamming}: $\frac{c_{01} + c_{10}}{n}$
        where $c_{ij}$ is the number of occurrences of $\mathtt{u[k]} = i$ and $\mathtt{v[k]} = j$ for $k < n$
      \item \xmlString{boolean|jaccard}: $\frac{c_{TF} + c_{FT}}{c_{TT} + c_{FT} + c_{TF}}$
        where $c_{ij}$ is the number of occurrences of $\mathtt{u[k]} = i$ and $\mathtt{v[k]} = j$ for $k < n$
      \item \xmlString{boolean|kulsinski}: $\frac{c_{TF} + c_{FT} - c_{TT} + n}{c_{FT} + c_{TF} + n}$
        where $c_{ij}$ is the number of occurrences of $\mathtt{u[k]} = i$ and $\mathtt{v[k]} = j$ for $k < n$
      \item \xmlString{boolean|rogerstanimoto}: $\frac{R}{c_{TT} + c_{FF} + R}$
        where $c_{ij}$ is the number of occurrences of $\mathtt{u[k]} = i$ and $\mathtt{v[k]} = j$
        for $k < n$ and $R = 2(c_{TF} + c_{FT})$
      \item \xmlString{boolean|russellrao}: $\frac{n - c_{TT}}{n}$
        where $c_{ij}$ is the number of occurrences of $\mathtt{u[k]} = i$ and $\mathtt{v[k]} = j$ for $k < n$
      \item \xmlString{boolean|sokalmichener}: $\frac{R}{S + R}$
        where $c_{ij}$ is the number of occurrences of $\mathtt{u[k]} = i$ and $\mathtt{v[k]} = j$ for
        $k < n$, $R = 2 * (c_{TF} + c_{FT})$ and $S = c_{FF} + c_{TT}$
      \item \xmlString{boolean|sokalsneath}: $\frac{R}{c_{TT} + R}$
        where $c_{ij}$ is the number of occurrences of $\mathtt{u[k]} = i$ and $\mathtt{v[k]} = j$
        for $k < n$ and $R = 2(c_{TF} + c_{FT})$
      \item \xmlString{boolean|yule}: $\frac{R}{c_{TT} * c_{FF} + \frac{R}{2}}$
        where $c_{ij}$ is the number of occurrences of $\mathtt{u[k]} = i$ and $\mathtt{v[k]} = j$ for
        $k < n$ and $R = 2.0 * c_{TF} * c_{FT}$
    \end{itemize}
\end{itemize}

%  \item From scipy.spatial.distance
%       and $x \cdot y$ is the dot product of $x$ and $y$
%       \item mahalanobis: $\sqrt{ (u-v) V^{-1} (u-v)^T }$ where $V$ is the covariance matrix.  Note that the argument $VI$ is the inverse of $V$
%       \item minkowski: ${||u-v||}_p = (\sum{|u_i - v_i|^p})^{1/p}$, parameters required: p
%       \item wminkowski: $\left(\sum{(|w_i (u_i - v_i)|^p)}\right)^{1/p}$, paramteres required: p
%       \item seuclidean: $\sqrt{\sum {(u_i-v_i)^2 / V[x_i]}}$ where $V$ is the variance vector; $V[i]$ is the variance computed over all the i'th components of the points.
%        If not passed, it is automatically computed.
%       \item sqeuclidean: ${||u-v||}_2^2$

%TODO: add tests example, add descriptions about parameters, p, sampled_weight

\begin{itemize}
  \item \xmlNode{p}, \xmlDesc{float, required field}, value for the parameter $p$
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{CDFAreaDifference}

This calculates the difference in area between the two CDFs.  This
metric supports using distributions as input.  Other inputs are
converted to a CDF.

\begin{equation}
  \text{CDF area difference} = \int_{-\infty}^{\infty}{\|CDF_a(x)-CDF_b(x)\|dx}
\end{equation}

This metric has the same units as $x$.  The closer the number is
to zero, the closer the match.  A perfect match would be 0.0.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{PDFCommonArea}

This calculates the common area between the two PDFs.  The higher the
value the closer the PDFs are.  This metric supports distributions as
inputs.  Other inputs are converted to a PDF.

\begin{equation}
  \text{PDF common area} = \int_{-\infty}^{\infty}{\min(PDF_a(x),PDF_b(x))}dx
\end{equation}

A perfect match would be 1.0.
