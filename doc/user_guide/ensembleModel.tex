\section{Using the Ensemble Model}
\label{sec:ensembleModel}

% TODO
% Introduction
% Data Objects are the Key
% Model Definition

In most RAVEN MultiRun steps, a sampler provides a variety of inputs to a model, whose outputs then produce a
set of responses that can be used in many ways.  However, sometimes a single model is insufficient to produce
the response we want.  When this happens, the EnsembleModel opens up a new vista of simulation options.

The EnsembleModel is a powerful tool for chaining multiple models together, with outputs of some models
becoming inputs for others.  Whether this is adding a preprocessing or postprocessing model, or linking
multiple physics-based models together, the EnsembleModel provides the functionality to see many models
together as a single model in a MultiRun step.

Note that the Ensemble Model combines multiple models for \emph{each sample}; that is, the whole ensemble of
models is run for each sample taken by RAVEN.  If instead you want to postprocess a batch of sampled data, try
the PostProcessor models instead.

\subsection{Introduction: The Ensemble Model}
The key to the Ensemble Model is careful definition of the inputs and outputs of each model.  When an
Ensemble Model is defined in a RAVEN run, RAVEN will automatically scan the inputs and outputs of each model
and determine the right order to evaluate the models in (or \emph{graph}).

\subsubsection{Example: ballistics and impact}
% TODO add an image showing these two models, their inputs and outputs
As a basic example, consider two physics models.  The first is a ballistics code, used to determine the
kinetic energy $E$ of a ball when it hits the ground, with a path depending on its initial height $y_0$, initial velocity
$v_0$, mass $m$ and initial angle $\theta_0$.  We'll assume we're near the Earth's surface and aside from the initial
launch height, we're launching over a flat surface.  This can be represented as a functional $E(y_0,v_0,m,\theta_0)$.

The second physics model is an impact code that estimates the diameter of the crater $D$ made when a ball
impacts.  With a few simplifying assumptions ($D$ is under 1 km, the impact is near Earth's surface, the
impact is in dry sand with fixed density), size $D$ can be determined as a function of the ball's kinetic
energy when impacting $E$, its mass $m$, and its radius $r$: $D(E,m,r)$.

We can see that the input $E$ for the impact model is calculated by the ballistics code.  In RAVEN the
ensemble model will automatically detect this, and run the ballistics code before the impact code in each
iteration.

In general, the EnsembleModel also has some finite capacity for resolving circular dependencies using Picard
iteration.  See the manual for more information on this capability.

Setting up an ensemble model can be a tricky process, so we'll walk through the input using our example
outlined above.  For
our purposes, we're going to let RAVEN perturb the codes using the GenericCode interface.  We'll call the
ballistics code \texttt{ballistics.py} with keyword input file \texttt{ballistics\_input.txt} and similarly the impact
code \texttt{impact.py} with keyword input file \texttt{impact\_input.txt}.

The RAVEN input file for this example is located at
\begin{verbatim}
raven/tests/framework/user_guide/EnsembleModel/basic.xml
\end{verbatim}
with run directory \texttt{run\_basic}.  The models and inputs are in the run directory.

Now we turn our attention to the RAVEN input file. We will discuss \xmlNode{DataObjects}, \xmlNode{Files},
\xmlNode{Models}, and \xmlNode{Steps} in detail; the rest are typical usage and need no special attention.

\subsection{DataObjects}
The key to a successful EnsembleModel is setting up the data object inputs and outputs.  Each model has a
\xmlNode{TargetEvaluation} data object that specifies what the inputs and outputs are for that model.  In
addition, any \xmlNode{Output} data objects in the \xmlNode{MultiRun} step can collect any or all of the
variables used throughout the EnsembleModel calculation, either as inputs or outputs.

In this
example, our convention is to name the \xmlNode{TargetEvaluation} data objects as \xmlString{model\_data}, replacing
\xmlString{model} with the model name.  Additionally, we add a data object to store the final results of the
\xmlNode{MultiRun} step:
\xmlExample{framework/user_guide/EnsembleModel/basic.xml}{DataObjects}
In this example, we see three data objects.  \xmlString{ballistics\_data} determines the inputs and outputs of the
\texttt{ballistics.py} model, so for its input space we have \texttt{y0,v0,ang,m}, which correspond to
$y_0,v_0,\theta_0,m$; for the output, we have \texttt{E} (for $E$).

The second data object, \xmlString{impact\_data}, delineates the inputs and outputs of the \texttt{impact.py}
model, so for its input space we have \texttt{E,m,r}, while in the output space we have \texttt{D}.  RAVEN
will use these first two data objects to map the order in which these two models should be run (first
ballistics, then impact) and transfer data from one to the next.

The third data object, \xmlString{final\_results}, can contain any information we want it to.  In this case,
we want to collect all the variables in their original spaces, so we take \texttt{y0,v0,ang,m,r} as inputs and
\texttt{E,D} as outputs.


\subsection{Files}
Since we know both of our models take input files to set the variable values, we inform RAVEN about the
template input files and
give those files RAVEN names in the \xmlNode{Files} block.  In this example, our input file for \texttt{ballistics.py} is
\texttt{ballistics\_template.txt}, which we simply name \xmlString{ballistics\_input}.  Similarly,
for \texttt{impact.py} the input file is \texttt{impact\_template.txt}, which we name
\xmlString{impact\_input}:
\xmlExample{framework/user_guide/EnsembleModel/basic.xml}{Files}
We will pause to note that the file \texttt{ballistics\_template.txt} is different than the file
\texttt{ballistics\_input.py}, and similarly for the impact code.  In the template file, we've replaced
variable values with the \texttt{\$RAVEN-\$} wildcard, since we will be using the Generic Code model for these
two models.  Having a template input file may not be required for all code interfaces, but it is required for
the Generic interface. See more about this interface in the Models section and in the user manual.


\subsection{Models}
Once we've specified the data objects and files, we are prepared to set up the \xmlNode{Models} block.  To set
up an ensemble model, we define each sub-module by itself as if it were a stand-alone RAVEN model, and then
combine them by defining an \xmlNode{EnsembleModel}:
\xmlExample{framework/user_guide/EnsembleModel/basic.xml}{Models}
The first model we will look at is the definition of the \xmlString{ballistics} model.  We note that is uses
the \xmlString{GenericCode} subType, so it will use the interface as described in the user manual, where
wildcards in the input file are replaced with RAVEN's sampled values.  The \xmlNode{clargs} (command line
arguments) include the \xmlString{python} command, the \xmlString{-i} flag to specify the input file, and the
\xmlString{-o} flag to specify the output file.  These nodes are specific to the Generic code interface and
will not apply to all codes or models. The \xmlString{Impact} model is defined in a similar manner.

With both Models defined, we can construct the \xmlNode{EnsembleModel}, which we've named
\xmlString{ballistic\_and\_impact} to describe the codes that are paired (you can name this whatever you
want).  There is no \xmlAttr{subType} for the \xmlNode{EnsembleModel} currently, so we leave it blank.

Within the \xmlNode{EnsembleModel} node there are two \xmlNode{Model} nodes listed, which will inform the
Ensemble Model which models need coupling.  The order listed does not matter; the Ensemble Model will sort out
the order based on the \xmlNode{TargetEvaluation} data objects of each model.

The first \xmlNode{Model} we list within the \xmlNode{EnsembleModel} is the \texttt{ballistics} model.  Note
that the \xmlAttr{class} and \xmlAttr{type} are used along with the name to find the right model.  Note also
the name of the model goes in the \emph{text} of the \xmlNode{Model} node, right after the first closing angle
bracket.  The subnodes of the \xmlString{ballistics} model are the \xmlNode{Input}, which points to the input
template input file we defined in the \xmlNode{Files} block; and the \xmlNode{TargetEvaluation}, which points
to the \xmlNode{PointSet} we defined in the \xmlNode{DataObjects} block.  These are critical to allowing the
Ensemble Model both to run the \xmlString{ballistics} model correctly, as well as the entire ensemble in a
sensible manner.

In general, some models (such as a \xmlNode{ROM} or \xmlNode{ExternalModel}) do not require any files as
inputs.  In this case, the \xmlNode{Input} for an input-less model should be a placeholder data object,
usually with the same input space as the \xmlNode{TargetEvaluation} data object, and a placeholder output.
For more information, see examples running external models in these guides as well as the user manual.

After the \xmlString{ballistics} model, we see a similar structure pointing to the \xmlString{impact} model.
The only differences between this model specification and the ballistics model specificatoin are the names of
the \xmlNode{Input} file and \xmlNode{TargetEvaluation} data object.

That's it!  With the two models defined, and the Ensemble Model assembled, no more work is required to
prepare these two models to run.  More complicated systems may require additional nodes in the ensemble model;
see the user manual for details.

\subsection{Steps}
Finally, to put all the pieces together, we consider the \xmlNode{Steps} node:
\xmlExample{framework/user_guide/EnsembleModel/basic.xml}{Steps}
We take two steps in this simulation, one \xmlNode{MultiRun} called \xmlString{sample} to sample the ensemble model on a grid,
and one \xmlNode{IOStep} to print the results.  These are constructed just as they would be with any other
model; as far as the \xmlNode{Steps} are concerned, the ensemble model is like any other model.  Note that we
include the two template input files as \xmlNode{Input} nodes for the sampling step.

We do not discuss the \xmlNode{Distributions}, \xmlNode{Samplers}, or \xmlNode{OutStreams}
here.  These operate in general as they would in any other RAVEN input file.  We will note, however, that the
\xmlNode{Grid} sampler named \xmlString{grid} samples all the inputs that are needed by either of the submodels,
unless the inputs are provided by another model.  In this case, that means we need to sample
$y_0,\theta_0,v_0,m,r$ but we do not sample $E$ since it is calculated by the \xmlString{ballistics} model.

We can find all the sampled and calculated values from both of the models in the output produced by this run,
found at
\begin{verbatim}
raven/tests/framework/user_guide/EnsembleModel/run_basic/results.csv
\end{verbatim}



%\subsection{External Models in Ensemble Models}
% TODO there's some tricks that should be known, including the [0] for scalars, how to request time-dependent
% variables and the index, etc.
